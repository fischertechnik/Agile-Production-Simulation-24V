[
    {
        "id": "f39c18cc6f60e7a0",
        "type": "tab",
        "label": "NodeRed Init",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "9810df827082ae56",
        "type": "tab",
        "label": "MILL #1",
        "disabled": false,
        "info": "eine Schnittstelle, die den lokalen MQTT-Broker mit\r\ndem OPCUA-Server der Fraese verbindet.",
        "env": []
    },
    {
        "id": "f6c8f50b75376b12",
        "type": "tab",
        "label": "MILL #2",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "05a427a07096ebdb",
        "type": "tab",
        "label": "MILL #3",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "a0e5f985232949c9",
        "type": "tab",
        "label": "MILL #4",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "5fc4fbd01fd96575",
        "type": "tab",
        "label": "MILL #5",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "74c49629fbf36c6c",
        "type": "tab",
        "label": "DRILL #1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "4b7639b8a17bacd0",
        "type": "tab",
        "label": "DRILL #2",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b8be3e0d96a62731",
        "type": "tab",
        "label": "DRILL #3",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "4cb2aa8b5e3c04ee",
        "type": "tab",
        "label": "DRILL #4",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "490d04c5383c1492",
        "type": "tab",
        "label": "DRILL #5",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "2edb0a9a7b9b6718",
        "type": "tab",
        "label": "OVEN #1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "306206362e6386f0",
        "type": "tab",
        "label": "OVEN #2",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "38289fd68fd11ff8",
        "type": "tab",
        "label": "OVEN #3",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "173ad22f4bdd0609",
        "type": "tab",
        "label": "OVEN #4",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "717abb2ca5ab1654",
        "type": "tab",
        "label": "OVEN #5",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "e811f976a7becb7c",
        "type": "tab",
        "label": "AIQS #1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "5983ec78decb4bc7",
        "type": "tab",
        "label": "AIQS #2",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "8464a92f18f7bec3",
        "type": "tab",
        "label": "AIQS #3",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "1b1092be024196cd",
        "type": "tab",
        "label": "AIQS #4",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "2a102a482beaf61c",
        "type": "tab",
        "label": "AIQS #5",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "2ad740b531e49822",
        "type": "tab",
        "label": "HBW #1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "fd2a2507d5769687",
        "type": "tab",
        "label": "HBW #2",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "814355edd4de93bc",
        "type": "tab",
        "label": "HBW #3",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "616d25e29ffaadda",
        "type": "tab",
        "label": "DPS",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "1b897516f5bf21fa",
        "type": "subflow",
        "name": "handle-actions",
        "info": "Flow to handle orders and instantActions",
        "category": "",
        "in": [
            {
                "x": 180,
                "y": 160,
                "wires": [
                    {
                        "id": "35bb3bae6cae9a4c"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 2390,
                "y": 220,
                "wires": [
                    {
                        "id": "dc414fb188f715a6",
                        "port": 0
                    }
                ]
            },
            {
                "x": 2140,
                "y": 680,
                "wires": [
                    {
                        "id": "6c70068076961807",
                        "port": 0
                    }
                ]
            },
            {
                "x": 3060,
                "y": 80,
                "wires": [
                    {
                        "id": "6c733024026db14e",
                        "port": 0
                    },
                    {
                        "id": "4ffa811ecb746d4f",
                        "port": 0
                    },
                    {
                        "id": "09075949c82779fc",
                        "port": 0
                    }
                ]
            },
            {
                "x": 620,
                "y": 200,
                "wires": [
                    {
                        "id": "35bb3bae6cae9a4c",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#b3d2e9",
        "inputLabels": [
            "serialNumber"
        ],
        "outputLabels": [
            "order",
            "supportedInstantAction",
            "forMQTT",
            "afterFactsheetUpdate"
        ],
        "icon": "node-red/parser-json.svg",
        "status": {
            "x": 360,
            "y": 820,
            "wires": [
                {
                    "id": "2950af8db6503c05",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "6a25ecd632542087",
        "type": "subflow",
        "name": "load-factsheet",
        "info": "This flow is used to load a factsheet from the filesystem with the provided path.\r\nUse the configuration of the subflow instance to set the path to the factsheet.\r\n\r\nRemember that it has to be an absolute filepath, otherwise the file will be loaded \r\nrelative to the work directory of the Node-RED process.",
        "category": "",
        "in": [
            {
                "x": 60,
                "y": 160,
                "wires": [
                    {
                        "id": "eccbae14041fd8d1"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 980,
                "y": 100,
                "wires": [
                    {
                        "id": "ae8c0f5da4317371",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-file-o",
                    "label": {
                        "en-US": "Path to factsheet"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "str",
                            "env"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#b3d2e9",
        "outputLabels": [
            "factsheet"
        ],
        "icon": "node-red/parser-json.svg"
    },
    {
        "id": "a91568669d27b6cc",
        "type": "subflow",
        "name": "get-opcua-address",
        "info": "Retrieves an environment variable from the list of global environment variables\r\nand sets it to `msg.endpoint` for use with the Flex Connector.",
        "category": "",
        "in": [],
        "out": [
            {
                "x": 700,
                "y": 80,
                "wires": [
                    {
                        "id": "1221e1a68d16c50c",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "Address",
                "type": "str",
                "value": "OPCUA_ADDRESS",
                "ui": {
                    "icon": "font-awesome/fa-font",
                    "label": {
                        "en-US": "Address"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#b3d2e9",
        "outputLabels": [
            "value of variable"
        ],
        "icon": "node-red/parser-json.svg",
        "status": {
            "x": 840,
            "y": 140,
            "wires": [
                {
                    "id": "21158da447f511de",
                    "port": 0
                },
                {
                    "id": "dfbe04cbe5e0e705",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "ea935d7649fccac4",
        "type": "subflow",
        "name": "update-rack-position",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 60,
                "y": 100,
                "wires": [
                    {
                        "id": "448fc81733591706"
                    }
                ]
            }
        ],
        "out": [],
        "env": [
            {
                "name": "RACK_POSITION",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-archive",
                    "label": {
                        "en-US": "Rack Position"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#b3d2e9",
        "inputLabels": [
            "rackposition-updates"
        ],
        "icon": "node-red/parser-json.svg",
        "status": {
            "x": 300,
            "y": 240,
            "wires": [
                {
                    "id": "f965220d4db8fa46",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "7173b966cb38f0e0",
        "type": "subflow",
        "name": "update-calibration",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 60,
                "y": 140,
                "wires": [
                    {
                        "id": "32b0de7a18bf11ad"
                    }
                ]
            }
        ],
        "out": [],
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-bullseye",
                    "label": {
                        "en-US": "Available Positions"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "CURRENT_POSITION",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-bullseye",
                    "label": {
                        "en-US": "Current Position"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            }
        ],
        "meta": {},
        "color": "#b3d2e9",
        "inputLabels": [
            "calib-values"
        ],
        "icon": "node-red/parser-json.svg",
        "status": {
            "x": 960,
            "y": 160,
            "wires": [
                {
                    "id": "030b08ea813bc11c",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "fb6b02d4d9963179",
        "type": "subflow",
        "name": "vda-status-finished InstantAction",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 80,
                "y": 80,
                "wires": [
                    {
                        "id": "a065343fb9fd80f0"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 520,
                "y": 80,
                "wires": [
                    {
                        "id": "a065343fb9fd80f0",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#FDD0A2",
        "outputLabels": [
            "toMQTT"
        ],
        "icon": "node-red/status.svg",
        "status": {
            "x": 320,
            "y": 160,
            "wires": [
                {
                    "id": "b9c02eadd51d2391",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "07a7fc5bcd60a12a",
        "type": "subflow",
        "name": "vda-status-running InstantAction",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 180,
                "y": 120,
                "wires": [
                    {
                        "id": "f77653d3181ab432"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 620,
                "y": 120,
                "wires": [
                    {
                        "id": "f77653d3181ab432",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#FDD0A2",
        "outputLabels": [
            "toMQTT"
        ],
        "icon": "node-red/status.svg",
        "status": {
            "x": 420,
            "y": 200,
            "wires": [
                {
                    "id": "2490563da31e8fd4",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "105d02aba31c4a1d",
        "type": "subflow",
        "name": "check-nodeValue-is-true",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 40,
                "y": 80,
                "wires": [
                    {
                        "id": "2eb17eba88eb7a2a"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 390,
                "y": 80,
                "wires": [
                    {
                        "id": "2eb17eba88eb7a2a",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#FDD0A2",
        "inputLabels": [
            "opcua-boolean"
        ],
        "outputLabels": [
            "is-true"
        ],
        "icon": "node-red/alert.svg",
        "status": {
            "x": 300,
            "y": 160,
            "wires": [
                {
                    "id": "bfe7d55dce5e2b71",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "468f2460ce66f11e",
        "type": "subflow",
        "name": "check-opcua-connection",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 40,
                "y": 80,
                "wires": [
                    {
                        "id": "e439d1ef2174715f"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 850,
                "y": 80,
                "wires": [
                    {
                        "id": "e439d1ef2174715f",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#FDD0A2",
        "inputLabels": [
            "OPCUA-Messages"
        ],
        "outputLabels": [
            "MQTT-Status"
        ],
        "icon": "node-red/status.svg",
        "status": {
            "x": 240,
            "y": 280,
            "wires": [
                {
                    "id": "d8c7f42fd8b72ff8",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "281fe79168d00793",
        "type": "group",
        "z": "f39c18cc6f60e7a0",
        "name": "Global-Reset",
        "style": {
            "stroke": "none",
            "fill": "#ffbfbf",
            "label": true,
            "color": "#000000",
            "fill-opacity": "0.3"
        },
        "nodes": [
            "68c74d703a2b2cdc",
            "9a5f8404f15c499e",
            "2571fe942764589b",
            "67b7ecc6ac892f54"
        ],
        "x": 94,
        "y": 579,
        "w": 752,
        "h": 82
    },
    {
        "id": "aff14dfdae4dbb82",
        "type": "group",
        "z": "e811f976a7becb7c",
        "name": "CHECK_QUALITY for TXT",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "0f8e9d8c8f4a575f",
            "1962f3637834741d",
            "9af9245fe6cabd23"
        ],
        "x": 1254,
        "y": 1919,
        "w": 562,
        "h": 102
    },
    {
        "id": "560d87a37ea3206d",
        "type": "group",
        "z": "e811f976a7becb7c",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "c888f042e90e4194",
            "5e2bda4e6e0fc62f"
        ],
        "x": 1254,
        "y": 2039,
        "w": 562,
        "h": 82
    },
    {
        "id": "70e8a1e72bab6ed8",
        "type": "group",
        "z": "e811f976a7becb7c",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "dcf42524a6fd0a16",
            "72720acb4bb56133",
            "fa8f7be0e2ec5707"
        ],
        "x": 54,
        "y": 359,
        "w": 672,
        "h": 122
    },
    {
        "id": "2a3a170984a0b0b4",
        "type": "group",
        "z": "2ad740b531e49822",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "2afdd84f46e20aa2",
            "88f413abe5572359",
            "177fbb831c55dd70"
        ],
        "x": 74,
        "y": 319,
        "w": 672,
        "h": 122
    },
    {
        "id": "d4589490bc22cdbd",
        "type": "group",
        "z": "fd2a2507d5769687",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "ad34b1839a6c08f8",
            "98c2222cc6522015",
            "50ab54e952166f62"
        ],
        "x": 54,
        "y": 279
    },
    {
        "id": "b1275603c54863e5",
        "type": "group",
        "z": "814355edd4de93bc",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "197f631d3bf14322",
            "cf8e6cdf952dc7ec",
            "56a54db18c10d5c1"
        ],
        "x": 54,
        "y": 279
    },
    {
        "id": "9d1b70bc07095e3a",
        "type": "group",
        "z": "616d25e29ffaadda",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "6a3050f1d6bb1ff8",
            "c315836ebc16f905",
            "51a0da5752d71ee6"
        ],
        "x": 54,
        "y": 299,
        "w": 672,
        "h": 122
    },
    {
        "id": "862accde4aa78908",
        "type": "group",
        "z": "e811f976a7becb7c",
        "name": "CHECK_QUALITY for Calibration Image",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "447290c98fb2d68a",
            "690bfd6eb41abf49"
        ],
        "x": 1194,
        "y": 939,
        "w": 302,
        "h": 82
    },
    {
        "id": "02a99316069e846c",
        "type": "group",
        "z": "5983ec78decb4bc7",
        "name": "CHECK_QUALITY for TXT",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "c41634c33dc1a26c",
            "c3e7e0944c5547b7",
            "6825856480022034"
        ],
        "x": 1254,
        "y": 1919,
        "w": 562,
        "h": 102
    },
    {
        "id": "da420d3af67fe5a9",
        "type": "group",
        "z": "5983ec78decb4bc7",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "5c30fd08617e64cc",
            "2730ae1cd4ff848b"
        ],
        "x": 1254,
        "y": 2039,
        "w": 562,
        "h": 82
    },
    {
        "id": "41988cae3f051d53",
        "type": "group",
        "z": "5983ec78decb4bc7",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "781cee4c2fbbd5cc",
            "31ebdff3f43512e3",
            "0837e84a0f2c7c79"
        ],
        "x": 54,
        "y": 359,
        "w": 672,
        "h": 122
    },
    {
        "id": "92b27bc5accb5f67",
        "type": "group",
        "z": "5983ec78decb4bc7",
        "name": "CHECK_QUALITY for Calibration Image",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "d8e8ddfd4d983fb2",
            "05fb4949e855ecdb"
        ],
        "x": 1194,
        "y": 939,
        "w": 302,
        "h": 82
    },
    {
        "id": "5f52012546de3448",
        "type": "group",
        "z": "8464a92f18f7bec3",
        "name": "CHECK_QUALITY for TXT",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "68b36603ad32ed4c",
            "9cf47619cbda5eb6",
            "224d482957f829ee"
        ],
        "x": 1254,
        "y": 1919,
        "w": 562,
        "h": 102
    },
    {
        "id": "939867a7fa679cd3",
        "type": "group",
        "z": "8464a92f18f7bec3",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "840721abe690fff2",
            "e5e319b9e29e3efb"
        ],
        "x": 1254,
        "y": 2039,
        "w": 562,
        "h": 82
    },
    {
        "id": "dbe76557bf1b2e57",
        "type": "group",
        "z": "8464a92f18f7bec3",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "1cd9010796403284",
            "4bee5bcd05c146dd",
            "dfe57bc9cc92f06a"
        ],
        "x": 54,
        "y": 359,
        "w": 672,
        "h": 122
    },
    {
        "id": "a94292f1e209f59e",
        "type": "group",
        "z": "8464a92f18f7bec3",
        "name": "CHECK_QUALITY for Calibration Image",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "bf54f3b280aea5d8",
            "1dbbe2eabe308dd5"
        ],
        "x": 1194,
        "y": 939,
        "w": 302,
        "h": 82
    },
    {
        "id": "ad86cf337e1bde88",
        "type": "group",
        "z": "1b1092be024196cd",
        "name": "CHECK_QUALITY for TXT",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "3319ba635fab1198",
            "318ccf97af04b4ec",
            "f9f34853b704e98a"
        ],
        "x": 1254,
        "y": 1919,
        "w": 562,
        "h": 102
    },
    {
        "id": "c49eb867beb3380f",
        "type": "group",
        "z": "1b1092be024196cd",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "64302493fb9a84f9",
            "aa93bb735679ddfa"
        ],
        "x": 1254,
        "y": 2039,
        "w": 562,
        "h": 82
    },
    {
        "id": "a1f9318bc31d47e4",
        "type": "group",
        "z": "1b1092be024196cd",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "161eb1db24684544",
            "5445f42677a66cab",
            "d30288bc7ae85c30"
        ],
        "x": 54,
        "y": 359,
        "w": 672,
        "h": 122
    },
    {
        "id": "1698cba31e843cb7",
        "type": "group",
        "z": "1b1092be024196cd",
        "name": "CHECK_QUALITY for Calibration Image",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "1f076ed3d2c2e1f9",
            "7b431bd530678e41"
        ],
        "x": 1194,
        "y": 939,
        "w": 302,
        "h": 82
    },
    {
        "id": "5456ca6e757fd98c",
        "type": "group",
        "z": "2a102a482beaf61c",
        "name": "CHECK_QUALITY for TXT",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "3e6dc1ec1d4b7727",
            "d7cf5c1c7eb941da",
            "f4d035248a74db5b"
        ],
        "x": 1254,
        "y": 1919,
        "w": 562,
        "h": 102
    },
    {
        "id": "dc41eb65e9d073ae",
        "type": "group",
        "z": "2a102a482beaf61c",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "11d42c1894748abb",
            "b59e7bd20a2a8685"
        ],
        "x": 1254,
        "y": 2039,
        "w": 562,
        "h": 82
    },
    {
        "id": "ffcb1614f967f203",
        "type": "group",
        "z": "2a102a482beaf61c",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "0a3f05f5b2f69deb",
            "1923fe0a5404d562",
            "5a76ea7d68985e91"
        ],
        "x": 54,
        "y": 359,
        "w": 672,
        "h": 122
    },
    {
        "id": "baaef4559a65316c",
        "type": "group",
        "z": "2a102a482beaf61c",
        "name": "CHECK_QUALITY for Calibration Image",
        "style": {
            "stroke": "#ffC000",
            "label": true
        },
        "nodes": [
            "a6be67d2813c9253",
            "e6e147eb63c68172"
        ],
        "x": 1194,
        "y": 939,
        "w": 302,
        "h": 82
    },
    {
        "id": "5218755bb1725ef8",
        "type": "group",
        "z": "616d25e29ffaadda",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "bc26a735805965bd",
            "59f18557de90da57",
            "1bc0a242bc419c4f",
            "09b4b5a556d8a94a",
            "06d80e3d59c38d1c",
            "6ef8c2588adea0a2",
            "75f3c6b5c505a6a0",
            "148850ccd1c7c024"
        ],
        "x": 214,
        "y": 2119,
        "w": 1192,
        "h": 182
    },
    {
        "id": "15b84ed331dcc49c",
        "type": "mqtt-broker",
        "name": "Lokal_MQTT",
        "broker": "192.168.2.189",
        "port": "1883",
        "clientid": "",
        "autoConnect": false,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "5",
        "cleansession": true,
        "birthTopic": "module/v1/ff/NodeRed/status",
        "birthQos": "1",
        "birthRetain": "true",
        "birthPayload": "{\"connectionState\":\"ONLINE\"}",
        "birthMsg": {},
        "closeTopic": "module/v1/ff/NodeRed/status",
        "closeQos": "1",
        "closeRetain": "true",
        "closePayload": "{\"connectionState\":\"OFFLINE\"}",
        "closeMsg": {},
        "willTopic": "module/v1/ff/NodeRed/status",
        "willQos": "1",
        "willRetain": "true",
        "willPayload": "{\"connectionState\":\"CONNECTIONBROKEN\"}",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "f8824f864369a41f",
        "type": "OPCUA-IIoT-Connector",
        "z": "9810df827082ae56",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.40:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "MILL_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "1000",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "a2de3bab55be08b7",
        "type": "OPCUA-IIoT-Connector",
        "z": "74c49629fbf36c6c",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.50:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "DRILL1_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "1000",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "fdbb80558db436be",
        "type": "OPCUA-IIoT-Connector",
        "z": "2edb0a9a7b9b6718",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.60:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "OVEN1_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "1000",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "8b41c5e43074a4eb",
        "type": "OPCUA-IIoT-Connector",
        "z": "e811f976a7becb7c",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.70:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "AIQS1_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "1000",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "b58c2380ef5679ca",
        "type": "OPCUA-IIoT-Connector",
        "z": "616d25e29ffaadda",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.90:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "DPS_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "1000",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "42eb75176feb84b0",
        "type": "OPCUA-IIoT-Connector",
        "z": "2ad740b531e49822",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.80:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "HBW1_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "1000",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "10c631e5670ce5e1",
        "type": "OPCUA-IIoT-Connector",
        "z": "f6c8f50b75376b12",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.41:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "MILL2_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "7859b273f274fc48",
        "type": "OPCUA-IIoT-Connector",
        "z": "05a427a07096ebdb",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.42:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "MILL3_OPCUA",
        "showErrors": false,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "7934c6af334404ef",
        "type": "OPCUA-IIoT-Connector",
        "z": "fd2a2507d5769687",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.81:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "HBW2_OPCUA",
        "showErrors": false,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "2933482444424b0c",
        "type": "OPCUA-IIoT-Connector",
        "z": "4b7639b8a17bacd0",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.51:4840/",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "DRILL2_OPCUA",
        "showErrors": false,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "014fc68d7d610e9d",
        "type": "OPCUA-IIoT-Connector",
        "z": "a0e5f985232949c9",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.43:4840/",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "MILL4_OPCUA",
        "showErrors": false,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "dc24d4023df4a98c",
        "type": "OPCUA-IIoT-Connector",
        "z": "5fc4fbd01fd96575",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.44:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "MILL5_OPCUA",
        "showErrors": false,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "e27138419046abbf",
        "type": "OPCUA-IIoT-Connector",
        "z": "b8be3e0d96a62731",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.52:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "DRILL3_OPCUA",
        "showErrors": false,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "05aa9778d001b499",
        "type": "OPCUA-IIoT-Connector",
        "z": "4cb2aa8b5e3c04ee",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.53:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "DRILL4_OPCUA",
        "showErrors": false,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "86523aff067d7a39",
        "type": "OPCUA-IIoT-Connector",
        "z": "490d04c5383c1492",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.54:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "DRILL5_OPCUA",
        "showErrors": false,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "3f264405b1bd9be7",
        "type": "OPCUA-IIoT-Connector",
        "z": "306206362e6386f0",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.61:4840/",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "OVEN2_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "ac4f033c5eb8a63f",
        "type": "OPCUA-IIoT-Connector",
        "z": "814355edd4de93bc",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.82:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "HBW3_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "fc2df9e2fa177319",
        "type": "OPCUA-IIoT-Connector",
        "z": "38289fd68fd11ff8",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.62:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "OVEN3_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "ec2f41c16c4ad7be",
        "type": "OPCUA-IIoT-Connector",
        "z": "173ad22f4bdd0609",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.63:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "OVEN4_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "235ad3137d70c021",
        "type": "OPCUA-IIoT-Connector",
        "z": "717abb2ca5ab1654",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.64:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "OVEN5_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "2a0ef4a50b3b9fe6",
        "type": "OPCUA-IIoT-Connector",
        "z": "5983ec78decb4bc7",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.71:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "AIQS2_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "0c00108717efa66b",
        "type": "OPCUA-IIoT-Connector",
        "z": "8464a92f18f7bec3",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.72:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "AIQS3_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "bcbb883b31fd5d88",
        "type": "OPCUA-IIoT-Connector",
        "z": "1b1092be024196cd",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.73:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "AIQS4_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "712b60d60ce311d2",
        "type": "OPCUA-IIoT-Connector",
        "z": "2a102a482beaf61c",
        "discoveryUrl": "",
        "endpoint": "opc.tcp://192.168.0.74:4840",
        "endpointMustExist": false,
        "keepSessionAlive": true,
        "loginEnabled": false,
        "name": "AIQS5_OPCUA",
        "showErrors": true,
        "securityPolicy": "None",
        "securityMode": "None",
        "individualCerts": false,
        "publicCertificateFile": "",
        "privateKeyFile": "",
        "defaultSecureTokenLifetime": "",
        "autoSelectRightEndpoint": false,
        "strategyMaxRetry": "",
        "strategyInitialDelay": "",
        "strategyMaxDelay": "",
        "strategyRandomisationFactor": "",
        "requestedSessionTimeout": "",
        "connectionStartDelay": "",
        "reconnectDelay": "",
        "maxBadSessionRequests": "10"
    },
    {
        "id": "4ffa811ecb746d4f",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "connection state",
        "func": "// connection Nachtricht bauen\nconst serialNumber = flow.get(\"$parent.serialNumber\");\nconst connection = flow.get(\"$parent.connection\");\nconnection.serialNumber = serialNumber;\nconnection.timestamp = new Date().toISOString();\n\nmsg.topic = flow.get(\"$parent.MQTT_topic\") + \"/connection\";\nmsg.payload = connection;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "12b7f30f89fc2761",
        "type": "mqtt in",
        "z": "1b897516f5bf21fa",
        "name": "dynamic Connection",
        "topic": "",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 1,
        "x": 810,
        "y": 480,
        "wires": [
            [
                "19c73938a34f7397",
                "8ce2f7c2955c85f4"
            ]
        ]
    },
    {
        "id": "d53a1400a9f46117",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "sub order",
        "func": "msg.topic = flow.get(\"$parent.MQTT_topic\") + \"/order\";\nmsg.action = \"subscribe\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 380,
        "wires": [
            [
                "12b7f30f89fc2761"
            ]
        ]
    },
    {
        "id": "e2dfb17bae4243cf",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "sub instantAction",
        "func": "msg.topic = flow.get(\"$parent.MQTT_topic\") + \"/instantAction\";\nmsg.action = \"subscribe\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 600,
        "wires": [
            [
                "12b7f30f89fc2761"
            ]
        ]
    },
    {
        "id": "6c733024026db14e",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "leere state",
        "func": "const state = flow.get(\"$parent.state\");\nconst loads = flow.get(\"$parent.loads\");\nstate.timestamp = new Date().toISOString();\nstate.actionState = null;\nstate.loads = loads ?? [];\nmsg.topic = flow.get(\"$parent.MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "35bb3bae6cae9a4c",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "factsheet Update",
        "func": "// Timestamp\nconst timestamp = new Date().toISOString();\n\nconst serialNumberObj = msg.payload.resultsConverted[0] ?? {};\nif (!serialNumberObj.value) {\n    node.error(\"SerialNumber is not available\", msg.payload);\n    return;\n}\nconst serialNumber = serialNumberObj.value.trim().replace(\" \", \"\").replace(\"-\", \"\");\nconst modelObj = msg.payload.resultsConverted[1] ?? {};\nconst model = modelObj.value ?? \"Unknown\";\nconst versionObj = msg.payload.resultsConverted[2] ?? {};\nconst version = versionObj.value ?? \"N/A\";\nmsg.model = model;\nmsg.serialNumber = serialNumber;\nmsg.version = version\n\n// Werte in Flow speichern\nflow.set('$parent.MQTT_topic', 'module/v1/ff/' + serialNumber);\nflow.set(\"$parent.modell\", model);\nflow.set(\"$parent.serialNumber\", serialNumber);\nflow.set(\"$parent.version\", version);\n\nnode.status({ shape: \"dot\", fill: \"green\", text: `${serialNumber} / ${model}`})\n\n// state serialNumber update\nconst state = flow.get(\"$parent.state\");\nstate.serialNumber = serialNumber;\nflow.set(\"$parent.state\", state);\n\n// connection update\nconst connection = flow.get(\"$parent.connection\");\nconnection.version = version;\nflow.set(\"$parent.connection\", connection);\n\n// factsheet Update\nconst factsheet = flow.get(\"$parent.factsheet\");\nfactsheet.serialNumber = serialNumber;\nfactsheet.version = version;\nfactsheet.typeSpecification.seriesName = \"MOD-FF22+\" + model + \"+24V\";\nfactsheet.typeSpecification.moduleClass = model;\nflow.set(\"$parent.factsheet\", factsheet);\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 160,
        "wires": [
            [
                "d53a1400a9f46117",
                "e2dfb17bae4243cf",
                "f4b7c39ee4f042c6",
                "01e8a5d11f1c807c"
            ]
        ]
    },
    {
        "id": "f4b7c39ee4f042c6",
        "type": "delay",
        "z": "1b897516f5bf21fa",
        "name": "Verzögerung",
        "pauseType": "delay",
        "timeout": "100",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 570,
        "y": 80,
        "wires": [
            [
                "6c733024026db14e"
            ]
        ]
    },
    {
        "id": "01e8a5d11f1c807c",
        "type": "delay",
        "z": "1b897516f5bf21fa",
        "name": "Verzögerung",
        "pauseType": "delay",
        "timeout": "100",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 570,
        "y": 120,
        "wires": [
            [
                "4ffa811ecb746d4f"
            ]
        ]
    },
    {
        "id": "19c73938a34f7397",
        "type": "switch",
        "z": "1b897516f5bf21fa",
        "name": "topicswitch",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "order",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "instantAction",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1030,
        "y": 480,
        "wires": [
            [
                "17adb789ba506056",
                "053f4854f9598be5"
            ],
            [
                "28872e6dafa9e3de",
                "053f4854f9598be5",
                "a974696dd4a89e76"
            ]
        ]
    },
    {
        "id": "09075949c82779fc",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "Publish vda_status_FAILED",
        "func": "// state bauen\nconst state = flow.get(\"$parent.state\");\nstate.headerId = parseInt(flow.get(\"$parent.headerId\"), 10);\nstate.loads = flow.get(\"$parent.loads\");\nstate.actionState = flow.get(\"$parent.actionState\");\nstate.actionState.id = msg.actionId;\nstate.actionState.state = \"FAILED\";\nstate.actionState.command = msg.order ?? msg.instantAction;\nstate.timestamp = new Date().toISOString();\nstate.orderId = msg.orderId;\nstate.orderUpdateId = msg.orderUpdateId;\nconst flowErrors = flow.get(\"$parent.errors\");\nstate.errors = flowErrors ? Array.isArray(flowErrors) ? flowErrors : [flowErrors] : [];\n\n// flow update\nflow.set(\"$parent.headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"$parent.MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3020,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "fed3de4f18bfc373",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "isInstantAction?",
        "func": "if (!msg.instantAction) {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"$parent.headerId\") },\n            { \"orderId\": msg.orderId },\n            { \"orderUpdateId\": msg.orderUpdateId }\n        ],\n        \"errorMessage\": \"Not an instantAction\"\n    }\n    // Error in Flow\n    flow.set(\"$parent.errors\", error);\n    return [undefined, msg];\n}\nreturn msg;",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1580,
        "y": 740,
        "wires": [
            [
                "6c70068076961807"
            ],
            [
                "09075949c82779fc"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "instantAction",
            "error"
        ]
    },
    {
        "id": "3ebde9ba7aa9d231",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "matchesSerialNumber?",
        "func": "const serialNumber = flow.get(\"$parent.serialNumber\") ?? \"MISSING-SERIALNUMBER\";\nif (msg.serialNumber != serialNumber) {\n    const headerId = flow.get(\"$parent.headerId\");\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": headerId },\n            { \"orderId\": msg.orderId },\n            { \"orderUpdateId\": msg.orderUpdateId }\n        ],\n        \"errorMessage\": \"SerialNumber does not match\"\n    }\n    // Error in Flow\n    flow.set(\"$parent.errors\", error);\n    return [null, msg];\n}\nreturn msg;",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 780,
        "wires": [
            [
                "fed3de4f18bfc373"
            ],
            [
                "09075949c82779fc"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "instantAction",
            "error"
        ]
    },
    {
        "id": "28872e6dafa9e3de",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "expand-instant-action-payload",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\nif (!msg.payload) {\n    return;\n}\n\nconst action = (msg.payload.actions ?? [])[0];\nconst instantAction = action?.actionType;\nconst actionId = action?.actionId;\nconst actionMetadata = action?.metadata ?? {};\nconst serialNumber = msg.payload.serialNumber ?? \"NoSerial\";\nconst orderId = msg.payload.orderId;\nconst orderUpdateId = msg.payload.orderUpdateId;\n\nmsg.instantAction = instantAction;\nmsg.actionId = actionId;\nmsg.actionMetadata = actionMetadata;\nmsg.actionCommand = instantAction;\nmsg.actionState = updateActionState(\"PENDING\", actionMetadata);\nflow.set(\"$parent.actionState\", msg.actionState);\nnode.status({ fill: \"green\", shape: \"ring\", text: msg.instantAction });\nmsg.serialNumber = serialNumber;\nmsg.orderId = orderId;\nmsg.orderUpdateId = orderUpdateId;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 740,
        "wires": [
            [
                "3ebde9ba7aa9d231"
            ]
        ]
    },
    {
        "id": "6c70068076961807",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "isSupportedInstantAction?",
        "func": "/**\n * @typedef {object} ModuleAction\n * @property {string} actionType\n * @property {string[]} actionScopes\n * @property {object[]} actionParameters\n * \n * @typedef {object} ProtocolFeatures\n * @property {ModuleAction[]} moduleActions\n * \n * @typedef {object} Factsheet\n * @property {ProtocolFeatures} protocolFeatures\n */\n\n/** @type {Factsheet} */\nconst factsheet = flow.get(\"$parent.factsheet\");\nconst factsheetInstantActions = factsheet.protocolFeatures.moduleActions.filter(act => {\n    return (act.actionScopes ?? []).includes(\"INSTANT\");\n}).map(act => act.actionType);\nconst supportedInstantActions = [\"factsheetRequest\", \"SET_STORAGE\", \"setStatusLED\", \"reset\", ...factsheetInstantActions];\nif (supportedInstantActions.indexOf(msg.instantAction) == -1) {\n    return;\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1850,
        "y": 700,
        "wires": [
            []
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "instantAction"
        ]
    },
    {
        "id": "00a4b26a1a2f10a2",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "matchesSerialNumber?",
        "func": "const serialNumber = flow.get(\"$parent.serialNumber\") ?? \"MISSING-SERIALNUMBER\";\nif (msg.serialNumber != serialNumber) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"$parent.headerId\") },\n            { \"orderId\": msg.orderId },\n            { \"orderUpdateId\": msg.orderUpdateId }\n        ],\n        \"errorMessage\": \"SerialNumber does not match\"\n    }\n    // Error in Flow\n    flow.set(\"$parent.errors\", error);\n    return [null, msg];\n}\nreturn msg;",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 220,
        "wires": [
            [
                "80215b551d9f0179"
            ],
            [
                "09075949c82779fc"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "instantAction",
            "error"
        ]
    },
    {
        "id": "17adb789ba506056",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "expand-order-action-payload",
        "func": "if (!msg.payload) {\n    return;\n}\n\nconst orderCommand = msg.payload.action?.command;\nconst actionId = msg.payload.action?.id;\nconst serialNumber = msg.payload.serialNumber ?? \"NoSerial\";\nconst orderId = msg.payload.orderId;\nconst orderUpdateId = msg.payload.orderUpdateId;\n\nmsg.order = orderCommand;\nmsg.orderAction = msg.payload.action;\nmsg.actionId = actionId;\nmsg.serialNumber = serialNumber;\nmsg.orderId = orderId;\nmsg.orderUpdateId = orderUpdateId;\nnode.status({ fill: \"green\", shape: \"dot\", text: orderCommand });\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1020,
        "y": 340,
        "wires": [
            [
                "00a4b26a1a2f10a2"
            ]
        ]
    },
    {
        "id": "80215b551d9f0179",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "isOrder?",
        "func": "if (!msg.order) {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"$parent.headerId\") },\n            { \"orderId\": msg.orderId },\n            { \"orderUpdateId\": msg.orderUpdateId }\n        ],\n        \"errorMessage\": \"Not an order\"\n    }\n    // Error in Flow\n    flow.set(\"$parent.errors\", error);\n    return [undefined, msg];\n}\nreturn msg;",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 220,
        "wires": [
            [
                "fbf2c5966ac5388c"
            ],
            [
                "09075949c82779fc"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "instantAction",
            "error"
        ]
    },
    {
        "id": "fbf2c5966ac5388c",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "isSupportedOrder?",
        "func": "/**\n * @typedef {object} ModuleAction\n * @property {string} actionType\n * @property {string[]} actionScopes\n * @property {object[]} actionParameters\n * \n * @typedef {object} ProtocolFeatures\n * @property {ModuleAction[]} moduleActions\n * \n * @typedef {object} Factsheet\n * @property {ProtocolFeatures} protocolFeatures\n */\n\n/** @type {Factsheet} */\nconst factsheet = flow.get(\"$parent.factsheet\");\nconst supportedActions = factsheet.protocolFeatures.moduleActions.filter(act => {\n    return act.actionScopes == undefined || \n    act.actionScopes.includes(\"NODE\") || \n    act.actionScopes.includes(\"ORDER\");\n}).map(act => act.actionType);\nif (supportedActions.indexOf(msg.order) == -1) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"$parent.headerId\") },\n            { \"orderId\": msg.orderId },\n            { \"orderUpdateId\": msg.orderUpdateId }\n        ],\n        \"errorMessage\": `Command \"${msg.order}\" is not supported`\n    }\n    // Error in Flow\n    flow.set(\"$parent.errors\", error);\n    return [undefined, msg];\n}\nreturn msg;",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 220,
        "wires": [
            [
                "572f37e8b111b091"
            ],
            [
                "09075949c82779fc"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "instantAction",
            "error"
        ]
    },
    {
        "id": "dc414fb188f715a6",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "isMatchingOrderId?",
        "func": "const existingOrderId = flow.get(\"$parent.orderId\");\nconst actionState = flow.get(\"$parent.actionState.state\");\n\nif (actionState == \"FINISHED\" || actionState == \"FAILED\") {\n    flow.set(\"$parent.orderId\", msg.orderId);\n    return msg;\n}\n\nif (msg.orderId == existingOrderId || existingOrderId == \"0\") {\n    flow.set(\"$parent.orderId\", msg.orderId);\n    return msg;\n}\n\nconst error = {\n    \"errorType\": \"Validation\",\n    \"errorLevel\": \"WARNING\",\n    \"errorReferences\": [\n        { \"topic\": \"order\" },\n        { \"headerId\": flow.get(\"$parent.headerId\") },\n        { \"orderId\": msg.orderId },\n        { \"orderUpdateId\": msg.orderUpdateId }\n    ],\n    \"errorMessage\": `OrderId \"${msg.orderId}\" not valid`\n}\n// Error in Flow\nflow.set(\"$parent.errors\", error);\nreturn [null, msg];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2150,
        "y": 220,
        "wires": [
            [],
            [
                "09075949c82779fc"
            ]
        ],
        "inputLabels": [
            "order"
        ],
        "outputLabels": [
            "order",
            "error"
        ]
    },
    {
        "id": "572f37e8b111b091",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "discard-duplicate-order",
        "func": "const knownOrderId = flow.get(\"$parent.orderId\");\nconst knownOrderUpdateId = flow.get(\"$parent.orderUpdateId\");\nconst receivedOrderId = msg.orderId;\nconst receivedOrderUpdateId = msg.orderUpdateId;\n\nif (knownOrderId == receivedOrderId && knownOrderUpdateId == receivedOrderUpdateId) {\n    return;\n}\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1920,
        "y": 220,
        "wires": [
            [
                "dc414fb188f715a6"
            ]
        ]
    },
    {
        "id": "f6506332d8af5a22",
        "type": "debug",
        "z": "1b897516f5bf21fa",
        "name": "after-topic-switch",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1450,
        "y": 480,
        "wires": []
    },
    {
        "id": "053f4854f9598be5",
        "type": "function",
        "z": "1b897516f5bf21fa",
        "name": "extract-model",
        "func": "msg.model = msg.model ?? flow.get(\"$parent.modell\");\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1240,
        "y": 480,
        "wires": [
            [
                "f6506332d8af5a22"
            ]
        ]
    },
    {
        "id": "56cf1074a6a1ec73",
        "type": "catch",
        "z": "1b897516f5bf21fa",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 240,
        "y": 780,
        "wires": [
            [
                "061ca8669fccfa25"
            ]
        ]
    },
    {
        "id": "061ca8669fccfa25",
        "type": "debug",
        "z": "1b897516f5bf21fa",
        "name": "debug-catch-all",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 420,
        "y": 780,
        "wires": []
    },
    {
        "id": "2950af8db6503c05",
        "type": "status",
        "z": "1b897516f5bf21fa",
        "name": "",
        "scope": null,
        "x": 240,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "8ce2f7c2955c85f4",
        "type": "debug",
        "z": "1b897516f5bf21fa",
        "name": "from-mqtt",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1020,
        "y": 540,
        "wires": []
    },
    {
        "id": "a974696dd4a89e76",
        "type": "debug",
        "z": "1b897516f5bf21fa",
        "name": "Instant Action",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 580,
        "wires": []
    },
    {
        "id": "7fea810e0a1a626a",
        "type": "file in",
        "z": "6a25ecd632542087",
        "name": "",
        "filename": "factsheetFile",
        "filenameType": "msg",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "utf8",
        "allProps": false,
        "x": 340,
        "y": 100,
        "wires": [
            [
                "d329b63e50c70622"
            ]
        ]
    },
    {
        "id": "d329b63e50c70622",
        "type": "json",
        "z": "6a25ecd632542087",
        "name": "",
        "property": "payload",
        "action": "obj",
        "pretty": false,
        "x": 530,
        "y": 100,
        "wires": [
            [
                "ae8c0f5da4317371"
            ]
        ]
    },
    {
        "id": "ae8c0f5da4317371",
        "type": "function",
        "z": "6a25ecd632542087",
        "name": "updateFactsheet",
        "func": "const factsheet = msg.payload ?? {};\n\n// update the timestamp\nfactsheet.timestamp = new Date().toISOString();\n\n// set factsheet to payload after all updates\nmsg.factsheet = factsheet;\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "2df87e11e653a880",
        "type": "inject",
        "z": "6a25ecd632542087",
        "name": "",
        "props": [
            {
                "p": "factsheetFile",
                "v": "FACTSHEET_FILE",
                "vt": "env"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "x": 150,
        "y": 100,
        "wires": [
            [
                "7fea810e0a1a626a"
            ]
        ]
    },
    {
        "id": "eccbae14041fd8d1",
        "type": "template",
        "z": "6a25ecd632542087",
        "name": "",
        "field": "factsheetFile",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "{{$env[\"FACTSHEET_FILE\"]}}",
        "output": "str",
        "x": 160,
        "y": 160,
        "wires": [
            [
                "7fea810e0a1a626a"
            ]
        ]
    },
    {
        "id": "f0c23c25821f9eb5",
        "type": "inject",
        "z": "a91568669d27b6cc",
        "name": "",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.3",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 190,
        "y": 80,
        "wires": [
            [
                "1221e1a68d16c50c"
            ]
        ]
    },
    {
        "id": "1221e1a68d16c50c",
        "type": "function",
        "z": "a91568669d27b6cc",
        "name": "get environment variable",
        "func": "const globalEnvs = global.get('env');\nconst variableName = env.get('VARIABLE_NAME');\nconst endpoint = globalEnvs[variableName];\nmsg.endpoint = endpoint ?? variableName;\nmsg.payload = {\n    endpoint,\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 80,
        "wires": [
            [
                "21158da447f511de"
            ]
        ]
    },
    {
        "id": "21158da447f511de",
        "type": "template",
        "z": "a91568669d27b6cc",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "{{{payload.endpoint}}}",
        "output": "str",
        "x": 680,
        "y": 140,
        "wires": [
            []
        ]
    },
    {
        "id": "05d6bd6a25172c84",
        "type": "catch",
        "z": "a91568669d27b6cc",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 160,
        "y": 180,
        "wires": [
            [
                "8f1cd448d9ddbb7d"
            ]
        ]
    },
    {
        "id": "dfbe04cbe5e0e705",
        "type": "status",
        "z": "a91568669d27b6cc",
        "name": "",
        "scope": null,
        "x": 680,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "8f1cd448d9ddbb7d",
        "type": "debug",
        "z": "a91568669d27b6cc",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 320,
        "y": 180,
        "wires": []
    },
    {
        "id": "32713dd13356c372",
        "type": "function",
        "z": "ea935d7649fccac4",
        "name": "setup-listen",
        "func": "/**\n * @typedef {object} RackPosition\n * @property {{\"#address\": string, value: string }} name\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n * @property {{\"#address\": string, value: string}} workpieceId\n */\n\n/** @param {string} nodeId */\nfunction getNodeName(nodeId) {\n    /** @type {Record<string, string>} */\n    const rack = flow.get(\"$parent.rack\") ?? {};\n    flow.set(\"$parent.rack\", rack);\n    /** @type {Record<string, string>} */\n    const existing = flow.get(\"$parent.rack.dictionary\") ?? {};\n    return existing[nodeId] ?? \"UNKNOWN\";\n}\n\n/**\n * @param {string} rackPosition\n * @returns {string|undefined}\n */\nfunction getRackPositionNodeId(rackPosition) {\n    /** @type {Record<string, string>} */\n    const rack = flow.get(\"$parent.rack\") ?? {};\n    flow.set(\"$parent.rack\", rack);\n    /** @type {Record<string, string>} */\n    const existing = flow.get(\"$parent.rack.dictionary\") ?? {};\n    return Object.entries(existing).filter(([_, value]) => value == rackPosition).map(([key]) => key)[0];\n}\n\n/** \n * @param {string} nodeId\n * @param {string} valueName\n * @param {string|boolean} nodeValue \n */\nfunction writeNodeValue(nodeId, valueName, nodeValue) {\n    const rackPos = env.get(\"RACK_POSITION\");\n    /** @type {Record<string, string>} */\n    const rack = flow.get(\"$parent.rack\") ?? {};\n    flow.set(\"$parent.rack\", rack);\n    /** @type {RackPosition} */\n    const rackPositionNodeId = getRackPositionNodeId(rackPos);\n    const storedPosition = flow.get(`$parent.rack.positions.${rackPos}`) ?? {\n        name: {\n            \"#address\": rackPositionNodeId,\n            value: rackPos\n        }\n    };\n    const strippedValueName = valueName.replace(`rack__${rackPos}_`, \"\");\n    storedPosition[strippedValueName] = {\n        \"#address\": nodeId,\n        value: nodeValue\n    };\n    flow.set(`$parent.rack.positions.${rackPos}`, storedPosition);\n    return storedPosition;\n}\n\nconst rackPos = env.get(\"RACK_POSITION\");\nconst valueName = getNodeName(msg.payload.nodeId);\n/** @type {string|boolean} */\nconst nodeValue = msg.payload.value.value.value;\nconst updatedRackPosition = writeNodeValue(msg.payload.nodeId, valueName, nodeValue);\nnode.status({ fill: \"green\", shape: \"dot\", text: `${rackPos}: ${updatedRackPosition.belegt.nodeValue} [${updatedRackPosition.type.nodeValue}]`});\nmsg.payload = updatedRackPosition;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 120,
        "wires": [
            [
                "0e6e260b3c5a891a"
            ]
        ]
    },
    {
        "id": "448fc81733591706",
        "type": "switch",
        "z": "ea935d7649fccac4",
        "name": "switch-opcua-messages",
        "property": "payload.nodetype",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "browse",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "listen",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 270,
        "y": 100,
        "wires": [
            [
                "3d414039742f078e"
            ],
            [
                "32713dd13356c372"
            ]
        ]
    },
    {
        "id": "3d414039742f078e",
        "type": "function",
        "z": "ea935d7649fccac4",
        "name": "setup-dictionary",
        "func": "/**\n * @typedef {object} BrowseResult\n * @property {string} nodeId\n * @property {string} browseName\n * @property {string} displayName\n * @property {string} nodeClass\n * @property {string} datatypeName\n */\n/** @param {BrowseResult} result */\nfunction extractName({ browseName }) {\n  const [_, nodeName] = browseName.split(\":\");\n  return nodeName ?? \"UNKNOWN\";\n}\n\nconst browserResults = msg.payload.browserResults ?? [];\n/** @type {Record<string, string>} */\nconst rack = flow.get(\"$parent.rack\") ?? {};\nflow.set(\"$parent.rack\", rack);\n/** @type {Record<string, string>} */\nconst existing = flow.get(\"$parent.rack.dictionary\") ?? {};\n/** @type {Record<string, string>} */\nconst dictionary = browserResults.reduce((dict, result) => {\n  const nodeName = extractName(result);\n  return {\n    ...dict,\n    [result.nodeId]: nodeName,\n    [nodeName]: result.nodeId,\n  };\n}, existing);\nflow.set(\"$parent.rack.dictionary\", dictionary);\nreturn;",
        "outputs": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 60,
        "wires": []
    },
    {
        "id": "8368fa805d3efbb7",
        "type": "catch",
        "z": "ea935d7649fccac4",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 180,
        "y": 180,
        "wires": [
            [
                "ee77e3e06bdd15cd"
            ]
        ]
    },
    {
        "id": "ee77e3e06bdd15cd",
        "type": "debug",
        "z": "ea935d7649fccac4",
        "name": "catch-all-errors",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 360,
        "y": 180,
        "wires": []
    },
    {
        "id": "f965220d4db8fa46",
        "type": "status",
        "z": "ea935d7649fccac4",
        "name": "",
        "scope": null,
        "x": 180,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "0e6e260b3c5a891a",
        "type": "function",
        "z": "ea935d7649fccac4",
        "name": "update-loads",
        "func": "/**\n * @typedef {object} RackPosition\n * @property {{value: string}} name\n * @property {{\"#address\": string, value: string}} workpieceId\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n */\n\n/**\n * @typedef {object} Load\n * @property {string} loadType\n * @property {string} loadId\n * @property {string} [loadPosition]\n * \n * @param {string} rackPosition\n * @param {string} workpieceId\n * @param {string} type\n */\nfunction createLoad(rackPosition, workpieceId, type) {\n    return {\n        loadType: type,\n        loadId: workpieceId,\n        loadPosition: rackPosition,\n    };\n}\n\nfunction createLoads() {\n    /** @type {Record<string, RackPosition>} */\n    const rackPositions = flow.get(\"$parent.rack.positions\") ?? [];\n    return Object.values(rackPositions).map((pos) => createLoad(pos.name.value, pos.workpieceId.value, pos.type.value));\n}\n\n/** @type {RackPosition} */\nconst rackPosition = msg.payload;\n/** @type {Load[]} */\nconst existing = createLoads();\nconst updated = existing.map((el) => {\n    if (el.loadPosition == rackPosition.name.value) {\n        node.status({ shape: \"dot\", \"fill\": \"green\", text: `${el.loadPosition}: ${rackPosition.type.value ?? \"EMPTY\"} / ${rackPosition.workpieceId.value ?? \"-\"}` });\n        return createLoad(el.loadPosition, rackPosition.workpieceId.value, rackPosition.type.value);\n    }\n    return el;\n});\nflow.set(\"$parent.loads\", updated);\nflow.set(\"$parent.state.loads\", updated);\nreturn;",
        "outputs": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 120,
        "wires": []
    },
    {
        "id": "4eaf89b69e1eafe0",
        "type": "function",
        "z": "7173b966cb38f0e0",
        "name": "setup-listen",
        "func": "/**\n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {Record<string, number>} NodeValues\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string|NodeValues} nodeValue\n */\n\n/** \n * @param {string} nodeId \n * @returns {string} the nodeName\n */\nfunction getNodeName(nodeId) {\n    /** @type {Record<string, string>} */\n    const calibration = flow.get(\"$parent.calibration\") ?? {};\n    flow.set(\"$parent.calibration\", calibration);\n    /** @type {Record<string, string>} */\n    const existing = flow.get(\"$parent.calibration.dictionary\") ?? {};\n    return existing[nodeId] ?? \"UNKNOWN\";\n}\n\n/**\n * @param {string} nodeName\n * @returns {string} the nodeId\n */\nfunction getNodeIdByName(nodeName) {\n    /** @type {Record<string, string>} */\n    const calibration = flow.get(\"$parent.calibration\") ?? {};\n    flow.set(\"$parent.calibration\", calibration);\n    /** @type {Record<string, string>} */\n    const existing = flow.get(\"$parent.calibration.dictionary\") ?? {};\n    return Object.entries(existing).filter(([_, nn]) => nn.toLocaleLowerCase() == nodeName?.toLocaleLowerCase()).map(([nodeId]) => nodeId)[0];\n}\n\n/**\n * @param {string} nodeId\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeId, nodeValue) {\n    const nodeName = getNodeName(nodeId);\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/** \n * @param {string} nodeId\n * @param {number} nodeValue\n * @returns {CalibrationValue}\n */\nfunction writeNodeValue(nodeId, nodeValue) {\n    /** @type {Record<string, CalibrationValue>} */\n    const nodeName = getNodeName(nodeId);\n    /** @type {CalibrationValue} */\n    const calibrationValue = flow.get(`$parent.calibration.state.${nodeName}`) ?? {\n        nodeId,\n        nodeName,\n    };\n    calibrationValue.nodeValue = nodeValue;\n    flow.set(`$parent.calibration.state.${nodeName}`, calibrationValue);\n    return calibrationValue;\n}\n\n/**\n * @param {Record<string, number>} nodeValueObject\n * @returns {CalibrationValue[]}\n */\nfunction writeNodeValues(nodeValueObject) {\n    // we are only interested in the entries of the nodeValueObject\n    return Object.entries(nodeValueObject).map(([nodeName, nodeValue]) => {\n        const nodeId = getNodeIdByName(nodeName);\n        return writeNodeValue(nodeId, nodeValue);\n    });\n}\n\n/** @type {string} */\nconst nodeId = msg.payload.nodeId;\n/** @type {number} */\nconst nodeValue = msg.payload.value.value.value;\nconst calibrationValue = writeNodeValue(nodeId, nodeValue);\nmsg.payload = calibrationValue;\nmsg.topic = \"calibration-value__\" + nodeId;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 160,
        "wires": [
            [
                "50822f49e8a1ce63"
            ]
        ]
    },
    {
        "id": "32b0de7a18bf11ad",
        "type": "switch",
        "z": "7173b966cb38f0e0",
        "name": "switch-opcua-messages",
        "property": "payload.nodetype",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "browse",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "listen",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 230,
        "y": 140,
        "wires": [
            [
                "93dd9c6ec05cb865",
                "885b455dfed2ed93"
            ],
            [
                "4eaf89b69e1eafe0"
            ]
        ]
    },
    {
        "id": "93dd9c6ec05cb865",
        "type": "function",
        "z": "7173b966cb38f0e0",
        "name": "setup-dictionary",
        "func": "/**\n * @typedef {object} BrowseResult\n * @property {string} nodeId\n * @property {string} browseName\n * @property {string} displayName\n * @property {string} nodeClass\n * @property {string} datatypeName\n */\n/** @param {BrowseResult} result */\nfunction extractName({ browseName }) {\n  const [_, nodeName] = browseName.split(\":\");\n  return nodeName ?? \"UNKNOWN\";\n}\n\nconst browserResults = msg.payload.browserResults ?? [];\n\n/** @type {Record<string, string>} */\nconst calibration = flow.get(\"$parent.calibration\") ?? {};\nflow.set(\"$parent.calibration\", calibration);\n\n/** @type {Record<string, string>} */\nconst existing = flow.get(\"$parent.calibration.dictionary\") ?? {};\n/** @type {Record<string, string>} */\nconst dictionary = browserResults.reduce((dict, result) => {\n  const nodeName = extractName(result);\n  return {\n    ...dict,\n    [result.nodeId]: nodeName,\n    [nodeName]: result.nodeId,\n  };\n}, existing);\nflow.set(\"$parent.calibration.dictionary\", dictionary);\nreturn;",
        "outputs": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 100,
        "wires": []
    },
    {
        "id": "50822f49e8a1ce63",
        "type": "template",
        "z": "7173b966cb38f0e0",
        "name": "",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "{{{payload.nodeId}}}: {{payload.nodeValue}} [{{payload.nodeName}}]",
        "output": "str",
        "x": 660,
        "y": 160,
        "wires": [
            [
                "030b08ea813bc11c"
            ]
        ]
    },
    {
        "id": "030b08ea813bc11c",
        "type": "delay",
        "z": "7173b966cb38f0e0",
        "name": "",
        "pauseType": "delay",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 830,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "885b455dfed2ed93",
        "type": "function",
        "z": "7173b966cb38f0e0",
        "name": "setup-positions",
        "func": "const configuredAvailablePositions = env.get(\"AVAILABLE_POSITIONS\") ?? \"\";\nconst configuredCurrentPosition = env.get(\"CURRENT_POSITION\") ?? \"\";\n\n/** @type {Record<string, string>} */\nconst calibration = flow.get(\"$parent.calibration\") ?? {};\nflow.set(\"$parent.calibration\", calibration);\n\n/** @type {Record<string, string>} */\nconst positions = flow.get(\"$parent.calibration.positions\") ?? {};\nflow.set(\"$parent.calibration.positions\", positions);\n\nflow.set(\"$parent.calibration.positions.available\", configuredAvailablePositions);\nflow.set(\"$parent.calibration.positions.current\", configuredCurrentPosition);\n\nreturn;",
        "outputs": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 60,
        "wires": []
    },
    {
        "id": "a065343fb9fd80f0",
        "type": "function",
        "z": "fb6b02d4d9963179",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} Load\n * @property {string} type\n * @property {string} [workpieceId]\n * \n * @typedef {object} Workpiece\n * @property {string} workpieceId\n * \n * @typedef {object} Metadata\n * @property {string} [type]\n * @property {string} [workpieceId]\n * @property {Workpiece} [workpiece]\n * \n * @typedef {object} Action\n * @property {string} id\n * @property {string} command\n * @property {string} [state]\n * @property {any} [result] \n * @property {Metadata} metadata\n */\n\n/**\n * @param {string} type\n * @param {string} workpieceId\n * @returns {Load}\n */\nfunction createLoad(type, workpieceId) {\n    return {\n        type,\n        workpieceId,\n    };\n}\n\n/**\n * @param {Action} actionState\n * @param {Load[] | undefined} loads\n */\nfunction createState(actionState, loads = undefined) {\n    /** @type {object} */\n    const state = flow.get(\"$parent.state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"$parent.headerId\");\n\n    state.headerId = headerId;\n    state.loads = loads ?? state.loads ?? [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = undefined;\n    state.orderUpdateId = flow.get(\"$parent.orderUpdateId\");\n    state.errors = [];\n    state.paused = msg.modulePaused ?? state.paused;\n    state.operatingMode = msg.operatingMode ?? state.operatingMode;\n    if (Array.isArray(msg.calibrationData)) {\n        state.information = msg.calibrationData;\n    }\n\n    // headerId Update\n    flow.set(\"$parent.headerId\", headerId + 1);\n    flow.set(\"$parent.state\", state);\n    flow.set(\"$parent.loads\", loads ?? state.loads);\n    return state;\n}\n\n/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"$parent.actionState\") ?? {};\n    actionState.id = msg.actionId ?? actionState.id;\n    actionState.state = state;\n    actionState.command = msg.actionCommand ?? actionState.command;\n    actionState.metadata = metadata ?? actionState.metadata ?? {};\n    flow.set(\"$parent.actionState\", actionState);\n    return actionState;\n}\n\n// state bauen\nconst actionState = updateActionState(\"FINISHED\", msg.actionMetadata);\nconst state = createState(actionState, msg.loads);\n\n/** @type {string} */\nconst parentFlowName = flow.get(\"$parent.flowName\");\nnode.status({ shape: \"dot\", fill: \"green\", text: `${parentFlowName} / ${actionState.command ?? \"UNKNOWN\"}: ${actionState.state}`});\n\n// flow update\nflow.set(\"$parent.orderId\", \"0\");\nflow.set(\"$parent.orderUpdateId\", 0);\n\nmsg.topic = flow.get(\"$parent.MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 280,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "b9c02eadd51d2391",
        "type": "status",
        "z": "fb6b02d4d9963179",
        "name": "",
        "scope": null,
        "x": 200,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "afdc0b0b98a75e61",
        "type": "catch",
        "z": "fb6b02d4d9963179",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 200,
        "y": 220,
        "wires": [
            [
                "8b73931be8bece60"
            ]
        ]
    },
    {
        "id": "8b73931be8bece60",
        "type": "debug",
        "z": "fb6b02d4d9963179",
        "name": "catch-all-errors",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 380,
        "y": 220,
        "wires": []
    },
    {
        "id": "f77653d3181ab432",
        "type": "function",
        "z": "07a7fc5bcd60a12a",
        "name": "vda_status_running instantAction",
        "func": "/**\n * @typedef {object} Load\n * @property {string} type\n * @property {string} [workpieceId]\n * \n * @typedef {object} Workpiece\n * @property {string} workpieceId\n * \n * @typedef {object} Metadata\n * @property {string} [type]\n * @property {string} [workpieceId]\n * @property {Workpiece} [workpiece]\n * \n * @typedef {object} Action\n * @property {string} id\n * @property {string} command\n * @property {string} [state]\n * @property {any} [result] \n * @property {Metadata} metadata\n */\n\n/**\n * @param {string} type\n * @param {string} workpieceId\n * @returns {Load}\n */\nfunction createLoad(type, workpieceId) {\n    return {\n        type,\n        workpieceId,\n    };\n}\n\n/**\n * @param {Action} actionState\n * @param {Load[] | undefined} loads\n */\nfunction createState(actionState, loads = undefined) {\n    /** @type {object} */\n    const state = flow.get(\"$parent.state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"$parent.headerId\");\n\n    state.headerId = headerId;\n    state.loads = loads ?? state.loads ?? [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"$parent.orderId\");\n    state.orderUpdateId = flow.get(\"$parent.orderUpdateId\");\n    const flowErrors = flow.get(\"$parent.errors\");\n    state.errors = flowErrors ? Array.isArray(flowErrors) ? flowErrors : [flowErrors] : [];\n    state.paused = msg.modulePaused ?? state.paused;\n    state.operatingMode = msg.operatingMode ?? state.operatingMode;\n\n    // headerId Update\n    flow.set(\"$parent.headerId\", headerId + 1);\n    flow.set(\"$parent.state\", state);\n    flow.set(\"$parent.loads\", loads ?? state.loads);\n    return state;\n}\n\n/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"$parent.actionState\") ?? {};\n    actionState.id = msg.actionId ?? actionState.id;\n    actionState.state = state;\n    actionState.command = msg.actionCommand ?? actionState.command;\n    actionState.metadata = metadata ?? actionState.metadata ?? {};\n    flow.set(\"$parent.actionState\", actionState);\n    return actionState;\n}\n\n// state bauen\nconst actionState = updateActionState(\"RUNNING\", msg.actionMetadata);\nconst state = createState(actionState);\n\n/** @type {string} */\nconst parentFlowName = flow.get(\"$parent.flowName\");\nnode.status({ shape: \"dot\", fill: \"yellow\", text: `${parentFlowName} / ${actionState.command}: ${actionState.state}`});\n\nmsg.topic = flow.get(\"$parent.MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "2490563da31e8fd4",
        "type": "status",
        "z": "07a7fc5bcd60a12a",
        "name": "",
        "scope": null,
        "x": 300,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "2f02d4a33ab1557a",
        "type": "catch",
        "z": "07a7fc5bcd60a12a",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 300,
        "y": 260,
        "wires": [
            [
                "2d9f81fdc288e7f7"
            ]
        ]
    },
    {
        "id": "2d9f81fdc288e7f7",
        "type": "debug",
        "z": "07a7fc5bcd60a12a",
        "name": "catch-errors",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 470,
        "y": 260,
        "wires": []
    },
    {
        "id": "2eb17eba88eb7a2a",
        "type": "function",
        "z": "105d02aba31c4a1d",
        "name": "check-nodeValue-true",
        "func": "const nodeValue = msg.payload.value.value.value;\nif (!!nodeValue) {\n    return msg;\n}\nreturn;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "bfe7d55dce5e2b71",
        "type": "status",
        "z": "105d02aba31c4a1d",
        "name": "",
        "scope": null,
        "x": 180,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "ad7035210b2daa14",
        "type": "catch",
        "z": "105d02aba31c4a1d",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 180,
        "y": 220,
        "wires": [
            [
                "c8913195bd587863"
            ]
        ]
    },
    {
        "id": "c8913195bd587863",
        "type": "debug",
        "z": "105d02aba31c4a1d",
        "name": "catch-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 350,
        "y": 220,
        "wires": []
    },
    {
        "id": "e439d1ef2174715f",
        "type": "function",
        "z": "468f2460ce66f11e",
        "name": "check-opcua-connection",
        "func": "/**\n * @typedef {object} Connection \n * @property {number} headerId\n * @property {string} timestamp\n * @property {string} version\n * @property {string} manufacturer\n * @property {string} serialNumber\n * @property {\"ONLINE\" | \"OFFLINE\" | \"CONNECTIONBROKEN\"} connectionState\n */\nconst MQTT_TOPIC_KEY = \"$parent.MQTT_topic\";\nconst CONNECTION_KEY = \"$parent.connection\";\nconst HEADER_ID_KEY = \"$parent.headerId\";\nconst INJECT_KEY = \"inject\";\nconst READ_KEY = \"read\";\nconst PREVIOUS_NODETYPE_KEY = \"PREVIOUS_NODETYPE\";\n\n/** @type {number} */\nconst headerId = flow.get(HEADER_ID_KEY);\n/** @type {Connection} */\nconst connection = flow.get(CONNECTION_KEY);\n/** @type {string} */\nconst previousNodetype = context.get(PREVIOUS_NODETYPE_KEY);\n/** @type {{ nodetype: string}} */\nconst { nodetype } = msg.payload;\n\nif (connection.serialNumber == \"serialNumber\") {\n    node.status({ fill: 'yellow', shape: 'dot', text: 'no initial read' });\n    // initial serialNumber read has not happened, discard message\n    return;\n}\n\nif (previousNodetype == null) {\n    // first message of message pair for checking received\n    context.set(PREVIOUS_NODETYPE_KEY, nodetype);\n    return;\n}\n\n// create new msg for connection state\nconst newMsg = { \n    topic: flow.get(MQTT_TOPIC_KEY) + \"/connection\",\n    payload: {\n        ...connection,\n        headerId,\n    }\n};\nif (previousNodetype == INJECT_KEY && nodetype == INJECT_KEY) {\n    // set connectionState to CONNECTIONBROKEN\n    newMsg.payload.connectionState = \"CONNECTIONBROKEN\";\n} else if (previousNodetype == INJECT_KEY && nodetype == READ_KEY) {\n    // set connectionState to CONNECTIONBROKEN\n    newMsg.payload.connectionState = \"ONLINE\";\n}\n// reset previousNodetype to null\ncontext.set(PREVIOUS_NODETYPE_KEY, null);\nnode.status({ fill: newMsg.payload.connectionState == 'ONLINE' ? 'green' : 'red', shape: 'dot', text: newMsg.payload.connectionState });\n\nflow.set(HEADER_ID_KEY, headerId + 1);\nflow.set(CONNECTION_KEY, newMsg.payload);\nreturn newMsg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "context.set(\"PREVIOUS_NODETYPE\", null);",
        "finalize": "",
        "libs": [],
        "x": 210,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "055f3c065fbca3ef",
        "type": "catch",
        "z": "468f2460ce66f11e",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 80,
        "y": 220,
        "wires": [
            [
                "384a4d17dbd91c90"
            ]
        ]
    },
    {
        "id": "d8c7f42fd8b72ff8",
        "type": "status",
        "z": "468f2460ce66f11e",
        "name": "",
        "scope": null,
        "x": 80,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "384a4d17dbd91c90",
        "type": "debug",
        "z": "468f2460ce66f11e",
        "name": "catch-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 290,
        "y": 220,
        "wires": []
    },
    {
        "id": "1778275986092549",
        "type": "comment",
        "z": "f39c18cc6f60e7a0",
        "name": "",
        "info": "aktuell werden sie in jedem Flow selbst gesetzt",
        "x": 210,
        "y": 120,
        "wires": []
    },
    {
        "id": "ae89c3d61e879c52",
        "type": "inject",
        "z": "f39c18cc6f60e7a0",
        "name": "Json for dynamic connection (testing)",
        "props": [
            {
                "p": "action",
                "v": "connect",
                "vt": "str"
            },
            {
                "p": "broker",
                "v": "{\"broker\":\"host.docker.internal\",\"port\":1883,\"force\":true}",
                "vt": "json"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "x": 270,
        "y": 400,
        "wires": [
            []
        ]
    },
    {
        "id": "b14f49e3ced85ac4",
        "type": "inject",
        "z": "f39c18cc6f60e7a0",
        "name": "Json for dynamic connection",
        "props": [
            {
                "p": "action",
                "v": "connect",
                "vt": "str"
            },
            {
                "p": "broker",
                "v": "{\"broker\":\"mqtt://mqtt-broker\",\"port\":1883,\"username\":\"default\",\"password\":\"default\",\"force\":true}",
                "vt": "json"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "x": 260,
        "y": 460,
        "wires": [
            [
                "9cdedeecc7d99229"
            ]
        ]
    },
    {
        "id": "9cdedeecc7d99229",
        "type": "mqtt in",
        "z": "f39c18cc6f60e7a0",
        "name": "dynamic Connection",
        "topic": "",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 1,
        "x": 590,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "1a56d5a4f8592caa",
        "type": "link in",
        "z": "f39c18cc6f60e7a0",
        "name": "MQTT_retained_in",
        "links": [
            "2835d8a03c6efb13",
            "f2bd69dc761fafc5",
            "7e3aa730b8656bf6",
            "ffc8d545a583a254",
            "c42740473d19f811",
            "05e39b93c0873051",
            "66b392bb4886c28c",
            "cd5c4668afc7a45f",
            "1d48fde7b9bf2caa",
            "b1318a37fb23e904",
            "184cf62fa0e6953d",
            "6cc1cf1872f95648",
            "e6f7e7d86c9e4f06",
            "a9a8c980b59621b0",
            "4e2c680ca0ad5de0",
            "c2d2aa8af676c4b1",
            "d0294086443d968b",
            "1db7ab2115fb2f64",
            "5743940d1df62fa0",
            "6299e10365010d76",
            "5d0c19257761e5cf",
            "4e2804bcebc1d0d8",
            "c39a247a735925aa",
            "1f97a4188eef17aa",
            "921091b65f9ec778",
            "5c4b33bb3f0f0981",
            "3b3a79c5f6ebb5d1",
            "d82413a44a86633a",
            "780e42cd53797e37",
            "ea1f7bad64b35803",
            "1df8cbd17e5cde13",
            "67c21c1828baa896",
            "c0a328943becf51f",
            "5a0397a45e9acc40",
            "1c2304c530564b98",
            "88418656a8a1acb1",
            "a848a2c71bc99df1",
            "0cc57234edc1a1f4",
            "e5a350c9446698c6",
            "532fa43b1627dae7",
            "30420fa86c4b5850",
            "66b35dc89f72837d",
            "3fb294540120f871",
            "82c199ad9dcfe4cc",
            "f0986aa47fc51448",
            "e92579999097f440",
            "c208df477b440c19",
            "93b293c477a8fd8f",
            "ed655a1d4b5ba332",
            "90d6f05d70ab15ba",
            "f9fe92b89535e85f",
            "3c2237769c19c0a0",
            "d2713ecd3cc4e670",
            "c4dc7d8627cc0b0d",
            "02eb86a3a529a935",
            "c3a6558945a16926",
            "79dbd33fdcc31d22",
            "2a4907c9929f1728",
            "5b91fb063f30adf5",
            "c36b6492ea57b4a7",
            "a60225a3c36d1ad0",
            "1335063f2d2e04f2",
            "ea6b0a7bcb8002ea",
            "b9624e41cd80a261",
            "dcdb9df3eb284b5d",
            "1235ba9752975539",
            "cd15d7f2fbda0c19",
            "e8ba288173d89591",
            "d7379ad2adb95133",
            "6c9e1ccb1d1ec383",
            "35bce9c8a26161ef",
            "bc7f5d17637a1282",
            "6a89475cfc0c08ec",
            "e93ebee86dd29f0c",
            "c8f59ce606cc90ca",
            "d2239bd3216b6c97",
            "7fd52d35a43b2482",
            "da46fcdf765cd02f",
            "2214f7baa101d895",
            "761fbdab37b1fd92",
            "2b5c3f37e732d11e",
            "d4351ece06736a6e",
            "0f1606fa85f29100",
            "a607fa96ac309e60",
            "f78c7dc67420f12d",
            "f0a4aacd8591c561",
            "dc6365bbc6ee41c0",
            "1156530db41fbba0",
            "6e2377bb208e784a",
            "add2844df775686e",
            "e490a699328a6495",
            "20ff0d426140f798",
            "02ace5d35e50c50f",
            "de957a6464c99cd6",
            "036c45b361b8726c",
            "399bbfc8be1c758d",
            "ee4d6e5cc05394ad",
            "fdcb738a593f8bdb",
            "e67101ca9202dad1",
            "7f79916a4455078e",
            "3fc4c1aee2d7c1cc",
            "5ea501f68a0ed14d",
            "6f100adfcdf484e6",
            "29cc4a93307380c0",
            "fa4c5a3f99e5f939",
            "fcf3a32b6f64b8a6",
            "e6c30e04c0c22070",
            "37552e6686b7069a",
            "ef0c06909fe7fe61",
            "da76d2f9b15675b9",
            "e020a2cfab753f17",
            "26bd923618076388"
        ],
        "x": 675,
        "y": 180,
        "wires": [
            [
                "eb9a8340ea3e7189",
                "fe49a4abe7973f32"
            ]
        ]
    },
    {
        "id": "eb9a8340ea3e7189",
        "type": "mqtt out",
        "z": "f39c18cc6f60e7a0",
        "name": "mqtt retained",
        "topic": "",
        "qos": "1",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "15b84ed331dcc49c",
        "x": 830,
        "y": 180,
        "wires": []
    },
    {
        "id": "b868e3d26bf1f789",
        "type": "link in",
        "z": "f39c18cc6f60e7a0",
        "name": "MQTT_notRetained_in",
        "links": [
            "259e9a48880689a7",
            "3db9fc4917e1de09",
            "4d11a1a73aeb8431",
            "83eb15f6b69aedf5",
            "631c7523cebe0901",
            "53b8ba0d43c3adbd",
            "2df5845a90f8f8de",
            "9af9245fe6cabd23",
            "98d439b491e3053a",
            "165169e6dd7b67a6",
            "3f2b0463d13be71b",
            "73108f9654f52051",
            "95f44127f088b410",
            "c7acfbeec497f778",
            "6cb816d4094ac4b4",
            "ce1f3b00ddcece69",
            "690bfd6eb41abf49",
            "6825856480022034",
            "05fb4949e855ecdb",
            "224d482957f829ee",
            "1dbbe2eabe308dd5",
            "f9f34853b704e98a",
            "7b431bd530678e41",
            "f4d035248a74db5b",
            "e6e147eb63c68172",
            "e230ef296fedef09",
            "1933ed2865f6ad0d",
            "b90bb9b723b79a8d",
            "63b8e9df09063d86",
            "57d6c8e571728e65",
            "75b7426ef58f12b5"
        ],
        "x": 675,
        "y": 260,
        "wires": [
            [
                "eaf45814a1499492",
                "1e32ec5990a7797a"
            ]
        ]
    },
    {
        "id": "eaf45814a1499492",
        "type": "mqtt out",
        "z": "f39c18cc6f60e7a0",
        "name": "mqtt not retained",
        "topic": "",
        "qos": "1",
        "retain": "false",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "15b84ed331dcc49c",
        "x": 850,
        "y": 260,
        "wires": []
    },
    {
        "id": "efc117fb5f572b53",
        "type": "inject",
        "z": "f39c18cc6f60e7a0",
        "name": "Json for dynamic connection 192.168.0.100",
        "props": [
            {
                "p": "action",
                "v": "connect",
                "vt": "str"
            },
            {
                "p": "broker",
                "v": "{\"broker\":\"192.168.0.100\",\"port\":1883,\"force\":true}",
                "vt": "json"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "x": 290,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "fe49a4abe7973f32",
        "type": "debug",
        "z": "f39c18cc6f60e7a0",
        "name": "mqtt-retained",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 830,
        "y": 120,
        "wires": []
    },
    {
        "id": "1e32ec5990a7797a",
        "type": "debug",
        "z": "f39c18cc6f60e7a0",
        "name": "mqtt-not-retained",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 850,
        "y": 340,
        "wires": []
    },
    {
        "id": "68c74d703a2b2cdc",
        "type": "mqtt in",
        "z": "f39c18cc6f60e7a0",
        "g": "281fe79168d00793",
        "name": "global-reset",
        "topic": "ccu/global",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 190,
        "y": 620,
        "wires": [
            [
                "67b7ecc6ac892f54"
            ]
        ]
    },
    {
        "id": "9a5f8404f15c499e",
        "type": "delay",
        "z": "f39c18cc6f60e7a0",
        "g": "281fe79168d00793",
        "name": "",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 580,
        "y": 620,
        "wires": [
            [
                "2571fe942764589b"
            ]
        ]
    },
    {
        "id": "2571fe942764589b",
        "type": "http request",
        "z": "f39c18cc6f60e7a0",
        "g": "281fe79168d00793",
        "name": "",
        "method": "POST",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "http://localhost:1880/flows",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "other",
                "keyValue": "Node-RED-Deployment-Type",
                "valueType": "other",
                "valueValue": "reload"
            }
        ],
        "x": 750,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "67b7ecc6ac892f54",
        "type": "function",
        "z": "f39c18cc6f60e7a0",
        "g": "281fe79168d00793",
        "name": "is-reset-message",
        "func": "const { payload } = msg;\nconst msgType = String(payload.type ?? \"\").toLowerCase();\nif (msgType == \"reset\") {\n    node.status({ fill: \"green\", shape: \"dot\", text: \"Received reset...\" });\n    return msg;\n}\nreturn;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 620,
        "wires": [
            [
                "9a5f8404f15c499e"
            ]
        ]
    },
    {
        "id": "84df02980fc40b12",
        "type": "OPCUA-IIoT-Listener",
        "z": "9810df827082ae56",
        "connector": "f8824f864369a41f",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 580,
        "y": 980,
        "wires": [
            [
                "0fd92e362101022d"
            ]
        ]
    },
    {
        "id": "ef2cc52219936216",
        "type": "OPCUA-IIoT-Inject",
        "z": "9810df827082ae56",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=21",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 460,
        "wires": [
            [
                "d0f0a98c76cc1658"
            ]
        ]
    },
    {
        "id": "d0f0a98c76cc1658",
        "type": "OPCUA-IIoT-Read",
        "z": "9810df827082ae56",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "f8824f864369a41f",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 390,
        "y": 460,
        "wires": [
            [
                "63b1d349f9e14e22",
                "6da2e3c24b5b1b15"
            ]
        ]
    },
    {
        "id": "cc88e3b8b0269abb",
        "type": "function",
        "z": "9810df827082ae56",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"MILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration}];\n            msg.payload.nodesToWrite = [\n                { \"name\": \"mill\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" },\n                { \"name\": \"duration\", \"nodeId\": \"ns=4;i=11\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg,null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 240,
        "wires": [
            [
                "f5ca159ccb1f2e6a"
            ],
            [
                "b0e989f72ff76e1e"
            ]
        ]
    },
    {
        "id": "f5ca159ccb1f2e6a",
        "type": "OPCUA-IIoT-Write",
        "z": "9810df827082ae56",
        "connector": "f8824f864369a41f",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 1190,
        "y": 180,
        "wires": [
            [
                "2ce2e5a1396e4726",
                "effbdfa5ecb213b2"
            ]
        ]
    },
    {
        "id": "effbdfa5ecb213b2",
        "type": "debug",
        "z": "9810df827082ae56",
        "name": "write MSg",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 140,
        "wires": []
    },
    {
        "id": "9275df57d3f45391",
        "type": "function",
        "z": "9810df827082ae56",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 1020,
        "wires": [
            [
                "e28019bd4d3c63b3",
                "ffc8d545a583a254"
            ]
        ]
    },
    {
        "id": "0fd92e362101022d",
        "type": "switch",
        "z": "9810df827082ae56",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 980,
        "wires": [
            [],
            [
                "a42f4a5baded7e34",
                "c2c41b017291ea5c"
            ],
            [
                "c2c41b017291ea5c"
            ],
            [
                "292be9a2c27fb100"
            ],
            [],
            [
                "1ee728a06a2be2f8"
            ],
            [],
            [
                "bbe82cd66f64a56e",
                "9275df57d3f45391"
            ],
            [
                "9275df57d3f45391"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "mill_aktiv",
            "mill_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "2ce2e5a1396e4726",
        "type": "function",
        "z": "9810df827082ae56",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 220,
        "wires": [
            [
                "7bbd139882cb9d91",
                "c42740473d19f811"
            ]
        ]
    },
    {
        "id": "7bbd139882cb9d91",
        "type": "debug",
        "z": "9810df827082ae56",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1810,
        "y": 220,
        "wires": []
    },
    {
        "id": "c2c41b017291ea5c",
        "type": "function",
        "z": "9810df827082ae56",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=13\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 940,
        "wires": [
            [
                "e28019bd4d3c63b3",
                "ffc8d545a583a254"
            ]
        ]
    },
    {
        "id": "e28019bd4d3c63b3",
        "type": "debug",
        "z": "9810df827082ae56",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 1140,
        "wires": []
    },
    {
        "id": "1ee728a06a2be2f8",
        "type": "function",
        "z": "9810df827082ae56",
        "name": "vda_status_finished MILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 980,
        "wires": [
            [
                "e28019bd4d3c63b3",
                "ffc8d545a583a254"
            ]
        ]
    },
    {
        "id": "292be9a2c27fb100",
        "type": "change",
        "z": "9810df827082ae56",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 860,
        "wires": [
            []
        ]
    },
    {
        "id": "bbe82cd66f64a56e",
        "type": "change",
        "z": "9810df827082ae56",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "a42f4a5baded7e34",
        "type": "change",
        "z": "9810df827082ae56",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1140,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "ef0bf5f46fe26aa4",
        "type": "function",
        "z": "9810df827082ae56",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"MILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"MILL\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": 0,\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\n// factsheet for MILL\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.40\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "b0e989f72ff76e1e",
        "type": "function",
        "z": "9810df827082ae56",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 320,
        "wires": [
            [
                "7bbd139882cb9d91",
                "c42740473d19f811"
            ]
        ]
    },
    {
        "id": "d33d0bcf9d6bcbe4",
        "type": "OPCUA-IIoT-Browser",
        "z": "9810df827082ae56",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "f8824f864369a41f",
        "x": 400,
        "y": 980,
        "wires": [
            [
                "84df02980fc40b12",
                "09303051db932bfe"
            ]
        ]
    },
    {
        "id": "8cb0c3e3d9d1afb9",
        "type": "OPCUA-IIoT-Inject",
        "z": "9810df827082ae56",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 980,
        "wires": [
            [
                "d33d0bcf9d6bcbe4"
            ]
        ]
    },
    {
        "id": "09303051db932bfe",
        "type": "change",
        "z": "9810df827082ae56",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "ffc8d545a583a254",
        "type": "link out",
        "z": "9810df827082ae56",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1735,
        "y": 960,
        "wires": []
    },
    {
        "id": "63b1d349f9e14e22",
        "type": "subflow:1b897516f5bf21fa",
        "z": "9810df827082ae56",
        "name": "",
        "x": 620,
        "y": 460,
        "wires": [
            [
                "cc88e3b8b0269abb"
            ],
            [
                "dc8e1da6db07a138"
            ],
            [
                "c42740473d19f811"
            ],
            []
        ]
    },
    {
        "id": "c42740473d19f811",
        "type": "link out",
        "z": "9810df827082ae56",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1935,
        "y": 480,
        "wires": []
    },
    {
        "id": "38f75efbbd61c00e",
        "type": "subflow:6a25ecd632542087",
        "z": "9810df827082ae56",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-mill.json",
                "type": "str"
            },
            {
                "name": "FACTSHEET_FILENAME",
                "value": "factsheet-mill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "ef0bf5f46fe26aa4"
            ]
        ]
    },
    {
        "id": "65ea2295db8256c4",
        "type": "function",
        "z": "9810df827082ae56",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1240,
        "y": 420,
        "wires": [
            [
                "e2ee768c89a9dcb5",
                "c42740473d19f811"
            ]
        ]
    },
    {
        "id": "e2ee768c89a9dcb5",
        "type": "function",
        "z": "9810df827082ae56",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 420,
        "wires": [
            [
                "c42740473d19f811"
            ]
        ]
    },
    {
        "id": "dc8e1da6db07a138",
        "type": "switch",
        "z": "9810df827082ae56",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 970,
        "y": 420,
        "wires": [
            [
                "65ea2295db8256c4"
            ]
        ]
    },
    {
        "id": "c5b5a85ec2269243",
        "type": "catch",
        "z": "9810df827082ae56",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "8b9f2b9f57dd3d5d"
            ]
        ]
    },
    {
        "id": "8b9f2b9f57dd3d5d",
        "type": "debug",
        "z": "9810df827082ae56",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "5b1744c09f35fa4d",
        "type": "subflow:468f2460ce66f11e",
        "z": "9810df827082ae56",
        "name": "",
        "x": 650,
        "y": 620,
        "wires": [
            [
                "c42740473d19f811"
            ]
        ]
    },
    {
        "id": "2675e42a18b06390",
        "type": "OPCUA-IIoT-Inject",
        "z": "9810df827082ae56",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 200,
        "y": 620,
        "wires": [
            [
                "000af99b0ede127b",
                "5b1744c09f35fa4d"
            ]
        ]
    },
    {
        "id": "000af99b0ede127b",
        "type": "OPCUA-IIoT-Read",
        "z": "9810df827082ae56",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "f8824f864369a41f",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 580,
        "wires": [
            [
                "5b1744c09f35fa4d"
            ]
        ]
    },
    {
        "id": "6da2e3c24b5b1b15",
        "type": "debug",
        "z": "9810df827082ae56",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 580,
        "y": 360,
        "wires": []
    },
    {
        "id": "e4af1351b613935f",
        "type": "OPCUA-IIoT-Listener",
        "z": "f6c8f50b75376b12",
        "connector": "10c631e5670ce5e1",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 580,
        "y": 980,
        "wires": [
            [
                "13014a3b40279d23"
            ]
        ]
    },
    {
        "id": "51f1c446fdc888f3",
        "type": "OPCUA-IIoT-Read",
        "z": "f6c8f50b75376b12",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "10c631e5670ce5e1",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 390,
        "y": 460,
        "wires": [
            [
                "5ca54bd1379d2014"
            ]
        ]
    },
    {
        "id": "d50b0f89a41e2f60",
        "type": "function",
        "z": "f6c8f50b75376b12",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"MILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"name\": \"mill\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" },\n                { \"name\": \"duration\", \"nodeId\": \"ns=4;i=11\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 240,
        "wires": [
            [
                "46daf718310aad69"
            ],
            [
                "eba861f25c6310f2"
            ]
        ]
    },
    {
        "id": "46daf718310aad69",
        "type": "OPCUA-IIoT-Write",
        "z": "f6c8f50b75376b12",
        "connector": "10c631e5670ce5e1",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 1190,
        "y": 180,
        "wires": [
            [
                "125359fdc5bc8840",
                "e890003b493b4bf5"
            ]
        ]
    },
    {
        "id": "e890003b493b4bf5",
        "type": "debug",
        "z": "f6c8f50b75376b12",
        "name": "write MSg",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 140,
        "wires": []
    },
    {
        "id": "69fb59256c20b694",
        "type": "function",
        "z": "f6c8f50b75376b12",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 1020,
        "wires": [
            [
                "4ff0557c79a22048",
                "6a89475cfc0c08ec"
            ]
        ]
    },
    {
        "id": "13014a3b40279d23",
        "type": "switch",
        "z": "f6c8f50b75376b12",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 980,
        "wires": [
            [],
            [
                "f728f206bee02bb8",
                "9dfae358f19d380b"
            ],
            [
                "9dfae358f19d380b"
            ],
            [
                "d391c770207c477e"
            ],
            [],
            [
                "0107937eed074b61"
            ],
            [],
            [
                "26f2c2edb2823204",
                "69fb59256c20b694"
            ],
            [
                "69fb59256c20b694"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "mill_aktiv",
            "mill_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "125359fdc5bc8840",
        "type": "function",
        "z": "f6c8f50b75376b12",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 220,
        "wires": [
            [
                "c9f167cd677fc933",
                "e93ebee86dd29f0c"
            ]
        ]
    },
    {
        "id": "c9f167cd677fc933",
        "type": "debug",
        "z": "f6c8f50b75376b12",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1810,
        "y": 220,
        "wires": []
    },
    {
        "id": "9dfae358f19d380b",
        "type": "function",
        "z": "f6c8f50b75376b12",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=13\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 940,
        "wires": [
            [
                "4ff0557c79a22048",
                "6a89475cfc0c08ec"
            ]
        ]
    },
    {
        "id": "4ff0557c79a22048",
        "type": "debug",
        "z": "f6c8f50b75376b12",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 1140,
        "wires": []
    },
    {
        "id": "0107937eed074b61",
        "type": "function",
        "z": "f6c8f50b75376b12",
        "name": "vda_status_finished MILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 980,
        "wires": [
            [
                "4ff0557c79a22048",
                "6a89475cfc0c08ec"
            ]
        ]
    },
    {
        "id": "d391c770207c477e",
        "type": "change",
        "z": "f6c8f50b75376b12",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 860,
        "wires": [
            []
        ]
    },
    {
        "id": "26f2c2edb2823204",
        "type": "change",
        "z": "f6c8f50b75376b12",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "f728f206bee02bb8",
        "type": "change",
        "z": "f6c8f50b75376b12",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1140,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "2195e1f52695f907",
        "type": "function",
        "z": "f6c8f50b75376b12",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"MILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"MILL\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": 0,\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\n// factsheet for MILL\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.41\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "eba861f25c6310f2",
        "type": "function",
        "z": "f6c8f50b75376b12",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 320,
        "wires": [
            [
                "c9f167cd677fc933",
                "e93ebee86dd29f0c"
            ]
        ]
    },
    {
        "id": "0c5144837e9e67be",
        "type": "OPCUA-IIoT-Browser",
        "z": "f6c8f50b75376b12",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "10c631e5670ce5e1",
        "x": 400,
        "y": 980,
        "wires": [
            [
                "e4af1351b613935f",
                "6980a5eabf32a599"
            ]
        ]
    },
    {
        "id": "59a50589ef7e6909",
        "type": "OPCUA-IIoT-Inject",
        "z": "f6c8f50b75376b12",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 980,
        "wires": [
            [
                "0c5144837e9e67be"
            ]
        ]
    },
    {
        "id": "6980a5eabf32a599",
        "type": "change",
        "z": "f6c8f50b75376b12",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "6a89475cfc0c08ec",
        "type": "link out",
        "z": "f6c8f50b75376b12",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1735,
        "y": 960,
        "wires": []
    },
    {
        "id": "5ca54bd1379d2014",
        "type": "subflow:1b897516f5bf21fa",
        "z": "f6c8f50b75376b12",
        "name": "",
        "x": 620,
        "y": 460,
        "wires": [
            [
                "d50b0f89a41e2f60"
            ],
            [
                "94de6d6d0aa329df"
            ],
            [
                "e93ebee86dd29f0c"
            ],
            []
        ]
    },
    {
        "id": "e93ebee86dd29f0c",
        "type": "link out",
        "z": "f6c8f50b75376b12",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1935,
        "y": 480,
        "wires": []
    },
    {
        "id": "621b6d9609491463",
        "type": "subflow:6a25ecd632542087",
        "z": "f6c8f50b75376b12",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-mill.json",
                "type": "str"
            },
            {
                "name": "FACTSHEET_FILENAME",
                "value": "factsheet-mill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "2195e1f52695f907"
            ]
        ]
    },
    {
        "id": "e40ed08ffd3f4845",
        "type": "function",
        "z": "f6c8f50b75376b12",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1240,
        "y": 420,
        "wires": [
            [
                "793fd25848e2ce1f",
                "e93ebee86dd29f0c"
            ]
        ]
    },
    {
        "id": "793fd25848e2ce1f",
        "type": "function",
        "z": "f6c8f50b75376b12",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 420,
        "wires": [
            [
                "e93ebee86dd29f0c"
            ]
        ]
    },
    {
        "id": "94de6d6d0aa329df",
        "type": "switch",
        "z": "f6c8f50b75376b12",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 970,
        "y": 420,
        "wires": [
            [
                "e40ed08ffd3f4845"
            ]
        ]
    },
    {
        "id": "6ac09b3176e81556",
        "type": "catch",
        "z": "f6c8f50b75376b12",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "d0eddaab120c095b"
            ]
        ]
    },
    {
        "id": "d0eddaab120c095b",
        "type": "debug",
        "z": "f6c8f50b75376b12",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "adaab3f20abc77a7",
        "type": "subflow:468f2460ce66f11e",
        "z": "f6c8f50b75376b12",
        "name": "",
        "x": 650,
        "y": 600,
        "wires": [
            [
                "e93ebee86dd29f0c"
            ]
        ]
    },
    {
        "id": "594a39967ca7c36f",
        "type": "OPCUA-IIoT-Inject",
        "z": "f6c8f50b75376b12",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 200,
        "y": 600,
        "wires": [
            [
                "a37376d3d3b0c917",
                "adaab3f20abc77a7"
            ]
        ]
    },
    {
        "id": "a37376d3d3b0c917",
        "type": "OPCUA-IIoT-Read",
        "z": "f6c8f50b75376b12",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "10c631e5670ce5e1",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 560,
        "wires": [
            [
                "adaab3f20abc77a7"
            ]
        ]
    },
    {
        "id": "5ea2281b434baee8",
        "type": "OPCUA-IIoT-Inject",
        "z": "f6c8f50b75376b12",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=21",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 460,
        "wires": [
            [
                "51f1c446fdc888f3"
            ]
        ]
    },
    {
        "id": "7b9e43c2b1e8f3ac",
        "type": "OPCUA-IIoT-Listener",
        "z": "05a427a07096ebdb",
        "connector": "7859b273f274fc48",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 580,
        "y": 980,
        "wires": [
            [
                "3faa32427cf78361"
            ]
        ]
    },
    {
        "id": "79a8ab2b7ba63194",
        "type": "OPCUA-IIoT-Read",
        "z": "05a427a07096ebdb",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "7859b273f274fc48",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 390,
        "y": 460,
        "wires": [
            [
                "7c1ea1a955e6d26f"
            ]
        ]
    },
    {
        "id": "28bd4ce3740d5b46",
        "type": "function",
        "z": "05a427a07096ebdb",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"MILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"name\": \"mill\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" },\n                { \"name\": \"duration\", \"nodeId\": \"ns=4;i=11\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 240,
        "wires": [
            [
                "0dd964455236b34d"
            ],
            [
                "a4f3b40f6c0c4682"
            ]
        ]
    },
    {
        "id": "0dd964455236b34d",
        "type": "OPCUA-IIoT-Write",
        "z": "05a427a07096ebdb",
        "connector": "7859b273f274fc48",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 1190,
        "y": 180,
        "wires": [
            [
                "3c347c97b8ce57fe",
                "16a196eefbc5fc23"
            ]
        ]
    },
    {
        "id": "16a196eefbc5fc23",
        "type": "debug",
        "z": "05a427a07096ebdb",
        "name": "write MSg",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 140,
        "wires": []
    },
    {
        "id": "9dc9bfd6a24c5af1",
        "type": "function",
        "z": "05a427a07096ebdb",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 1020,
        "wires": [
            [
                "6d59f394b8e096cd",
                "c8f59ce606cc90ca"
            ]
        ]
    },
    {
        "id": "3faa32427cf78361",
        "type": "switch",
        "z": "05a427a07096ebdb",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 980,
        "wires": [
            [],
            [
                "bacf247c53368113",
                "e0ddd3bfdb9d3ce2"
            ],
            [
                "e0ddd3bfdb9d3ce2"
            ],
            [
                "39cc4d4ab24b8172"
            ],
            [],
            [
                "688e61492fe26e5c"
            ],
            [],
            [
                "f5fbb20a8764a759",
                "9dc9bfd6a24c5af1"
            ],
            [
                "9dc9bfd6a24c5af1"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "mill_aktiv",
            "mill_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "3c347c97b8ce57fe",
        "type": "function",
        "z": "05a427a07096ebdb",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 220,
        "wires": [
            [
                "709c9acac5bbe0c5",
                "d2239bd3216b6c97"
            ]
        ]
    },
    {
        "id": "709c9acac5bbe0c5",
        "type": "debug",
        "z": "05a427a07096ebdb",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1810,
        "y": 220,
        "wires": []
    },
    {
        "id": "e0ddd3bfdb9d3ce2",
        "type": "function",
        "z": "05a427a07096ebdb",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=13\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 940,
        "wires": [
            [
                "6d59f394b8e096cd",
                "c8f59ce606cc90ca"
            ]
        ]
    },
    {
        "id": "6d59f394b8e096cd",
        "type": "debug",
        "z": "05a427a07096ebdb",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 1140,
        "wires": []
    },
    {
        "id": "688e61492fe26e5c",
        "type": "function",
        "z": "05a427a07096ebdb",
        "name": "vda_status_finished MILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 980,
        "wires": [
            [
                "6d59f394b8e096cd",
                "c8f59ce606cc90ca"
            ]
        ]
    },
    {
        "id": "39cc4d4ab24b8172",
        "type": "change",
        "z": "05a427a07096ebdb",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 860,
        "wires": [
            []
        ]
    },
    {
        "id": "f5fbb20a8764a759",
        "type": "change",
        "z": "05a427a07096ebdb",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "bacf247c53368113",
        "type": "change",
        "z": "05a427a07096ebdb",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1140,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "1d62b8d1f6e0c080",
        "type": "function",
        "z": "05a427a07096ebdb",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"MILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"MILL\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": 0,\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\n// factsheet for MILL\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.42\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "a4f3b40f6c0c4682",
        "type": "function",
        "z": "05a427a07096ebdb",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 320,
        "wires": [
            [
                "709c9acac5bbe0c5",
                "d2239bd3216b6c97"
            ]
        ]
    },
    {
        "id": "03dc71409a2e9496",
        "type": "OPCUA-IIoT-Browser",
        "z": "05a427a07096ebdb",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "7859b273f274fc48",
        "x": 400,
        "y": 980,
        "wires": [
            [
                "7b9e43c2b1e8f3ac",
                "bcd06b533f96ce5c"
            ]
        ]
    },
    {
        "id": "2239e24f817fe7c5",
        "type": "OPCUA-IIoT-Inject",
        "z": "05a427a07096ebdb",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 980,
        "wires": [
            [
                "03dc71409a2e9496"
            ]
        ]
    },
    {
        "id": "bcd06b533f96ce5c",
        "type": "change",
        "z": "05a427a07096ebdb",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "c8f59ce606cc90ca",
        "type": "link out",
        "z": "05a427a07096ebdb",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1735,
        "y": 960,
        "wires": []
    },
    {
        "id": "7c1ea1a955e6d26f",
        "type": "subflow:1b897516f5bf21fa",
        "z": "05a427a07096ebdb",
        "name": "",
        "x": 620,
        "y": 460,
        "wires": [
            [
                "28bd4ce3740d5b46"
            ],
            [
                "6b6c21345ca583f1"
            ],
            [
                "d2239bd3216b6c97"
            ],
            []
        ]
    },
    {
        "id": "d2239bd3216b6c97",
        "type": "link out",
        "z": "05a427a07096ebdb",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1935,
        "y": 480,
        "wires": []
    },
    {
        "id": "640bd29d7f9f9243",
        "type": "subflow:6a25ecd632542087",
        "z": "05a427a07096ebdb",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-mill.json",
                "type": "str"
            },
            {
                "name": "FACTSHEET_FILENAME",
                "value": "factsheet-mill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "1d62b8d1f6e0c080"
            ]
        ]
    },
    {
        "id": "a7c38ab0e58110ca",
        "type": "function",
        "z": "05a427a07096ebdb",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1240,
        "y": 420,
        "wires": [
            [
                "0a6e35de5d306ab6",
                "d2239bd3216b6c97"
            ]
        ]
    },
    {
        "id": "0a6e35de5d306ab6",
        "type": "function",
        "z": "05a427a07096ebdb",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 420,
        "wires": [
            [
                "d2239bd3216b6c97"
            ]
        ]
    },
    {
        "id": "6b6c21345ca583f1",
        "type": "switch",
        "z": "05a427a07096ebdb",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 970,
        "y": 420,
        "wires": [
            [
                "a7c38ab0e58110ca"
            ]
        ]
    },
    {
        "id": "8a6a4971aab79fe9",
        "type": "catch",
        "z": "05a427a07096ebdb",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "867e0ab9d722b88f"
            ]
        ]
    },
    {
        "id": "867e0ab9d722b88f",
        "type": "debug",
        "z": "05a427a07096ebdb",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "e6213a541f6cc0ef",
        "type": "subflow:468f2460ce66f11e",
        "z": "05a427a07096ebdb",
        "name": "",
        "x": 650,
        "y": 600,
        "wires": [
            [
                "d2239bd3216b6c97"
            ]
        ]
    },
    {
        "id": "7b64ee4eee4a57cb",
        "type": "OPCUA-IIoT-Inject",
        "z": "05a427a07096ebdb",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 600,
        "wires": [
            [
                "3ca0e8cce791e547",
                "e6213a541f6cc0ef"
            ]
        ]
    },
    {
        "id": "3ca0e8cce791e547",
        "type": "OPCUA-IIoT-Read",
        "z": "05a427a07096ebdb",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "7859b273f274fc48",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 390,
        "y": 560,
        "wires": [
            [
                "e6213a541f6cc0ef"
            ]
        ]
    },
    {
        "id": "8a02b1228a3bd26d",
        "type": "OPCUA-IIoT-Inject",
        "z": "05a427a07096ebdb",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=21",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 460,
        "wires": [
            [
                "79a8ab2b7ba63194"
            ]
        ]
    },
    {
        "id": "50d0da44b9c33ab1",
        "type": "OPCUA-IIoT-Listener",
        "z": "a0e5f985232949c9",
        "connector": "014fc68d7d610e9d",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 580,
        "y": 980,
        "wires": [
            [
                "aa8cd1b7de2db0eb"
            ]
        ]
    },
    {
        "id": "7bb73981cc64192c",
        "type": "OPCUA-IIoT-Read",
        "z": "a0e5f985232949c9",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "014fc68d7d610e9d",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 390,
        "y": 460,
        "wires": [
            [
                "caada65e18fbd22b"
            ]
        ]
    },
    {
        "id": "6bdcbfaff638b488",
        "type": "function",
        "z": "a0e5f985232949c9",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"MILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"name\": \"mill\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" },\n                { \"name\": \"duration\", \"nodeId\": \"ns=4;i=11\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 240,
        "wires": [
            [
                "0ed45d4159b737f0"
            ],
            [
                "6d76228171bfc25d"
            ]
        ]
    },
    {
        "id": "0ed45d4159b737f0",
        "type": "OPCUA-IIoT-Write",
        "z": "a0e5f985232949c9",
        "connector": "014fc68d7d610e9d",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 1190,
        "y": 180,
        "wires": [
            [
                "4ab12f97b3726869",
                "6179fcbc8e98af0f"
            ]
        ]
    },
    {
        "id": "6179fcbc8e98af0f",
        "type": "debug",
        "z": "a0e5f985232949c9",
        "name": "write MSg",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 140,
        "wires": []
    },
    {
        "id": "d96ea8bd9bd887e8",
        "type": "function",
        "z": "a0e5f985232949c9",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 1020,
        "wires": [
            [
                "7c7c4b82763e50f3",
                "7fd52d35a43b2482"
            ]
        ]
    },
    {
        "id": "aa8cd1b7de2db0eb",
        "type": "switch",
        "z": "a0e5f985232949c9",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 980,
        "wires": [
            [],
            [
                "e302bc854b468fb3",
                "88822f3d38a8cf5d"
            ],
            [
                "88822f3d38a8cf5d"
            ],
            [
                "1439cb2cee54dc68"
            ],
            [],
            [
                "eff8df734c02aef8"
            ],
            [],
            [
                "15c731173260b413",
                "d96ea8bd9bd887e8"
            ],
            [
                "d96ea8bd9bd887e8"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "mill_aktiv",
            "mill_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "4ab12f97b3726869",
        "type": "function",
        "z": "a0e5f985232949c9",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 220,
        "wires": [
            [
                "a1a19b05031590fe",
                "da46fcdf765cd02f"
            ]
        ]
    },
    {
        "id": "a1a19b05031590fe",
        "type": "debug",
        "z": "a0e5f985232949c9",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1810,
        "y": 220,
        "wires": []
    },
    {
        "id": "88822f3d38a8cf5d",
        "type": "function",
        "z": "a0e5f985232949c9",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=13\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 940,
        "wires": [
            [
                "7c7c4b82763e50f3",
                "7fd52d35a43b2482"
            ]
        ]
    },
    {
        "id": "7c7c4b82763e50f3",
        "type": "debug",
        "z": "a0e5f985232949c9",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 1140,
        "wires": []
    },
    {
        "id": "eff8df734c02aef8",
        "type": "function",
        "z": "a0e5f985232949c9",
        "name": "vda_status_finished MILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 980,
        "wires": [
            [
                "7c7c4b82763e50f3",
                "7fd52d35a43b2482"
            ]
        ]
    },
    {
        "id": "1439cb2cee54dc68",
        "type": "change",
        "z": "a0e5f985232949c9",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 860,
        "wires": [
            []
        ]
    },
    {
        "id": "15c731173260b413",
        "type": "change",
        "z": "a0e5f985232949c9",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "e302bc854b468fb3",
        "type": "change",
        "z": "a0e5f985232949c9",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1140,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "acaebea02aae425c",
        "type": "function",
        "z": "a0e5f985232949c9",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"MILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"MILL\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": 0,\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\n// factsheet for MILL\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.43\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "6d76228171bfc25d",
        "type": "function",
        "z": "a0e5f985232949c9",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 320,
        "wires": [
            [
                "a1a19b05031590fe",
                "da46fcdf765cd02f"
            ]
        ]
    },
    {
        "id": "192b3ab7d07a0f04",
        "type": "OPCUA-IIoT-Browser",
        "z": "a0e5f985232949c9",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "014fc68d7d610e9d",
        "x": 400,
        "y": 980,
        "wires": [
            [
                "50d0da44b9c33ab1",
                "9e66db44793de846"
            ]
        ]
    },
    {
        "id": "90f081c9f5d3771e",
        "type": "OPCUA-IIoT-Inject",
        "z": "a0e5f985232949c9",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 980,
        "wires": [
            [
                "192b3ab7d07a0f04"
            ]
        ]
    },
    {
        "id": "9e66db44793de846",
        "type": "change",
        "z": "a0e5f985232949c9",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "7fd52d35a43b2482",
        "type": "link out",
        "z": "a0e5f985232949c9",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1735,
        "y": 960,
        "wires": []
    },
    {
        "id": "caada65e18fbd22b",
        "type": "subflow:1b897516f5bf21fa",
        "z": "a0e5f985232949c9",
        "name": "",
        "x": 620,
        "y": 460,
        "wires": [
            [
                "6bdcbfaff638b488"
            ],
            [
                "bebb38a1524be2cc"
            ],
            [
                "da46fcdf765cd02f"
            ],
            []
        ]
    },
    {
        "id": "da46fcdf765cd02f",
        "type": "link out",
        "z": "a0e5f985232949c9",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1935,
        "y": 480,
        "wires": []
    },
    {
        "id": "0b2b566e650c31fb",
        "type": "subflow:6a25ecd632542087",
        "z": "a0e5f985232949c9",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-mill.json",
                "type": "str"
            },
            {
                "name": "FACTSHEET_FILENAME",
                "value": "factsheet-mill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "acaebea02aae425c"
            ]
        ]
    },
    {
        "id": "e781e4b0a40357f4",
        "type": "function",
        "z": "a0e5f985232949c9",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1240,
        "y": 420,
        "wires": [
            [
                "85c9360a486bb811",
                "da46fcdf765cd02f"
            ]
        ]
    },
    {
        "id": "85c9360a486bb811",
        "type": "function",
        "z": "a0e5f985232949c9",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 420,
        "wires": [
            [
                "da46fcdf765cd02f"
            ]
        ]
    },
    {
        "id": "bebb38a1524be2cc",
        "type": "switch",
        "z": "a0e5f985232949c9",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 970,
        "y": 420,
        "wires": [
            [
                "e781e4b0a40357f4"
            ]
        ]
    },
    {
        "id": "a89a0dcd6465d828",
        "type": "catch",
        "z": "a0e5f985232949c9",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "9b3aab1e59ca7645"
            ]
        ]
    },
    {
        "id": "9b3aab1e59ca7645",
        "type": "debug",
        "z": "a0e5f985232949c9",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "bff72ef49476ea7d",
        "type": "subflow:468f2460ce66f11e",
        "z": "a0e5f985232949c9",
        "name": "",
        "x": 650,
        "y": 600,
        "wires": [
            [
                "da46fcdf765cd02f"
            ]
        ]
    },
    {
        "id": "51edac07ca5cfe23",
        "type": "OPCUA-IIoT-Inject",
        "z": "a0e5f985232949c9",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 600,
        "wires": [
            [
                "b2283d203542ad97",
                "bff72ef49476ea7d"
            ]
        ]
    },
    {
        "id": "b2283d203542ad97",
        "type": "OPCUA-IIoT-Read",
        "z": "a0e5f985232949c9",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "014fc68d7d610e9d",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 390,
        "y": 560,
        "wires": [
            [
                "bff72ef49476ea7d"
            ]
        ]
    },
    {
        "id": "8a833b4160a1e68e",
        "type": "OPCUA-IIoT-Inject",
        "z": "a0e5f985232949c9",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=21",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 460,
        "wires": [
            [
                "7bb73981cc64192c"
            ]
        ]
    },
    {
        "id": "ae2be797c95aff65",
        "type": "OPCUA-IIoT-Listener",
        "z": "5fc4fbd01fd96575",
        "connector": "dc24d4023df4a98c",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 580,
        "y": 980,
        "wires": [
            [
                "de7d743634022218"
            ]
        ]
    },
    {
        "id": "bdecf968fce32409",
        "type": "OPCUA-IIoT-Read",
        "z": "5fc4fbd01fd96575",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "dc24d4023df4a98c",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 390,
        "y": 460,
        "wires": [
            [
                "6e69d179b76cc20a"
            ]
        ]
    },
    {
        "id": "37f95576f2039358",
        "type": "function",
        "z": "5fc4fbd01fd96575",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"MILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"name\": \"mill\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" },\n                { \"name\": \"duration\", \"nodeId\": \"ns=4;i=11\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 240,
        "wires": [
            [
                "898359777571d4e5"
            ],
            [
                "ada95e0dbc40ed50"
            ]
        ]
    },
    {
        "id": "898359777571d4e5",
        "type": "OPCUA-IIoT-Write",
        "z": "5fc4fbd01fd96575",
        "connector": "dc24d4023df4a98c",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 1190,
        "y": 180,
        "wires": [
            [
                "926991327fa32491",
                "4bead212bf3c4830"
            ]
        ]
    },
    {
        "id": "4bead212bf3c4830",
        "type": "debug",
        "z": "5fc4fbd01fd96575",
        "name": "write MSg",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 140,
        "wires": []
    },
    {
        "id": "5fd3e042ede74b83",
        "type": "function",
        "z": "5fc4fbd01fd96575",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 1020,
        "wires": [
            [
                "e81a7450cc6160e0",
                "2214f7baa101d895"
            ]
        ]
    },
    {
        "id": "de7d743634022218",
        "type": "switch",
        "z": "5fc4fbd01fd96575",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 980,
        "wires": [
            [],
            [
                "1d382824a19008bb",
                "bd732f949d519f56"
            ],
            [
                "bd732f949d519f56"
            ],
            [
                "30c5fbe84ce4eea9"
            ],
            [],
            [
                "dbdf2b0e6ca6a6d1"
            ],
            [],
            [
                "03a16fdd30a264c2",
                "5fd3e042ede74b83"
            ],
            [
                "5fd3e042ede74b83"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "mill_aktiv",
            "mill_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "926991327fa32491",
        "type": "function",
        "z": "5fc4fbd01fd96575",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 220,
        "wires": [
            [
                "2935769b6a05b7c7",
                "761fbdab37b1fd92"
            ]
        ]
    },
    {
        "id": "2935769b6a05b7c7",
        "type": "debug",
        "z": "5fc4fbd01fd96575",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1810,
        "y": 220,
        "wires": []
    },
    {
        "id": "bd732f949d519f56",
        "type": "function",
        "z": "5fc4fbd01fd96575",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=13\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 940,
        "wires": [
            [
                "e81a7450cc6160e0",
                "2214f7baa101d895"
            ]
        ]
    },
    {
        "id": "e81a7450cc6160e0",
        "type": "debug",
        "z": "5fc4fbd01fd96575",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 1140,
        "wires": []
    },
    {
        "id": "dbdf2b0e6ca6a6d1",
        "type": "function",
        "z": "5fc4fbd01fd96575",
        "name": "vda_status_finished MILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 980,
        "wires": [
            [
                "e81a7450cc6160e0",
                "2214f7baa101d895"
            ]
        ]
    },
    {
        "id": "30c5fbe84ce4eea9",
        "type": "change",
        "z": "5fc4fbd01fd96575",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 860,
        "wires": [
            []
        ]
    },
    {
        "id": "03a16fdd30a264c2",
        "type": "change",
        "z": "5fc4fbd01fd96575",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1130,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "1d382824a19008bb",
        "type": "change",
        "z": "5fc4fbd01fd96575",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1140,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "7f521eb466112c18",
        "type": "function",
        "z": "5fc4fbd01fd96575",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"MILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"MILL\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": 0,\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\n// factsheet for MILL\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.44\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "ada95e0dbc40ed50",
        "type": "function",
        "z": "5fc4fbd01fd96575",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 320,
        "wires": [
            [
                "2935769b6a05b7c7",
                "761fbdab37b1fd92"
            ]
        ]
    },
    {
        "id": "d74d9f7a50e6c58a",
        "type": "OPCUA-IIoT-Browser",
        "z": "5fc4fbd01fd96575",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "dc24d4023df4a98c",
        "x": 400,
        "y": 980,
        "wires": [
            [
                "ae2be797c95aff65",
                "acb934ea79de6d02"
            ]
        ]
    },
    {
        "id": "3ae7e19004fce37f",
        "type": "OPCUA-IIoT-Inject",
        "z": "5fc4fbd01fd96575",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 980,
        "wires": [
            [
                "d74d9f7a50e6c58a"
            ]
        ]
    },
    {
        "id": "acb934ea79de6d02",
        "type": "change",
        "z": "5fc4fbd01fd96575",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 880,
        "wires": [
            []
        ]
    },
    {
        "id": "2214f7baa101d895",
        "type": "link out",
        "z": "5fc4fbd01fd96575",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1735,
        "y": 960,
        "wires": []
    },
    {
        "id": "6e69d179b76cc20a",
        "type": "subflow:1b897516f5bf21fa",
        "z": "5fc4fbd01fd96575",
        "name": "",
        "x": 620,
        "y": 460,
        "wires": [
            [
                "37f95576f2039358"
            ],
            [
                "dd9c46da111f78ed"
            ],
            [
                "761fbdab37b1fd92"
            ],
            []
        ]
    },
    {
        "id": "761fbdab37b1fd92",
        "type": "link out",
        "z": "5fc4fbd01fd96575",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1935,
        "y": 480,
        "wires": []
    },
    {
        "id": "5fc0321fd93438bb",
        "type": "subflow:6a25ecd632542087",
        "z": "5fc4fbd01fd96575",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-mill.json",
                "type": "str"
            },
            {
                "name": "FACTSHEET_FILENAME",
                "value": "factsheet-mill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "7f521eb466112c18"
            ]
        ]
    },
    {
        "id": "599fd0682f16bc4a",
        "type": "function",
        "z": "5fc4fbd01fd96575",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1240,
        "y": 420,
        "wires": [
            [
                "d9078bf8e5723ca5",
                "761fbdab37b1fd92"
            ]
        ]
    },
    {
        "id": "d9078bf8e5723ca5",
        "type": "function",
        "z": "5fc4fbd01fd96575",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 420,
        "wires": [
            [
                "761fbdab37b1fd92"
            ]
        ]
    },
    {
        "id": "dd9c46da111f78ed",
        "type": "switch",
        "z": "5fc4fbd01fd96575",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 970,
        "y": 420,
        "wires": [
            [
                "599fd0682f16bc4a"
            ]
        ]
    },
    {
        "id": "a65bbacb093ca7ad",
        "type": "catch",
        "z": "5fc4fbd01fd96575",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "795754639a288c51"
            ]
        ]
    },
    {
        "id": "795754639a288c51",
        "type": "debug",
        "z": "5fc4fbd01fd96575",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "beee5c9cf10d8732",
        "type": "subflow:468f2460ce66f11e",
        "z": "5fc4fbd01fd96575",
        "name": "",
        "x": 650,
        "y": 580,
        "wires": [
            [
                "761fbdab37b1fd92"
            ]
        ]
    },
    {
        "id": "683123e8f9ac550d",
        "type": "OPCUA-IIoT-Inject",
        "z": "5fc4fbd01fd96575",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 580,
        "wires": [
            [
                "4dbf24305e1117c1",
                "beee5c9cf10d8732"
            ]
        ]
    },
    {
        "id": "4dbf24305e1117c1",
        "type": "OPCUA-IIoT-Read",
        "z": "5fc4fbd01fd96575",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "dc24d4023df4a98c",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 390,
        "y": 540,
        "wires": [
            [
                "beee5c9cf10d8732"
            ]
        ]
    },
    {
        "id": "34665b2f9ef23118",
        "type": "OPCUA-IIoT-Inject",
        "z": "5fc4fbd01fd96575",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=21",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 460,
        "wires": [
            [
                "bdecf968fce32409"
            ]
        ]
    },
    {
        "id": "5616f93f3b4b44c5",
        "type": "OPCUA-IIoT-Listener",
        "z": "74c49629fbf36c6c",
        "connector": "a2de3bab55be08b7",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 820,
        "wires": [
            [
                "d8f0d300406c046b",
                "bd56e4360c56875f"
            ]
        ]
    },
    {
        "id": "406ce52d7e1889a5",
        "type": "OPCUA-IIoT-Inject",
        "z": "74c49629fbf36c6c",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=20",
                "datatypeName": "String"
            }
        ],
        "x": 150,
        "y": 380,
        "wires": [
            [
                "c07b9fee67ab4c02"
            ]
        ]
    },
    {
        "id": "c07b9fee67ab4c02",
        "type": "OPCUA-IIoT-Read",
        "z": "74c49629fbf36c6c",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "a2de3bab55be08b7",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 380,
        "wires": [
            [
                "c3ff6383723b4e50"
            ]
        ]
    },
    {
        "id": "7d7956859647c9ea",
        "type": "function",
        "z": "74c49629fbf36c6c",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DRILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration}];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=10\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg,null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 240,
        "wires": [
            [
                "de76f7b399b9ac0c"
            ],
            [
                "e18115031cc8d3a7"
            ]
        ]
    },
    {
        "id": "de76f7b399b9ac0c",
        "type": "OPCUA-IIoT-Write",
        "z": "74c49629fbf36c6c",
        "connector": "a2de3bab55be08b7",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1210,
        "y": 160,
        "wires": [
            [
                "c1b080c3f870f828",
                "5d0ee9e17066fdb4"
            ]
        ]
    },
    {
        "id": "5d0ee9e17066fdb4",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "write MSg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1460,
        "y": 60,
        "wires": []
    },
    {
        "id": "fc28b05ff2ff5c6d",
        "type": "function",
        "z": "74c49629fbf36c6c",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=7\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 840,
        "wires": [
            [
                "c2161701925565db",
                "7e3aa730b8656bf6"
            ]
        ]
    },
    {
        "id": "d8f0d300406c046b",
        "type": "switch",
        "z": "74c49629fbf36c6c",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=7",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 820,
        "wires": [
            [],
            [
                "42627a92b15a92cb"
            ],
            [],
            [
                "f667275b68cbb63c",
                "a88d64096b771875",
                "be6415039c416eef"
            ],
            [
                "a88d64096b771875",
                "be6415039c416eef"
            ],
            [
                "18e1e599b8ce7c03"
            ],
            [],
            [
                "7a4786c57772e773",
                "fc28b05ff2ff5c6d"
            ],
            [
                "fc28b05ff2ff5c6d"
            ]
        ],
        "outputLabels": [
            "drill_aktiv",
            "drill_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "c1b080c3f870f828",
        "type": "function",
        "z": "74c49629fbf36c6c",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1510,
        "y": 160,
        "wires": [
            [
                "a265782ee694e465",
                "05e39b93c0873051"
            ]
        ]
    },
    {
        "id": "a265782ee694e465",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1790,
        "y": 240,
        "wires": []
    },
    {
        "id": "be6415039c416eef",
        "type": "function",
        "z": "74c49629fbf36c6c",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 800,
        "wires": [
            [
                "c2161701925565db",
                "7e3aa730b8656bf6"
            ]
        ]
    },
    {
        "id": "c2161701925565db",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1780,
        "y": 740,
        "wires": []
    },
    {
        "id": "42627a92b15a92cb",
        "type": "function",
        "z": "74c49629fbf36c6c",
        "name": "vda_status_finished DRILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 760,
        "wires": [
            [
                "c2161701925565db",
                "7e3aa730b8656bf6"
            ]
        ]
    },
    {
        "id": "18e1e599b8ce7c03",
        "type": "change",
        "z": "74c49629fbf36c6c",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "7a4786c57772e773",
        "type": "change",
        "z": "74c49629fbf36c6c",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 620,
        "wires": [
            [
                "f3d8a52465ba50ec"
            ]
        ]
    },
    {
        "id": "f667275b68cbb63c",
        "type": "change",
        "z": "74c49629fbf36c6c",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1080,
        "y": 700,
        "wires": [
            [
                "f3d8a52465ba50ec"
            ]
        ]
    },
    {
        "id": "84ae377e36db6603",
        "type": "function",
        "z": "74c49629fbf36c6c",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"DRILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"DRILL\");\nflow.set(\"errors\", []);\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.50\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "bd56e4360c56875f",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 960,
        "wires": []
    },
    {
        "id": "e18115031cc8d3a7",
        "type": "function",
        "z": "74c49629fbf36c6c",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 240,
        "wires": [
            [
                "a265782ee694e465",
                "05e39b93c0873051"
            ]
        ]
    },
    {
        "id": "3e990dd198d6a37b",
        "type": "OPCUA-IIoT-Browser",
        "z": "74c49629fbf36c6c",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "a2de3bab55be08b7",
        "x": 400,
        "y": 820,
        "wires": [
            [
                "5616f93f3b4b44c5",
                "bc0133343146f199",
                "b2d53d2f18cec5e8"
            ]
        ]
    },
    {
        "id": "4fcd283ec8ecec8e",
        "type": "OPCUA-IIoT-Inject",
        "z": "74c49629fbf36c6c",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 820,
        "wires": [
            [
                "3e990dd198d6a37b"
            ]
        ]
    },
    {
        "id": "bc0133343146f199",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 660,
        "wires": []
    },
    {
        "id": "b2d53d2f18cec5e8",
        "type": "change",
        "z": "74c49629fbf36c6c",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "7e3aa730b8656bf6",
        "type": "link out",
        "z": "74c49629fbf36c6c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1835,
        "y": 820,
        "wires": []
    },
    {
        "id": "c3ff6383723b4e50",
        "type": "subflow:1b897516f5bf21fa",
        "z": "74c49629fbf36c6c",
        "name": "",
        "x": 640,
        "y": 380,
        "wires": [
            [
                "7d7956859647c9ea",
                "18571427c518ed82"
            ],
            [
                "128929c690206a9c",
                "bf74221ea43883ea"
            ],
            [
                "05e39b93c0873051"
            ],
            []
        ]
    },
    {
        "id": "05e39b93c0873051",
        "type": "link out",
        "z": "74c49629fbf36c6c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1825,
        "y": 460,
        "wires": []
    },
    {
        "id": "fbbed8041ae9855c",
        "type": "subflow:6a25ecd632542087",
        "z": "74c49629fbf36c6c",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-drill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "84ae377e36db6603"
            ]
        ]
    },
    {
        "id": "d037522f8805c78d",
        "type": "function",
        "z": "74c49629fbf36c6c",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 320,
        "wires": [
            [
                "446e1e33906ec354",
                "05e39b93c0873051"
            ]
        ]
    },
    {
        "id": "446e1e33906ec354",
        "type": "function",
        "z": "74c49629fbf36c6c",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\nflow.set(\"errors\", {});\nflow.set(\"orderId\", 0);\nflow.set(\"orderUpdateId\", 0);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 320,
        "wires": [
            [
                "05e39b93c0873051"
            ]
        ]
    },
    {
        "id": "128929c690206a9c",
        "type": "switch",
        "z": "74c49629fbf36c6c",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 930,
        "y": 320,
        "wires": [
            [
                "d037522f8805c78d",
                "bf74221ea43883ea"
            ]
        ]
    },
    {
        "id": "9305974a7c32a34d",
        "type": "catch",
        "z": "74c49629fbf36c6c",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "a1d9153b1814ae69"
            ]
        ]
    },
    {
        "id": "a1d9153b1814ae69",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "bf74221ea43883ea",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "supportedInstantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1200,
        "y": 380,
        "wires": []
    },
    {
        "id": "18571427c518ed82",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "Debug-Order-Actions",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 220,
        "wires": []
    },
    {
        "id": "a88d64096b771875",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "drop-end-state",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1060,
        "y": 1080,
        "wires": []
    },
    {
        "id": "f3d8a52465ba50ec",
        "type": "debug",
        "z": "74c49629fbf36c6c",
        "name": "state switch",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1410,
        "y": 1060,
        "wires": []
    },
    {
        "id": "46b210f3be4c9059",
        "type": "subflow:468f2460ce66f11e",
        "z": "74c49629fbf36c6c",
        "name": "",
        "x": 610,
        "y": 500,
        "wires": [
            [
                "05e39b93c0873051"
            ]
        ]
    },
    {
        "id": "1aaf74e5ec85e7ca",
        "type": "OPCUA-IIoT-Inject",
        "z": "74c49629fbf36c6c",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 160,
        "y": 500,
        "wires": [
            [
                "dc576bc12a65325f",
                "46b210f3be4c9059"
            ]
        ]
    },
    {
        "id": "dc576bc12a65325f",
        "type": "OPCUA-IIoT-Read",
        "z": "74c49629fbf36c6c",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "a2de3bab55be08b7",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 460,
        "wires": [
            [
                "46b210f3be4c9059"
            ]
        ]
    },
    {
        "id": "edc7be6562080b37",
        "type": "OPCUA-IIoT-Listener",
        "z": "4b7639b8a17bacd0",
        "connector": "2933482444424b0c",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 820,
        "wires": [
            [
                "ee80def4f33cd81b",
                "7862708a0386beec"
            ]
        ]
    },
    {
        "id": "5ce8bb3a2c524213",
        "type": "OPCUA-IIoT-Read",
        "z": "4b7639b8a17bacd0",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "2933482444424b0c",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 380,
        "wires": [
            [
                "a8f07c596e20abdc"
            ]
        ]
    },
    {
        "id": "0d5b632604a0810c",
        "type": "function",
        "z": "4b7639b8a17bacd0",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DRILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=10\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 240,
        "wires": [
            [
                "d8fbd4e10b38291e"
            ],
            [
                "53b031bff04d82fb"
            ]
        ]
    },
    {
        "id": "d8fbd4e10b38291e",
        "type": "OPCUA-IIoT-Write",
        "z": "4b7639b8a17bacd0",
        "connector": "2933482444424b0c",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1210,
        "y": 160,
        "wires": [
            [
                "e76cab31b4425384",
                "4bfc8e6c766d0fcb"
            ]
        ]
    },
    {
        "id": "4bfc8e6c766d0fcb",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "write MSg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1460,
        "y": 60,
        "wires": []
    },
    {
        "id": "4a57accba22b6efc",
        "type": "function",
        "z": "4b7639b8a17bacd0",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=7\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 840,
        "wires": [
            [
                "4b3db60ed5a886c8",
                "5a0397a45e9acc40"
            ]
        ]
    },
    {
        "id": "ee80def4f33cd81b",
        "type": "switch",
        "z": "4b7639b8a17bacd0",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=7",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 820,
        "wires": [
            [],
            [
                "ec2dfe1c7f6bed2f"
            ],
            [],
            [
                "ca21f26831ae0f26",
                "b9d8cb1251ac4048",
                "39e80af69d9c2ee1"
            ],
            [
                "b9d8cb1251ac4048",
                "39e80af69d9c2ee1"
            ],
            [
                "36de05d164807ff8"
            ],
            [],
            [
                "fa1dbf363e737781",
                "4a57accba22b6efc"
            ],
            [
                "4a57accba22b6efc"
            ]
        ],
        "outputLabels": [
            "drill_aktiv",
            "drill_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "e76cab31b4425384",
        "type": "function",
        "z": "4b7639b8a17bacd0",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1510,
        "y": 160,
        "wires": [
            [
                "b602d5bce6b994dc",
                "1c2304c530564b98"
            ]
        ]
    },
    {
        "id": "b602d5bce6b994dc",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1790,
        "y": 240,
        "wires": []
    },
    {
        "id": "39e80af69d9c2ee1",
        "type": "function",
        "z": "4b7639b8a17bacd0",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 800,
        "wires": [
            [
                "4b3db60ed5a886c8",
                "5a0397a45e9acc40"
            ]
        ]
    },
    {
        "id": "4b3db60ed5a886c8",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1780,
        "y": 740,
        "wires": []
    },
    {
        "id": "ec2dfe1c7f6bed2f",
        "type": "function",
        "z": "4b7639b8a17bacd0",
        "name": "vda_status_finished DRILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 760,
        "wires": [
            [
                "4b3db60ed5a886c8",
                "5a0397a45e9acc40"
            ]
        ]
    },
    {
        "id": "36de05d164807ff8",
        "type": "change",
        "z": "4b7639b8a17bacd0",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "fa1dbf363e737781",
        "type": "change",
        "z": "4b7639b8a17bacd0",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 620,
        "wires": [
            [
                "731e5c7cf05b896f"
            ]
        ]
    },
    {
        "id": "ca21f26831ae0f26",
        "type": "change",
        "z": "4b7639b8a17bacd0",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1080,
        "y": 700,
        "wires": [
            [
                "731e5c7cf05b896f"
            ]
        ]
    },
    {
        "id": "6e9d517c1718102b",
        "type": "function",
        "z": "4b7639b8a17bacd0",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"DRILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"DRILL\");\nflow.set(\"errors\", []);\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.51\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "7862708a0386beec",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 960,
        "wires": []
    },
    {
        "id": "53b031bff04d82fb",
        "type": "function",
        "z": "4b7639b8a17bacd0",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 240,
        "wires": [
            [
                "b602d5bce6b994dc",
                "1c2304c530564b98"
            ]
        ]
    },
    {
        "id": "916ee7fe37645602",
        "type": "OPCUA-IIoT-Browser",
        "z": "4b7639b8a17bacd0",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "2933482444424b0c",
        "x": 400,
        "y": 820,
        "wires": [
            [
                "edc7be6562080b37",
                "35e2e138cf6fdbb3",
                "63c14bcae49940f9"
            ]
        ]
    },
    {
        "id": "ea90558b79c981d4",
        "type": "OPCUA-IIoT-Inject",
        "z": "4b7639b8a17bacd0",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 820,
        "wires": [
            [
                "916ee7fe37645602"
            ]
        ]
    },
    {
        "id": "35e2e138cf6fdbb3",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 660,
        "wires": []
    },
    {
        "id": "63c14bcae49940f9",
        "type": "change",
        "z": "4b7639b8a17bacd0",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "5a0397a45e9acc40",
        "type": "link out",
        "z": "4b7639b8a17bacd0",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1835,
        "y": 820,
        "wires": []
    },
    {
        "id": "a8f07c596e20abdc",
        "type": "subflow:1b897516f5bf21fa",
        "z": "4b7639b8a17bacd0",
        "name": "",
        "x": 640,
        "y": 380,
        "wires": [
            [
                "0d5b632604a0810c",
                "84ba94f3acd595f7"
            ],
            [
                "6797a4e760f2a0c8",
                "59718d19acbf11be"
            ],
            [
                "1c2304c530564b98"
            ],
            []
        ]
    },
    {
        "id": "1c2304c530564b98",
        "type": "link out",
        "z": "4b7639b8a17bacd0",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1825,
        "y": 460,
        "wires": []
    },
    {
        "id": "dc862e3db12792fd",
        "type": "subflow:6a25ecd632542087",
        "z": "4b7639b8a17bacd0",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-drill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "6e9d517c1718102b"
            ]
        ]
    },
    {
        "id": "2f50f968a0cc1a96",
        "type": "function",
        "z": "4b7639b8a17bacd0",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 320,
        "wires": [
            [
                "2423079d948f3c9c",
                "1c2304c530564b98"
            ]
        ]
    },
    {
        "id": "2423079d948f3c9c",
        "type": "function",
        "z": "4b7639b8a17bacd0",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\nflow.set(\"errors\", {});\nflow.set(\"orderId\", 0);\nflow.set(\"orderUpdateId\", 0);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 320,
        "wires": [
            [
                "1c2304c530564b98"
            ]
        ]
    },
    {
        "id": "6797a4e760f2a0c8",
        "type": "switch",
        "z": "4b7639b8a17bacd0",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 930,
        "y": 320,
        "wires": [
            [
                "2f50f968a0cc1a96",
                "59718d19acbf11be"
            ]
        ]
    },
    {
        "id": "107f0d0c9cdfb0d1",
        "type": "catch",
        "z": "4b7639b8a17bacd0",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "fefdfbbe3a637077"
            ]
        ]
    },
    {
        "id": "fefdfbbe3a637077",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "59718d19acbf11be",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "supportedInstantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1200,
        "y": 380,
        "wires": []
    },
    {
        "id": "84ba94f3acd595f7",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "Debug-Order-Actions",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 220,
        "wires": []
    },
    {
        "id": "b9d8cb1251ac4048",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "drop-end-state",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1060,
        "y": 1080,
        "wires": []
    },
    {
        "id": "731e5c7cf05b896f",
        "type": "debug",
        "z": "4b7639b8a17bacd0",
        "name": "state switch",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1410,
        "y": 1060,
        "wires": []
    },
    {
        "id": "99667f07b91aa9a3",
        "type": "subflow:468f2460ce66f11e",
        "z": "4b7639b8a17bacd0",
        "name": "",
        "x": 610,
        "y": 500,
        "wires": [
            [
                "1c2304c530564b98"
            ]
        ]
    },
    {
        "id": "67f690c1b16ee1cc",
        "type": "OPCUA-IIoT-Inject",
        "z": "4b7639b8a17bacd0",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 160,
        "y": 500,
        "wires": [
            [
                "8579b3278227f761",
                "99667f07b91aa9a3"
            ]
        ]
    },
    {
        "id": "8579b3278227f761",
        "type": "OPCUA-IIoT-Read",
        "z": "4b7639b8a17bacd0",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "2933482444424b0c",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 460,
        "wires": [
            [
                "99667f07b91aa9a3"
            ]
        ]
    },
    {
        "id": "31dc14aab54525b1",
        "type": "OPCUA-IIoT-Inject",
        "z": "4b7639b8a17bacd0",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=20",
                "datatypeName": "String"
            }
        ],
        "x": 150,
        "y": 380,
        "wires": [
            [
                "5ce8bb3a2c524213"
            ]
        ]
    },
    {
        "id": "422466e46c1b0566",
        "type": "OPCUA-IIoT-Listener",
        "z": "b8be3e0d96a62731",
        "connector": "e27138419046abbf",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 820,
        "wires": [
            [
                "676743537853b5ba",
                "bf4b2e3a58dc1173"
            ]
        ]
    },
    {
        "id": "804eed4f016325c9",
        "type": "OPCUA-IIoT-Read",
        "z": "b8be3e0d96a62731",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "e27138419046abbf",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 380,
        "wires": [
            [
                "9ebd312af89aeb06"
            ]
        ]
    },
    {
        "id": "233d521064eca746",
        "type": "function",
        "z": "b8be3e0d96a62731",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DRILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=10\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 240,
        "wires": [
            [
                "24990f7268258417"
            ],
            [
                "64560c2164b815b7"
            ]
        ]
    },
    {
        "id": "24990f7268258417",
        "type": "OPCUA-IIoT-Write",
        "z": "b8be3e0d96a62731",
        "connector": "e27138419046abbf",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1210,
        "y": 160,
        "wires": [
            [
                "fd2c6d9023f0c699",
                "785c6ec6a3246d96"
            ]
        ]
    },
    {
        "id": "785c6ec6a3246d96",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "write MSg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1460,
        "y": 60,
        "wires": []
    },
    {
        "id": "56ac6e830366368e",
        "type": "function",
        "z": "b8be3e0d96a62731",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=7\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 840,
        "wires": [
            [
                "ebcdd95b92a71803",
                "532fa43b1627dae7"
            ]
        ]
    },
    {
        "id": "676743537853b5ba",
        "type": "switch",
        "z": "b8be3e0d96a62731",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=7",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 820,
        "wires": [
            [],
            [
                "444af7984180a854"
            ],
            [],
            [
                "1d7c4f2063747454",
                "a921482810fe688e",
                "ed78e048b8d82b78"
            ],
            [
                "a921482810fe688e",
                "ed78e048b8d82b78"
            ],
            [
                "5f6e51085ee0d1a6"
            ],
            [],
            [
                "75a05fd9c6f6b109",
                "56ac6e830366368e"
            ],
            [
                "56ac6e830366368e"
            ]
        ],
        "outputLabels": [
            "drill_aktiv",
            "drill_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "fd2c6d9023f0c699",
        "type": "function",
        "z": "b8be3e0d96a62731",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1510,
        "y": 160,
        "wires": [
            [
                "2aba1a2726a18609",
                "30420fa86c4b5850"
            ]
        ]
    },
    {
        "id": "2aba1a2726a18609",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1790,
        "y": 240,
        "wires": []
    },
    {
        "id": "ed78e048b8d82b78",
        "type": "function",
        "z": "b8be3e0d96a62731",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 800,
        "wires": [
            [
                "ebcdd95b92a71803",
                "532fa43b1627dae7"
            ]
        ]
    },
    {
        "id": "ebcdd95b92a71803",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1780,
        "y": 740,
        "wires": []
    },
    {
        "id": "444af7984180a854",
        "type": "function",
        "z": "b8be3e0d96a62731",
        "name": "vda_status_finished DRILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 760,
        "wires": [
            [
                "ebcdd95b92a71803",
                "532fa43b1627dae7"
            ]
        ]
    },
    {
        "id": "5f6e51085ee0d1a6",
        "type": "change",
        "z": "b8be3e0d96a62731",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "75a05fd9c6f6b109",
        "type": "change",
        "z": "b8be3e0d96a62731",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 620,
        "wires": [
            [
                "38fe6c825c9c1183"
            ]
        ]
    },
    {
        "id": "1d7c4f2063747454",
        "type": "change",
        "z": "b8be3e0d96a62731",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1080,
        "y": 700,
        "wires": [
            [
                "38fe6c825c9c1183"
            ]
        ]
    },
    {
        "id": "379e1d26e9fcf794",
        "type": "function",
        "z": "b8be3e0d96a62731",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"DRILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"DRILL\");\nflow.set(\"errors\", []);\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.52\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "bf4b2e3a58dc1173",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 960,
        "wires": []
    },
    {
        "id": "64560c2164b815b7",
        "type": "function",
        "z": "b8be3e0d96a62731",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 240,
        "wires": [
            [
                "2aba1a2726a18609",
                "30420fa86c4b5850"
            ]
        ]
    },
    {
        "id": "b31d2647c6cbf7bd",
        "type": "OPCUA-IIoT-Browser",
        "z": "b8be3e0d96a62731",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "e27138419046abbf",
        "x": 400,
        "y": 820,
        "wires": [
            [
                "422466e46c1b0566",
                "63bb018274869de4",
                "ad9b177a869fa5af"
            ]
        ]
    },
    {
        "id": "271fa6a4700c2993",
        "type": "OPCUA-IIoT-Inject",
        "z": "b8be3e0d96a62731",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 820,
        "wires": [
            [
                "b31d2647c6cbf7bd"
            ]
        ]
    },
    {
        "id": "63bb018274869de4",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 660,
        "wires": []
    },
    {
        "id": "ad9b177a869fa5af",
        "type": "change",
        "z": "b8be3e0d96a62731",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "532fa43b1627dae7",
        "type": "link out",
        "z": "b8be3e0d96a62731",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1835,
        "y": 820,
        "wires": []
    },
    {
        "id": "9ebd312af89aeb06",
        "type": "subflow:1b897516f5bf21fa",
        "z": "b8be3e0d96a62731",
        "name": "",
        "x": 640,
        "y": 380,
        "wires": [
            [
                "233d521064eca746",
                "f8afbb1f7a372b0d"
            ],
            [
                "db8b202ffb6efdf3",
                "0255ee3eab45b809"
            ],
            [
                "30420fa86c4b5850"
            ],
            []
        ]
    },
    {
        "id": "30420fa86c4b5850",
        "type": "link out",
        "z": "b8be3e0d96a62731",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1825,
        "y": 460,
        "wires": []
    },
    {
        "id": "4415fe323564c542",
        "type": "subflow:6a25ecd632542087",
        "z": "b8be3e0d96a62731",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-drill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "379e1d26e9fcf794"
            ]
        ]
    },
    {
        "id": "c7bd55aa1e42731e",
        "type": "function",
        "z": "b8be3e0d96a62731",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 320,
        "wires": [
            [
                "178d83897bf822b7",
                "30420fa86c4b5850"
            ]
        ]
    },
    {
        "id": "178d83897bf822b7",
        "type": "function",
        "z": "b8be3e0d96a62731",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\nflow.set(\"errors\", {});\nflow.set(\"orderId\", 0);\nflow.set(\"orderUpdateId\", 0);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 320,
        "wires": [
            [
                "30420fa86c4b5850"
            ]
        ]
    },
    {
        "id": "db8b202ffb6efdf3",
        "type": "switch",
        "z": "b8be3e0d96a62731",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 930,
        "y": 320,
        "wires": [
            [
                "c7bd55aa1e42731e",
                "0255ee3eab45b809"
            ]
        ]
    },
    {
        "id": "71cb88517fa2eff4",
        "type": "catch",
        "z": "b8be3e0d96a62731",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "d58c80a31a076d89"
            ]
        ]
    },
    {
        "id": "d58c80a31a076d89",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "0255ee3eab45b809",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "supportedInstantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1200,
        "y": 380,
        "wires": []
    },
    {
        "id": "f8afbb1f7a372b0d",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "Debug-Order-Actions",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 220,
        "wires": []
    },
    {
        "id": "a921482810fe688e",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "drop-end-state",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1060,
        "y": 1080,
        "wires": []
    },
    {
        "id": "38fe6c825c9c1183",
        "type": "debug",
        "z": "b8be3e0d96a62731",
        "name": "state switch",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1410,
        "y": 1060,
        "wires": []
    },
    {
        "id": "45734d4376634a21",
        "type": "subflow:468f2460ce66f11e",
        "z": "b8be3e0d96a62731",
        "name": "",
        "x": 670,
        "y": 520,
        "wires": [
            [
                "30420fa86c4b5850"
            ]
        ]
    },
    {
        "id": "ab89b96f6e632c25",
        "type": "OPCUA-IIoT-Inject",
        "z": "b8be3e0d96a62731",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 520,
        "wires": [
            [
                "54181a65064c4050",
                "45734d4376634a21"
            ]
        ]
    },
    {
        "id": "54181a65064c4050",
        "type": "OPCUA-IIoT-Read",
        "z": "b8be3e0d96a62731",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "e27138419046abbf",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 480,
        "wires": [
            [
                "45734d4376634a21"
            ]
        ]
    },
    {
        "id": "e3b2f858c7049d74",
        "type": "OPCUA-IIoT-Inject",
        "z": "b8be3e0d96a62731",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=20",
                "datatypeName": "String"
            }
        ],
        "x": 150,
        "y": 380,
        "wires": [
            [
                "804eed4f016325c9"
            ]
        ]
    },
    {
        "id": "e7ee804d40fe0e11",
        "type": "OPCUA-IIoT-Listener",
        "z": "4cb2aa8b5e3c04ee",
        "connector": "05aa9778d001b499",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 820,
        "wires": [
            [
                "e0fa2a5cc1754834",
                "ee3cac4a3c1ad4eb"
            ]
        ]
    },
    {
        "id": "f1d5e95320601ab6",
        "type": "OPCUA-IIoT-Read",
        "z": "4cb2aa8b5e3c04ee",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "05aa9778d001b499",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 380,
        "wires": [
            [
                "7aeff1c3de92ece7"
            ]
        ]
    },
    {
        "id": "b31eede24df15d2e",
        "type": "function",
        "z": "4cb2aa8b5e3c04ee",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DRILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=10\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 240,
        "wires": [
            [
                "3ce1cdc6b9e74f96"
            ],
            [
                "6085316bf7c80e8c"
            ]
        ]
    },
    {
        "id": "3ce1cdc6b9e74f96",
        "type": "OPCUA-IIoT-Write",
        "z": "4cb2aa8b5e3c04ee",
        "connector": "05aa9778d001b499",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1210,
        "y": 160,
        "wires": [
            [
                "5d2f2a18c7b021d9",
                "eb411801320693e0"
            ]
        ]
    },
    {
        "id": "eb411801320693e0",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "write MSg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1460,
        "y": 60,
        "wires": []
    },
    {
        "id": "8271c97338c72b26",
        "type": "function",
        "z": "4cb2aa8b5e3c04ee",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=7\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 840,
        "wires": [
            [
                "93be9a8c5ef8aa6e",
                "66b35dc89f72837d"
            ]
        ]
    },
    {
        "id": "e0fa2a5cc1754834",
        "type": "switch",
        "z": "4cb2aa8b5e3c04ee",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=7",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 820,
        "wires": [
            [],
            [
                "bf2d39ee2413fa8c"
            ],
            [],
            [
                "22669cd41821096e",
                "80f42b6dd178ab3c",
                "137159f2029a1453"
            ],
            [
                "80f42b6dd178ab3c",
                "137159f2029a1453"
            ],
            [
                "ad23a7124b396cf1"
            ],
            [],
            [
                "9de86b31556d1316",
                "8271c97338c72b26"
            ],
            [
                "8271c97338c72b26"
            ]
        ],
        "outputLabels": [
            "drill_aktiv",
            "drill_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "5d2f2a18c7b021d9",
        "type": "function",
        "z": "4cb2aa8b5e3c04ee",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1510,
        "y": 160,
        "wires": [
            [
                "4270b21bca3acb3c",
                "3fb294540120f871"
            ]
        ]
    },
    {
        "id": "4270b21bca3acb3c",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1790,
        "y": 240,
        "wires": []
    },
    {
        "id": "137159f2029a1453",
        "type": "function",
        "z": "4cb2aa8b5e3c04ee",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 800,
        "wires": [
            [
                "93be9a8c5ef8aa6e",
                "66b35dc89f72837d"
            ]
        ]
    },
    {
        "id": "93be9a8c5ef8aa6e",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1780,
        "y": 740,
        "wires": []
    },
    {
        "id": "bf2d39ee2413fa8c",
        "type": "function",
        "z": "4cb2aa8b5e3c04ee",
        "name": "vda_status_finished DRILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 760,
        "wires": [
            [
                "93be9a8c5ef8aa6e",
                "66b35dc89f72837d"
            ]
        ]
    },
    {
        "id": "ad23a7124b396cf1",
        "type": "change",
        "z": "4cb2aa8b5e3c04ee",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "9de86b31556d1316",
        "type": "change",
        "z": "4cb2aa8b5e3c04ee",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 620,
        "wires": [
            [
                "e2c2e8571ac16b4c"
            ]
        ]
    },
    {
        "id": "22669cd41821096e",
        "type": "change",
        "z": "4cb2aa8b5e3c04ee",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1080,
        "y": 700,
        "wires": [
            [
                "e2c2e8571ac16b4c"
            ]
        ]
    },
    {
        "id": "60fc9507d72fd811",
        "type": "function",
        "z": "4cb2aa8b5e3c04ee",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"DRILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"DRILL\");\nflow.set(\"errors\", []);\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.53\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "ee3cac4a3c1ad4eb",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 960,
        "wires": []
    },
    {
        "id": "6085316bf7c80e8c",
        "type": "function",
        "z": "4cb2aa8b5e3c04ee",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 240,
        "wires": [
            [
                "4270b21bca3acb3c",
                "3fb294540120f871"
            ]
        ]
    },
    {
        "id": "2a886819f562df2e",
        "type": "OPCUA-IIoT-Browser",
        "z": "4cb2aa8b5e3c04ee",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "05aa9778d001b499",
        "x": 400,
        "y": 820,
        "wires": [
            [
                "e7ee804d40fe0e11",
                "49a3186c8a69b279",
                "3ea9496a69f80463"
            ]
        ]
    },
    {
        "id": "446e71f68e8e5731",
        "type": "OPCUA-IIoT-Inject",
        "z": "4cb2aa8b5e3c04ee",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 820,
        "wires": [
            [
                "2a886819f562df2e"
            ]
        ]
    },
    {
        "id": "49a3186c8a69b279",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 660,
        "wires": []
    },
    {
        "id": "3ea9496a69f80463",
        "type": "change",
        "z": "4cb2aa8b5e3c04ee",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "66b35dc89f72837d",
        "type": "link out",
        "z": "4cb2aa8b5e3c04ee",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1835,
        "y": 820,
        "wires": []
    },
    {
        "id": "7aeff1c3de92ece7",
        "type": "subflow:1b897516f5bf21fa",
        "z": "4cb2aa8b5e3c04ee",
        "name": "",
        "x": 640,
        "y": 380,
        "wires": [
            [
                "b31eede24df15d2e",
                "92b9f4f55a9281ae"
            ],
            [
                "757a515ac48bbe9e",
                "147e0e6084c8a8eb"
            ],
            [
                "3fb294540120f871"
            ],
            []
        ]
    },
    {
        "id": "3fb294540120f871",
        "type": "link out",
        "z": "4cb2aa8b5e3c04ee",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1825,
        "y": 460,
        "wires": []
    },
    {
        "id": "902ede0fd6f308d2",
        "type": "subflow:6a25ecd632542087",
        "z": "4cb2aa8b5e3c04ee",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-drill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "60fc9507d72fd811"
            ]
        ]
    },
    {
        "id": "4de80e8090fe4a7c",
        "type": "function",
        "z": "4cb2aa8b5e3c04ee",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 320,
        "wires": [
            [
                "a1b5c0f423a25e42",
                "3fb294540120f871"
            ]
        ]
    },
    {
        "id": "a1b5c0f423a25e42",
        "type": "function",
        "z": "4cb2aa8b5e3c04ee",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\nflow.set(\"errors\", {});\nflow.set(\"orderId\", 0);\nflow.set(\"orderUpdateId\", 0);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 320,
        "wires": [
            [
                "3fb294540120f871"
            ]
        ]
    },
    {
        "id": "757a515ac48bbe9e",
        "type": "switch",
        "z": "4cb2aa8b5e3c04ee",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 930,
        "y": 320,
        "wires": [
            [
                "4de80e8090fe4a7c",
                "147e0e6084c8a8eb"
            ]
        ]
    },
    {
        "id": "28cb3b02f42b3e71",
        "type": "catch",
        "z": "4cb2aa8b5e3c04ee",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "99495a245b3189fb"
            ]
        ]
    },
    {
        "id": "99495a245b3189fb",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "147e0e6084c8a8eb",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "supportedInstantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1200,
        "y": 380,
        "wires": []
    },
    {
        "id": "92b9f4f55a9281ae",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "Debug-Order-Actions",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 220,
        "wires": []
    },
    {
        "id": "80f42b6dd178ab3c",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "drop-end-state",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1060,
        "y": 1080,
        "wires": []
    },
    {
        "id": "e2c2e8571ac16b4c",
        "type": "debug",
        "z": "4cb2aa8b5e3c04ee",
        "name": "state switch",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1410,
        "y": 1060,
        "wires": []
    },
    {
        "id": "99359db4b0ae2864",
        "type": "subflow:468f2460ce66f11e",
        "z": "4cb2aa8b5e3c04ee",
        "name": "",
        "x": 670,
        "y": 500,
        "wires": [
            [
                "3fb294540120f871"
            ]
        ]
    },
    {
        "id": "3f0712eb3ddcfefe",
        "type": "OPCUA-IIoT-Inject",
        "z": "4cb2aa8b5e3c04ee",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 500,
        "wires": [
            [
                "9a94a9482550bfd1",
                "99359db4b0ae2864"
            ]
        ]
    },
    {
        "id": "9a94a9482550bfd1",
        "type": "OPCUA-IIoT-Read",
        "z": "4cb2aa8b5e3c04ee",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "05aa9778d001b499",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 460,
        "wires": [
            [
                "99359db4b0ae2864"
            ]
        ]
    },
    {
        "id": "3335e07270b43f25",
        "type": "OPCUA-IIoT-Inject",
        "z": "4cb2aa8b5e3c04ee",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=20",
                "datatypeName": "String"
            }
        ],
        "x": 150,
        "y": 380,
        "wires": [
            [
                "f1d5e95320601ab6"
            ]
        ]
    },
    {
        "id": "c4a07041633366f3",
        "type": "OPCUA-IIoT-Listener",
        "z": "490d04c5383c1492",
        "connector": "86523aff067d7a39",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 820,
        "wires": [
            [
                "c7583c3541159422",
                "5c55b466b6f75e48"
            ]
        ]
    },
    {
        "id": "5011dec71084f6af",
        "type": "OPCUA-IIoT-Read",
        "z": "490d04c5383c1492",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "86523aff067d7a39",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 380,
        "wires": [
            [
                "3133ba874c353f65"
            ]
        ]
    },
    {
        "id": "48065cf31b935e2c",
        "type": "function",
        "z": "490d04c5383c1492",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_MILL\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DRILL\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"MILLBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=10\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            flow.set(\"errors\", [...errors, error]);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        flow.set(\"errors\", [...errors, error]);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    flow.set(\"errors\", [...errors, error]);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 240,
        "wires": [
            [
                "fedbcfc241eba7ca"
            ],
            [
                "eded32227bde015f"
            ]
        ]
    },
    {
        "id": "fedbcfc241eba7ca",
        "type": "OPCUA-IIoT-Write",
        "z": "490d04c5383c1492",
        "connector": "86523aff067d7a39",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1210,
        "y": 160,
        "wires": [
            [
                "b3e626285aa542e2",
                "b5a1a4a413757da8"
            ]
        ]
    },
    {
        "id": "b5a1a4a413757da8",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "write MSg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1460,
        "y": 60,
        "wires": []
    },
    {
        "id": "eec52496d8866e91",
        "type": "function",
        "z": "490d04c5383c1492",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=7\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 840,
        "wires": [
            [
                "e11f5828b9862f84",
                "82c199ad9dcfe4cc"
            ]
        ]
    },
    {
        "id": "c7583c3541159422",
        "type": "switch",
        "z": "490d04c5383c1492",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=7",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 820,
        "wires": [
            [],
            [
                "d355fc4ff71f8ef7"
            ],
            [],
            [
                "f88ec345b005123f",
                "513d0ea7614e88aa",
                "28c4b9679402e1d4"
            ],
            [
                "513d0ea7614e88aa",
                "28c4b9679402e1d4"
            ],
            [
                "29e542c0e0c3b2a3"
            ],
            [],
            [
                "8b2cad7e5f9b6d98",
                "eec52496d8866e91"
            ],
            [
                "eec52496d8866e91"
            ]
        ],
        "outputLabels": [
            "drill_aktiv",
            "drill_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "b3e626285aa542e2",
        "type": "function",
        "z": "490d04c5383c1492",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1510,
        "y": 160,
        "wires": [
            [
                "40c75a961acf23ed",
                "f0986aa47fc51448"
            ]
        ]
    },
    {
        "id": "40c75a961acf23ed",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1790,
        "y": 240,
        "wires": []
    },
    {
        "id": "28c4b9679402e1d4",
        "type": "function",
        "z": "490d04c5383c1492",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n        flow.set(\"errors\", errors);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = flow.get(\"errors\") ? flow.get(\"errors\") : [];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 800,
        "wires": [
            [
                "e11f5828b9862f84",
                "82c199ad9dcfe4cc"
            ]
        ]
    },
    {
        "id": "e11f5828b9862f84",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1780,
        "y": 740,
        "wires": []
    },
    {
        "id": "d355fc4ff71f8ef7",
        "type": "function",
        "z": "490d04c5383c1492",
        "name": "vda_status_finished DRILL",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"MILLBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_MILL\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 760,
        "wires": [
            [
                "e11f5828b9862f84",
                "82c199ad9dcfe4cc"
            ]
        ]
    },
    {
        "id": "29e542c0e0c3b2a3",
        "type": "change",
        "z": "490d04c5383c1492",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "8b2cad7e5f9b6d98",
        "type": "change",
        "z": "490d04c5383c1492",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1070,
        "y": 620,
        "wires": [
            [
                "48820e9474be234d"
            ]
        ]
    },
    {
        "id": "f88ec345b005123f",
        "type": "change",
        "z": "490d04c5383c1492",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1080,
        "y": 700,
        "wires": [
            [
                "48820e9474be234d"
            ]
        ]
    },
    {
        "id": "c1b29e68fa38b77c",
        "type": "function",
        "z": "490d04c5383c1492",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"DRILL\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"DRILL\");\nflow.set(\"errors\", []);\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.54\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "5c55b466b6f75e48",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 960,
        "wires": []
    },
    {
        "id": "eded32227bde015f",
        "type": "function",
        "z": "490d04c5383c1492",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 240,
        "wires": [
            [
                "40c75a961acf23ed",
                "f0986aa47fc51448"
            ]
        ]
    },
    {
        "id": "1e1d8199fd32127f",
        "type": "OPCUA-IIoT-Browser",
        "z": "490d04c5383c1492",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "86523aff067d7a39",
        "x": 400,
        "y": 820,
        "wires": [
            [
                "c4a07041633366f3",
                "84bcbfafe64f18d6",
                "b4277eda2ccaa068"
            ]
        ]
    },
    {
        "id": "94b4dd70cfc0a917",
        "type": "OPCUA-IIoT-Inject",
        "z": "490d04c5383c1492",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 150,
        "y": 820,
        "wires": [
            [
                "1e1d8199fd32127f"
            ]
        ]
    },
    {
        "id": "84bcbfafe64f18d6",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 660,
        "wires": []
    },
    {
        "id": "b4277eda2ccaa068",
        "type": "change",
        "z": "490d04c5383c1492",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "82c199ad9dcfe4cc",
        "type": "link out",
        "z": "490d04c5383c1492",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1835,
        "y": 820,
        "wires": []
    },
    {
        "id": "3133ba874c353f65",
        "type": "subflow:1b897516f5bf21fa",
        "z": "490d04c5383c1492",
        "name": "",
        "x": 640,
        "y": 380,
        "wires": [
            [
                "48065cf31b935e2c",
                "3b85f4d521412277"
            ],
            [
                "3d5c9d42fdf760fa",
                "0fadd5f905f09d0a"
            ],
            [
                "f0986aa47fc51448"
            ],
            []
        ]
    },
    {
        "id": "f0986aa47fc51448",
        "type": "link out",
        "z": "490d04c5383c1492",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1825,
        "y": 460,
        "wires": []
    },
    {
        "id": "785acae0019b74c2",
        "type": "subflow:6a25ecd632542087",
        "z": "490d04c5383c1492",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-drill.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "c1b29e68fa38b77c"
            ]
        ]
    },
    {
        "id": "3bb3e4f5b5244de7",
        "type": "function",
        "z": "490d04c5383c1492",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 320,
        "wires": [
            [
                "1b983b1a311d91fd",
                "f0986aa47fc51448"
            ]
        ]
    },
    {
        "id": "1b983b1a311d91fd",
        "type": "function",
        "z": "490d04c5383c1492",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\nflow.set(\"errors\", {});\nflow.set(\"orderId\", 0);\nflow.set(\"orderUpdateId\", 0);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1500,
        "y": 320,
        "wires": [
            [
                "f0986aa47fc51448"
            ]
        ]
    },
    {
        "id": "3d5c9d42fdf760fa",
        "type": "switch",
        "z": "490d04c5383c1492",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 930,
        "y": 320,
        "wires": [
            [
                "3bb3e4f5b5244de7",
                "0fadd5f905f09d0a"
            ]
        ]
    },
    {
        "id": "58fe19f36ce1b732",
        "type": "catch",
        "z": "490d04c5383c1492",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "4aeb98e263d7a28c"
            ]
        ]
    },
    {
        "id": "4aeb98e263d7a28c",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "0fadd5f905f09d0a",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "supportedInstantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1200,
        "y": 380,
        "wires": []
    },
    {
        "id": "3b85f4d521412277",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "Debug-Order-Actions",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 680,
        "y": 220,
        "wires": []
    },
    {
        "id": "513d0ea7614e88aa",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "drop-end-state",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1060,
        "y": 1080,
        "wires": []
    },
    {
        "id": "48820e9474be234d",
        "type": "debug",
        "z": "490d04c5383c1492",
        "name": "state switch",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1410,
        "y": 1060,
        "wires": []
    },
    {
        "id": "3e826eb93d0d1dbf",
        "type": "subflow:468f2460ce66f11e",
        "z": "490d04c5383c1492",
        "name": "",
        "x": 670,
        "y": 520,
        "wires": [
            [
                "f0986aa47fc51448"
            ]
        ]
    },
    {
        "id": "7701aed2d0b1a5e8",
        "type": "OPCUA-IIoT-Inject",
        "z": "490d04c5383c1492",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 160,
        "y": 520,
        "wires": [
            [
                "95ccd3ed52477bb8",
                "3e826eb93d0d1dbf"
            ]
        ]
    },
    {
        "id": "95ccd3ed52477bb8",
        "type": "OPCUA-IIoT-Read",
        "z": "490d04c5383c1492",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "86523aff067d7a39",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 410,
        "y": 480,
        "wires": [
            [
                "3e826eb93d0d1dbf"
            ]
        ]
    },
    {
        "id": "dccdab56c1921e12",
        "type": "OPCUA-IIoT-Inject",
        "z": "490d04c5383c1492",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=20",
                "datatypeName": "String"
            }
        ],
        "x": 150,
        "y": 380,
        "wires": [
            [
                "5011dec71084f6af"
            ]
        ]
    },
    {
        "id": "a314f5e008b87c38",
        "type": "OPCUA-IIoT-Listener",
        "z": "2edb0a9a7b9b6718",
        "connector": "fdbb80558db436be",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 620,
        "wires": [
            [
                "92cf904819290527",
                "0a91a05b1496a96b"
            ]
        ]
    },
    {
        "id": "92cf904819290527",
        "type": "switch",
        "z": "2edb0a9a7b9b6718",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=18",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 660,
        "wires": [
            [],
            [
                "3912e2baba48cca8",
                "2c7d277138a53860"
            ],
            [
                "2c7d277138a53860"
            ],
            [],
            [
                "9bc3946811a65244"
            ],
            [
                "f954a72b94a63c8b"
            ],
            [],
            [
                "4684941dc1f8bb64",
                "1072e58c55835df2"
            ],
            [
                "1072e58c55835df2"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fire_aktiv",
            "fire_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "0a91a05b1496a96b",
        "type": "debug",
        "z": "2edb0a9a7b9b6718",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 780,
        "wires": []
    },
    {
        "id": "f954a72b94a63c8b",
        "type": "change",
        "z": "2edb0a9a7b9b6718",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1210,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "9bc3946811a65244",
        "type": "function",
        "z": "2edb0a9a7b9b6718",
        "name": "vda_status_finished FIRE",
        "func": "const nodeValue = msg.payload.value.value.value;\nif (nodeValue == true && flow.get(\"moduleState\") == \"FIREBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_FIRE\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 760,
        "wires": [
            [
                "65590faa4a19f381",
                "2835d8a03c6efb13"
            ]
        ]
    },
    {
        "id": "4684941dc1f8bb64",
        "type": "change",
        "z": "2edb0a9a7b9b6718",
        "name": "OPCUA state pick_failed",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 520,
        "wires": [
            [
                "3d4679d95b9da121"
            ]
        ]
    },
    {
        "id": "3912e2baba48cca8",
        "type": "change",
        "z": "2edb0a9a7b9b6718",
        "name": "OPCUA state drop_failed",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 560,
        "wires": [
            [
                "3d4679d95b9da121"
            ]
        ]
    },
    {
        "id": "1072e58c55835df2",
        "type": "function",
        "z": "2edb0a9a7b9b6718",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"errors\", []);\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 680,
        "wires": [
            [
                "65590faa4a19f381",
                "2835d8a03c6efb13"
            ]
        ]
    },
    {
        "id": "2c7d277138a53860",
        "type": "function",
        "z": "2edb0a9a7b9b6718",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 720,
        "wires": [
            [
                "65590faa4a19f381",
                "2835d8a03c6efb13"
            ]
        ]
    },
    {
        "id": "65590faa4a19f381",
        "type": "debug",
        "z": "2edb0a9a7b9b6718",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1800,
        "y": 520,
        "wires": []
    },
    {
        "id": "d9fc32a9c5f264a4",
        "type": "function",
        "z": "2edb0a9a7b9b6718",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"OVEN\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", 0);\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"OVEN\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.60\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "38dfa9d897629499",
        "type": "OPCUA-IIoT-Browser",
        "z": "2edb0a9a7b9b6718",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "fdbb80558db436be",
        "x": 380,
        "y": 620,
        "wires": [
            [
                "a314f5e008b87c38",
                "a3fe231f1000e7c5",
                "a11e1185e47d717b"
            ]
        ]
    },
    {
        "id": "623c9a4aab15dc6c",
        "type": "OPCUA-IIoT-Inject",
        "z": "2edb0a9a7b9b6718",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 130,
        "y": 620,
        "wires": [
            [
                "38dfa9d897629499"
            ]
        ]
    },
    {
        "id": "a3fe231f1000e7c5",
        "type": "debug",
        "z": "2edb0a9a7b9b6718",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 520,
        "wires": []
    },
    {
        "id": "a11e1185e47d717b",
        "type": "change",
        "z": "2edb0a9a7b9b6718",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "2835d8a03c6efb13",
        "type": "link out",
        "z": "2edb0a9a7b9b6718",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1895,
        "y": 660,
        "wires": []
    },
    {
        "id": "197d69d8da358621",
        "type": "subflow:6a25ecd632542087",
        "z": "2edb0a9a7b9b6718",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-oven.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "d9fc32a9c5f264a4"
            ]
        ]
    },
    {
        "id": "421ba6ab9d4d9491",
        "type": "OPCUA-IIoT-Inject",
        "z": "2edb0a9a7b9b6718",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=19",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 300,
        "wires": [
            [
                "67a571430df6d84c"
            ]
        ]
    },
    {
        "id": "67a571430df6d84c",
        "type": "OPCUA-IIoT-Read",
        "z": "2edb0a9a7b9b6718",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "fdbb80558db436be",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 300,
        "wires": [
            [
                "56804a55e82f8a48"
            ]
        ]
    },
    {
        "id": "9e2226f47adab054",
        "type": "function",
        "z": "2edb0a9a7b9b6718",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_FIRE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"FIRE\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"FIREBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration}];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            errors.push(error);\n            flow.set(\"errors\", errors);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg,null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    errors.push(error);\n    flow.set(\"errors\", errors);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 200,
        "wires": [
            [
                "a9563b9579cb2834",
                "513befbfce075a19"
            ],
            [
                "af2a9a076af2ae4c"
            ]
        ]
    },
    {
        "id": "af2a9a076af2ae4c",
        "type": "function",
        "z": "2edb0a9a7b9b6718",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 220,
        "wires": [
            [
                "6dbd6e64611f420a",
                "c39a247a735925aa"
            ]
        ]
    },
    {
        "id": "a9563b9579cb2834",
        "type": "OPCUA-IIoT-Write",
        "z": "2edb0a9a7b9b6718",
        "connector": "fdbb80558db436be",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1350,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "6dbd6e64611f420a",
        "type": "debug",
        "z": "2edb0a9a7b9b6718",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1830,
        "y": 180,
        "wires": []
    },
    {
        "id": "513befbfce075a19",
        "type": "function",
        "z": "2edb0a9a7b9b6718",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet flowErrors = flow.get(\"errors\") ?? [];\nlet errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nstate.errors = errors;\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 180,
        "wires": [
            [
                "6dbd6e64611f420a",
                "c39a247a735925aa"
            ]
        ]
    },
    {
        "id": "56804a55e82f8a48",
        "type": "subflow:1b897516f5bf21fa",
        "z": "2edb0a9a7b9b6718",
        "name": "",
        "x": 720,
        "y": 300,
        "wires": [
            [
                "9e2226f47adab054"
            ],
            [
                "b024fcb65f9764fc",
                "ab4ba02b9a6b09e5"
            ],
            [
                "c39a247a735925aa"
            ],
            []
        ]
    },
    {
        "id": "6516addd180e5e59",
        "type": "function",
        "z": "2edb0a9a7b9b6718",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 280,
        "wires": [
            [
                "f777926eb0e1d348",
                "c39a247a735925aa"
            ]
        ]
    },
    {
        "id": "f777926eb0e1d348",
        "type": "function",
        "z": "2edb0a9a7b9b6718",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 280,
        "wires": [
            [
                "c39a247a735925aa"
            ]
        ]
    },
    {
        "id": "b024fcb65f9764fc",
        "type": "switch",
        "z": "2edb0a9a7b9b6718",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1010,
        "y": 280,
        "wires": [
            [
                "6516addd180e5e59",
                "ab4ba02b9a6b09e5"
            ]
        ]
    },
    {
        "id": "c39a247a735925aa",
        "type": "link out",
        "z": "2edb0a9a7b9b6718",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1905,
        "y": 320,
        "wires": []
    },
    {
        "id": "14482e35b83d03ce",
        "type": "catch",
        "z": "2edb0a9a7b9b6718",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "557cc0db5292f013"
            ]
        ]
    },
    {
        "id": "557cc0db5292f013",
        "type": "debug",
        "z": "2edb0a9a7b9b6718",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "ab4ba02b9a6b09e5",
        "type": "debug",
        "z": "2edb0a9a7b9b6718",
        "name": "instantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 340,
        "wires": []
    },
    {
        "id": "3d4679d95b9da121",
        "type": "debug",
        "z": "2edb0a9a7b9b6718",
        "name": "failed output",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1510,
        "y": 540,
        "wires": []
    },
    {
        "id": "50fdeaf18fdf20ab",
        "type": "subflow:468f2460ce66f11e",
        "z": "2edb0a9a7b9b6718",
        "name": "",
        "x": 750,
        "y": 420,
        "wires": [
            [
                "c39a247a735925aa"
            ]
        ]
    },
    {
        "id": "6639fb27b9197833",
        "type": "OPCUA-IIoT-Inject",
        "z": "2edb0a9a7b9b6718",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 420,
        "wires": [
            [
                "8dac36e2aea321c3",
                "50fdeaf18fdf20ab"
            ]
        ]
    },
    {
        "id": "8dac36e2aea321c3",
        "type": "OPCUA-IIoT-Read",
        "z": "2edb0a9a7b9b6718",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "fdbb80558db436be",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 450,
        "y": 380,
        "wires": [
            [
                "50fdeaf18fdf20ab"
            ]
        ]
    },
    {
        "id": "41d13623d61507bc",
        "type": "OPCUA-IIoT-Listener",
        "z": "306206362e6386f0",
        "connector": "3f264405b1bd9be7",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 620,
        "wires": [
            [
                "b38d04f21585ad03",
                "d4adccc13ec798f5"
            ]
        ]
    },
    {
        "id": "b38d04f21585ad03",
        "type": "switch",
        "z": "306206362e6386f0",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=18",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 660,
        "wires": [
            [],
            [
                "4bb8ed0daefd8143",
                "eec569a469daf4da"
            ],
            [
                "eec569a469daf4da"
            ],
            [],
            [
                "aae70e20b7d1b85d"
            ],
            [
                "22a0d425b6d612f4"
            ],
            [],
            [
                "d2189a71d829b5c4",
                "3622456a255b6441"
            ],
            [
                "3622456a255b6441"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fire_aktiv",
            "fire_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "d4adccc13ec798f5",
        "type": "debug",
        "z": "306206362e6386f0",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 780,
        "wires": []
    },
    {
        "id": "22a0d425b6d612f4",
        "type": "change",
        "z": "306206362e6386f0",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1210,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "aae70e20b7d1b85d",
        "type": "function",
        "z": "306206362e6386f0",
        "name": "vda_status_finished FIRE",
        "func": "const nodeValue = msg.payload.value.value.value;\nif (nodeValue == true && flow.get(\"moduleState\") == \"FIREBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_FIRE\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 760,
        "wires": [
            [
                "5f55e56a7c63d7b2",
                "e92579999097f440"
            ]
        ]
    },
    {
        "id": "d2189a71d829b5c4",
        "type": "change",
        "z": "306206362e6386f0",
        "name": "OPCUA state pick_failed",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 520,
        "wires": [
            [
                "5e7a97f33282b7c1"
            ]
        ]
    },
    {
        "id": "4bb8ed0daefd8143",
        "type": "change",
        "z": "306206362e6386f0",
        "name": "OPCUA state drop_failed",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 560,
        "wires": [
            [
                "5e7a97f33282b7c1"
            ]
        ]
    },
    {
        "id": "3622456a255b6441",
        "type": "function",
        "z": "306206362e6386f0",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"errors\", []);\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 680,
        "wires": [
            [
                "5f55e56a7c63d7b2",
                "e92579999097f440"
            ]
        ]
    },
    {
        "id": "eec569a469daf4da",
        "type": "function",
        "z": "306206362e6386f0",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 720,
        "wires": [
            [
                "5f55e56a7c63d7b2",
                "e92579999097f440"
            ]
        ]
    },
    {
        "id": "5f55e56a7c63d7b2",
        "type": "debug",
        "z": "306206362e6386f0",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1800,
        "y": 520,
        "wires": []
    },
    {
        "id": "d1902f6947b8b3aa",
        "type": "function",
        "z": "306206362e6386f0",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"OVEN\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", 0);\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"OVEN\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.61\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "1630822bb1e4560b",
        "type": "OPCUA-IIoT-Browser",
        "z": "306206362e6386f0",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "3f264405b1bd9be7",
        "x": 380,
        "y": 620,
        "wires": [
            [
                "41d13623d61507bc",
                "2849b137e6a874e9",
                "49251f9f776247bd"
            ]
        ]
    },
    {
        "id": "866c9ab2ffbf9ec7",
        "type": "OPCUA-IIoT-Inject",
        "z": "306206362e6386f0",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 130,
        "y": 620,
        "wires": [
            [
                "1630822bb1e4560b"
            ]
        ]
    },
    {
        "id": "2849b137e6a874e9",
        "type": "debug",
        "z": "306206362e6386f0",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 520,
        "wires": []
    },
    {
        "id": "49251f9f776247bd",
        "type": "change",
        "z": "306206362e6386f0",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "e92579999097f440",
        "type": "link out",
        "z": "306206362e6386f0",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1895,
        "y": 660,
        "wires": []
    },
    {
        "id": "3e1ae146d41ae366",
        "type": "subflow:6a25ecd632542087",
        "z": "306206362e6386f0",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-oven.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "d1902f6947b8b3aa"
            ]
        ]
    },
    {
        "id": "282922f0bff97926",
        "type": "OPCUA-IIoT-Read",
        "z": "306206362e6386f0",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "3f264405b1bd9be7",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 300,
        "wires": [
            [
                "22cde6d5cab682b6"
            ]
        ]
    },
    {
        "id": "219301d237151c28",
        "type": "function",
        "z": "306206362e6386f0",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_FIRE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"FIRE\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"FIREBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            errors.push(error);\n            flow.set(\"errors\", errors);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    errors.push(error);\n    flow.set(\"errors\", errors);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 200,
        "wires": [
            [
                "7ea1c681f06a85f8",
                "653f0d0373876dfa"
            ],
            [
                "5917f396108c7e36"
            ]
        ]
    },
    {
        "id": "5917f396108c7e36",
        "type": "function",
        "z": "306206362e6386f0",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 220,
        "wires": [
            [
                "94b14a153516571a",
                "c208df477b440c19"
            ]
        ]
    },
    {
        "id": "7ea1c681f06a85f8",
        "type": "OPCUA-IIoT-Write",
        "z": "306206362e6386f0",
        "connector": "3f264405b1bd9be7",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1350,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "94b14a153516571a",
        "type": "debug",
        "z": "306206362e6386f0",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1830,
        "y": 180,
        "wires": []
    },
    {
        "id": "653f0d0373876dfa",
        "type": "function",
        "z": "306206362e6386f0",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet flowErrors = flow.get(\"errors\") ?? [];\nlet errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nstate.errors = errors;\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 180,
        "wires": [
            [
                "94b14a153516571a",
                "c208df477b440c19"
            ]
        ]
    },
    {
        "id": "22cde6d5cab682b6",
        "type": "subflow:1b897516f5bf21fa",
        "z": "306206362e6386f0",
        "name": "",
        "x": 720,
        "y": 300,
        "wires": [
            [
                "219301d237151c28"
            ],
            [
                "248f70b173dec23d",
                "1b2e1fff230db5e8"
            ],
            [
                "c208df477b440c19"
            ],
            []
        ]
    },
    {
        "id": "b45b570f355ce647",
        "type": "function",
        "z": "306206362e6386f0",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 280,
        "wires": [
            [
                "aa5f487508da89c9",
                "c208df477b440c19"
            ]
        ]
    },
    {
        "id": "aa5f487508da89c9",
        "type": "function",
        "z": "306206362e6386f0",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 280,
        "wires": [
            [
                "c208df477b440c19"
            ]
        ]
    },
    {
        "id": "248f70b173dec23d",
        "type": "switch",
        "z": "306206362e6386f0",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1010,
        "y": 280,
        "wires": [
            [
                "b45b570f355ce647",
                "1b2e1fff230db5e8"
            ]
        ]
    },
    {
        "id": "c208df477b440c19",
        "type": "link out",
        "z": "306206362e6386f0",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1905,
        "y": 320,
        "wires": []
    },
    {
        "id": "768dcead94e7c711",
        "type": "catch",
        "z": "306206362e6386f0",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "89ce35ff7b306bd6"
            ]
        ]
    },
    {
        "id": "89ce35ff7b306bd6",
        "type": "debug",
        "z": "306206362e6386f0",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "1b2e1fff230db5e8",
        "type": "debug",
        "z": "306206362e6386f0",
        "name": "instantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 340,
        "wires": []
    },
    {
        "id": "5e7a97f33282b7c1",
        "type": "debug",
        "z": "306206362e6386f0",
        "name": "failed output",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1510,
        "y": 540,
        "wires": []
    },
    {
        "id": "4a6dcc3ec94b45c5",
        "type": "subflow:468f2460ce66f11e",
        "z": "306206362e6386f0",
        "name": "",
        "x": 750,
        "y": 420,
        "wires": [
            [
                "c208df477b440c19"
            ]
        ]
    },
    {
        "id": "3d8050904dbdc00e",
        "type": "OPCUA-IIoT-Read",
        "z": "306206362e6386f0",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "3f264405b1bd9be7",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 450,
        "y": 380,
        "wires": [
            [
                "4a6dcc3ec94b45c5"
            ]
        ]
    },
    {
        "id": "20028dc458b4adcd",
        "type": "OPCUA-IIoT-Inject",
        "z": "306206362e6386f0",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=19",
                "datatypeName": "String"
            }
        ],
        "x": 190,
        "y": 300,
        "wires": [
            [
                "282922f0bff97926"
            ]
        ]
    },
    {
        "id": "b93dc857d8a877e8",
        "type": "OPCUA-IIoT-Inject",
        "z": "306206362e6386f0",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 200,
        "y": 420,
        "wires": [
            [
                "3d8050904dbdc00e",
                "4a6dcc3ec94b45c5"
            ]
        ]
    },
    {
        "id": "92a103c7ef9706a5",
        "type": "OPCUA-IIoT-Listener",
        "z": "38289fd68fd11ff8",
        "connector": "fc2df9e2fa177319",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 620,
        "wires": [
            [
                "1dfdab15de45013d",
                "ab42625063a5345a"
            ]
        ]
    },
    {
        "id": "1dfdab15de45013d",
        "type": "switch",
        "z": "38289fd68fd11ff8",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=18",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 660,
        "wires": [
            [],
            [
                "36816dd2f1c247c5",
                "66f50d23b9f554fe"
            ],
            [
                "66f50d23b9f554fe"
            ],
            [],
            [
                "bdc119a01bd8f397"
            ],
            [
                "2b3ab0e273941d0d"
            ],
            [],
            [
                "3c462b52d573ddf9",
                "ebf155fab06e2d95"
            ],
            [
                "ebf155fab06e2d95"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fire_aktiv",
            "fire_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "ab42625063a5345a",
        "type": "debug",
        "z": "38289fd68fd11ff8",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 780,
        "wires": []
    },
    {
        "id": "2b3ab0e273941d0d",
        "type": "change",
        "z": "38289fd68fd11ff8",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1210,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "bdc119a01bd8f397",
        "type": "function",
        "z": "38289fd68fd11ff8",
        "name": "vda_status_finished FIRE",
        "func": "const nodeValue = msg.payload.value.value.value;\nif (nodeValue == true && flow.get(\"moduleState\") == \"FIREBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_FIRE\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 760,
        "wires": [
            [
                "2211b0f133e3d8c8",
                "f9fe92b89535e85f"
            ]
        ]
    },
    {
        "id": "3c462b52d573ddf9",
        "type": "change",
        "z": "38289fd68fd11ff8",
        "name": "OPCUA state pick_failed",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 520,
        "wires": [
            [
                "eaa3b4522f626c80"
            ]
        ]
    },
    {
        "id": "36816dd2f1c247c5",
        "type": "change",
        "z": "38289fd68fd11ff8",
        "name": "OPCUA state drop_failed",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 560,
        "wires": [
            [
                "eaa3b4522f626c80"
            ]
        ]
    },
    {
        "id": "ebf155fab06e2d95",
        "type": "function",
        "z": "38289fd68fd11ff8",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"errors\", []);\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 680,
        "wires": [
            [
                "2211b0f133e3d8c8",
                "f9fe92b89535e85f"
            ]
        ]
    },
    {
        "id": "66f50d23b9f554fe",
        "type": "function",
        "z": "38289fd68fd11ff8",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 720,
        "wires": [
            [
                "2211b0f133e3d8c8",
                "f9fe92b89535e85f"
            ]
        ]
    },
    {
        "id": "2211b0f133e3d8c8",
        "type": "debug",
        "z": "38289fd68fd11ff8",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1800,
        "y": 520,
        "wires": []
    },
    {
        "id": "90e2e06b2b8abb29",
        "type": "function",
        "z": "38289fd68fd11ff8",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"OVEN\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", 0);\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"OVEN\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.62\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "a6be2544cf23037b",
        "type": "OPCUA-IIoT-Browser",
        "z": "38289fd68fd11ff8",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "fc2df9e2fa177319",
        "x": 380,
        "y": 620,
        "wires": [
            [
                "92a103c7ef9706a5",
                "49f96a19dc3c8d59",
                "878947293324086b"
            ]
        ]
    },
    {
        "id": "666c20f5ab511623",
        "type": "OPCUA-IIoT-Inject",
        "z": "38289fd68fd11ff8",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 130,
        "y": 620,
        "wires": [
            [
                "a6be2544cf23037b"
            ]
        ]
    },
    {
        "id": "49f96a19dc3c8d59",
        "type": "debug",
        "z": "38289fd68fd11ff8",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 520,
        "wires": []
    },
    {
        "id": "878947293324086b",
        "type": "change",
        "z": "38289fd68fd11ff8",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "f9fe92b89535e85f",
        "type": "link out",
        "z": "38289fd68fd11ff8",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1895,
        "y": 660,
        "wires": []
    },
    {
        "id": "dd4c06a3a5caa5c7",
        "type": "subflow:6a25ecd632542087",
        "z": "38289fd68fd11ff8",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-oven.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "90e2e06b2b8abb29"
            ]
        ]
    },
    {
        "id": "ce7349c74d8bf917",
        "type": "OPCUA-IIoT-Read",
        "z": "38289fd68fd11ff8",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "fc2df9e2fa177319",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 300,
        "wires": [
            [
                "4e7e256e2d4e6b5f"
            ]
        ]
    },
    {
        "id": "971606b1692401fb",
        "type": "function",
        "z": "38289fd68fd11ff8",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_FIRE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"FIRE\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"FIREBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            errors.push(error);\n            flow.set(\"errors\", errors);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    errors.push(error);\n    flow.set(\"errors\", errors);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 200,
        "wires": [
            [
                "74be869be86f8124",
                "8bc8fb55188f0cff"
            ],
            [
                "de5fca49db29fe89"
            ]
        ]
    },
    {
        "id": "de5fca49db29fe89",
        "type": "function",
        "z": "38289fd68fd11ff8",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 220,
        "wires": [
            [
                "f977a68d6b206998",
                "3c2237769c19c0a0"
            ]
        ]
    },
    {
        "id": "74be869be86f8124",
        "type": "OPCUA-IIoT-Write",
        "z": "38289fd68fd11ff8",
        "connector": "fc2df9e2fa177319",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1350,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "f977a68d6b206998",
        "type": "debug",
        "z": "38289fd68fd11ff8",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1830,
        "y": 180,
        "wires": []
    },
    {
        "id": "8bc8fb55188f0cff",
        "type": "function",
        "z": "38289fd68fd11ff8",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet flowErrors = flow.get(\"errors\") ?? [];\nlet errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nstate.errors = errors;\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 180,
        "wires": [
            [
                "f977a68d6b206998",
                "3c2237769c19c0a0"
            ]
        ]
    },
    {
        "id": "4e7e256e2d4e6b5f",
        "type": "subflow:1b897516f5bf21fa",
        "z": "38289fd68fd11ff8",
        "name": "",
        "x": 720,
        "y": 300,
        "wires": [
            [
                "971606b1692401fb"
            ],
            [
                "a95eb749be43edc7",
                "3e7ed9927c43c821"
            ],
            [
                "3c2237769c19c0a0"
            ],
            []
        ]
    },
    {
        "id": "6e7892853e618c06",
        "type": "function",
        "z": "38289fd68fd11ff8",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 280,
        "wires": [
            [
                "b7382df2f241c377",
                "3c2237769c19c0a0"
            ]
        ]
    },
    {
        "id": "b7382df2f241c377",
        "type": "function",
        "z": "38289fd68fd11ff8",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 280,
        "wires": [
            [
                "3c2237769c19c0a0"
            ]
        ]
    },
    {
        "id": "a95eb749be43edc7",
        "type": "switch",
        "z": "38289fd68fd11ff8",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1010,
        "y": 280,
        "wires": [
            [
                "6e7892853e618c06",
                "3e7ed9927c43c821"
            ]
        ]
    },
    {
        "id": "3c2237769c19c0a0",
        "type": "link out",
        "z": "38289fd68fd11ff8",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1905,
        "y": 320,
        "wires": []
    },
    {
        "id": "7ad74a770cb957b9",
        "type": "catch",
        "z": "38289fd68fd11ff8",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "2bae4cfa16e2c946"
            ]
        ]
    },
    {
        "id": "2bae4cfa16e2c946",
        "type": "debug",
        "z": "38289fd68fd11ff8",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "3e7ed9927c43c821",
        "type": "debug",
        "z": "38289fd68fd11ff8",
        "name": "instantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 340,
        "wires": []
    },
    {
        "id": "eaa3b4522f626c80",
        "type": "debug",
        "z": "38289fd68fd11ff8",
        "name": "failed output",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1510,
        "y": 540,
        "wires": []
    },
    {
        "id": "4da50f2b4dc8f6d4",
        "type": "subflow:468f2460ce66f11e",
        "z": "38289fd68fd11ff8",
        "name": "",
        "x": 750,
        "y": 420,
        "wires": [
            [
                "3c2237769c19c0a0"
            ]
        ]
    },
    {
        "id": "6ccb7f717c740c19",
        "type": "OPCUA-IIoT-Read",
        "z": "38289fd68fd11ff8",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "fc2df9e2fa177319",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 450,
        "y": 380,
        "wires": [
            [
                "4da50f2b4dc8f6d4"
            ]
        ]
    },
    {
        "id": "e0b508ec859e5b68",
        "type": "OPCUA-IIoT-Inject",
        "z": "38289fd68fd11ff8",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=19",
                "datatypeName": "String"
            }
        ],
        "x": 190,
        "y": 300,
        "wires": [
            [
                "ce7349c74d8bf917"
            ]
        ]
    },
    {
        "id": "dab8160ce933d347",
        "type": "OPCUA-IIoT-Inject",
        "z": "38289fd68fd11ff8",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 200,
        "y": 420,
        "wires": [
            [
                "6ccb7f717c740c19",
                "4da50f2b4dc8f6d4"
            ]
        ]
    },
    {
        "id": "d85d2c4bbb2796e0",
        "type": "OPCUA-IIoT-Listener",
        "z": "173ad22f4bdd0609",
        "connector": "ec2f41c16c4ad7be",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 620,
        "wires": [
            [
                "d430a3976f536cbc",
                "4dd832400178c5c4"
            ]
        ]
    },
    {
        "id": "d430a3976f536cbc",
        "type": "switch",
        "z": "173ad22f4bdd0609",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=18",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 660,
        "wires": [
            [],
            [
                "a56a02ae33f3d8b3",
                "b793787ac1b25bb0"
            ],
            [
                "b793787ac1b25bb0"
            ],
            [],
            [
                "c9bec23eaadfec7f"
            ],
            [
                "22b891eb5b7dd577"
            ],
            [],
            [
                "085b6e740696e549",
                "cc3fd18deaf85cec"
            ],
            [
                "cc3fd18deaf85cec"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fire_aktiv",
            "fire_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "4dd832400178c5c4",
        "type": "debug",
        "z": "173ad22f4bdd0609",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 780,
        "wires": []
    },
    {
        "id": "22b891eb5b7dd577",
        "type": "change",
        "z": "173ad22f4bdd0609",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1210,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "c9bec23eaadfec7f",
        "type": "function",
        "z": "173ad22f4bdd0609",
        "name": "vda_status_finished FIRE",
        "func": "const nodeValue = msg.payload.value.value.value;\nif (nodeValue == true && flow.get(\"moduleState\") == \"FIREBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_FIRE\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 760,
        "wires": [
            [
                "fdc3a06e2455de96",
                "d2713ecd3cc4e670"
            ]
        ]
    },
    {
        "id": "085b6e740696e549",
        "type": "change",
        "z": "173ad22f4bdd0609",
        "name": "OPCUA state pick_failed",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 520,
        "wires": [
            [
                "5c7cb6637f0cc322"
            ]
        ]
    },
    {
        "id": "a56a02ae33f3d8b3",
        "type": "change",
        "z": "173ad22f4bdd0609",
        "name": "OPCUA state drop_failed",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 560,
        "wires": [
            [
                "5c7cb6637f0cc322"
            ]
        ]
    },
    {
        "id": "cc3fd18deaf85cec",
        "type": "function",
        "z": "173ad22f4bdd0609",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"errors\", []);\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 680,
        "wires": [
            [
                "fdc3a06e2455de96",
                "d2713ecd3cc4e670"
            ]
        ]
    },
    {
        "id": "b793787ac1b25bb0",
        "type": "function",
        "z": "173ad22f4bdd0609",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 720,
        "wires": [
            [
                "fdc3a06e2455de96",
                "d2713ecd3cc4e670"
            ]
        ]
    },
    {
        "id": "fdc3a06e2455de96",
        "type": "debug",
        "z": "173ad22f4bdd0609",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1800,
        "y": 520,
        "wires": []
    },
    {
        "id": "b42d9933bff187b0",
        "type": "function",
        "z": "173ad22f4bdd0609",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"OVEN\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", 0);\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"OVEN\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.63\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "3480f6dbd2c82597",
        "type": "OPCUA-IIoT-Browser",
        "z": "173ad22f4bdd0609",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "ec2f41c16c4ad7be",
        "x": 380,
        "y": 620,
        "wires": [
            [
                "d85d2c4bbb2796e0",
                "5419bd74816aa8d5",
                "478aae4a4b4d44c8"
            ]
        ]
    },
    {
        "id": "9f88ba9f057ed755",
        "type": "OPCUA-IIoT-Inject",
        "z": "173ad22f4bdd0609",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 130,
        "y": 620,
        "wires": [
            [
                "3480f6dbd2c82597"
            ]
        ]
    },
    {
        "id": "5419bd74816aa8d5",
        "type": "debug",
        "z": "173ad22f4bdd0609",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 520,
        "wires": []
    },
    {
        "id": "478aae4a4b4d44c8",
        "type": "change",
        "z": "173ad22f4bdd0609",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "d2713ecd3cc4e670",
        "type": "link out",
        "z": "173ad22f4bdd0609",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1895,
        "y": 660,
        "wires": []
    },
    {
        "id": "856ae3247b172ff8",
        "type": "subflow:6a25ecd632542087",
        "z": "173ad22f4bdd0609",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-oven.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "b42d9933bff187b0"
            ]
        ]
    },
    {
        "id": "988aba3e94f77e12",
        "type": "OPCUA-IIoT-Read",
        "z": "173ad22f4bdd0609",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "ec2f41c16c4ad7be",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 300,
        "wires": [
            [
                "25221dba3c2cc921"
            ]
        ]
    },
    {
        "id": "a4b8b5b09a8024d4",
        "type": "function",
        "z": "173ad22f4bdd0609",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_FIRE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"FIRE\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"FIREBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            errors.push(error);\n            flow.set(\"errors\", errors);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    errors.push(error);\n    flow.set(\"errors\", errors);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 200,
        "wires": [
            [
                "444d3b4a0645fc02",
                "1dba24a2e322e5bc"
            ],
            [
                "162b220427411754"
            ]
        ]
    },
    {
        "id": "162b220427411754",
        "type": "function",
        "z": "173ad22f4bdd0609",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 220,
        "wires": [
            [
                "636ee19046de0158",
                "c4dc7d8627cc0b0d"
            ]
        ]
    },
    {
        "id": "444d3b4a0645fc02",
        "type": "OPCUA-IIoT-Write",
        "z": "173ad22f4bdd0609",
        "connector": "ec2f41c16c4ad7be",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1350,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "636ee19046de0158",
        "type": "debug",
        "z": "173ad22f4bdd0609",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1830,
        "y": 180,
        "wires": []
    },
    {
        "id": "1dba24a2e322e5bc",
        "type": "function",
        "z": "173ad22f4bdd0609",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet flowErrors = flow.get(\"errors\") ?? [];\nlet errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nstate.errors = errors;\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 180,
        "wires": [
            [
                "636ee19046de0158",
                "c4dc7d8627cc0b0d"
            ]
        ]
    },
    {
        "id": "25221dba3c2cc921",
        "type": "subflow:1b897516f5bf21fa",
        "z": "173ad22f4bdd0609",
        "name": "",
        "x": 720,
        "y": 300,
        "wires": [
            [
                "a4b8b5b09a8024d4"
            ],
            [
                "eee77b12406c144f",
                "7789abecd1974099"
            ],
            [
                "c4dc7d8627cc0b0d"
            ],
            []
        ]
    },
    {
        "id": "9f925523a55120b1",
        "type": "function",
        "z": "173ad22f4bdd0609",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 280,
        "wires": [
            [
                "7ff69a9672381269",
                "c4dc7d8627cc0b0d"
            ]
        ]
    },
    {
        "id": "7ff69a9672381269",
        "type": "function",
        "z": "173ad22f4bdd0609",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 280,
        "wires": [
            [
                "c4dc7d8627cc0b0d"
            ]
        ]
    },
    {
        "id": "eee77b12406c144f",
        "type": "switch",
        "z": "173ad22f4bdd0609",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1010,
        "y": 280,
        "wires": [
            [
                "9f925523a55120b1",
                "7789abecd1974099"
            ]
        ]
    },
    {
        "id": "c4dc7d8627cc0b0d",
        "type": "link out",
        "z": "173ad22f4bdd0609",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1905,
        "y": 320,
        "wires": []
    },
    {
        "id": "a41ee9efb2a3e407",
        "type": "catch",
        "z": "173ad22f4bdd0609",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "fe692799030f6cf3"
            ]
        ]
    },
    {
        "id": "fe692799030f6cf3",
        "type": "debug",
        "z": "173ad22f4bdd0609",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "7789abecd1974099",
        "type": "debug",
        "z": "173ad22f4bdd0609",
        "name": "instantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 340,
        "wires": []
    },
    {
        "id": "5c7cb6637f0cc322",
        "type": "debug",
        "z": "173ad22f4bdd0609",
        "name": "failed output",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1510,
        "y": 540,
        "wires": []
    },
    {
        "id": "7671203f601a2b12",
        "type": "subflow:468f2460ce66f11e",
        "z": "173ad22f4bdd0609",
        "name": "",
        "x": 750,
        "y": 420,
        "wires": [
            [
                "c4dc7d8627cc0b0d"
            ]
        ]
    },
    {
        "id": "16e98ff477f73d6a",
        "type": "OPCUA-IIoT-Read",
        "z": "173ad22f4bdd0609",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "ec2f41c16c4ad7be",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 380,
        "wires": [
            [
                "7671203f601a2b12"
            ]
        ]
    },
    {
        "id": "046663a148f3c506",
        "type": "OPCUA-IIoT-Inject",
        "z": "173ad22f4bdd0609",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=19",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 300,
        "wires": [
            [
                "988aba3e94f77e12"
            ]
        ]
    },
    {
        "id": "0f1abeadda4b34fb",
        "type": "OPCUA-IIoT-Inject",
        "z": "173ad22f4bdd0609",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 420,
        "wires": [
            [
                "16e98ff477f73d6a",
                "7671203f601a2b12"
            ]
        ]
    },
    {
        "id": "94532cd890c60107",
        "type": "OPCUA-IIoT-Listener",
        "z": "717abb2ca5ab1654",
        "connector": "235ad3137d70c021",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 580,
        "y": 620,
        "wires": [
            [
                "84d66ef351df01dd",
                "5634d91b77501f70"
            ]
        ]
    },
    {
        "id": "84d66ef351df01dd",
        "type": "switch",
        "z": "717abb2ca5ab1654",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=18",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 660,
        "wires": [
            [],
            [
                "698efc84d220a428",
                "688dbbda2e10df6e"
            ],
            [
                "688dbbda2e10df6e"
            ],
            [],
            [
                "f28523b5186c0366"
            ],
            [
                "ce9a8d952d611089"
            ],
            [],
            [
                "8348043e59178366",
                "f8e59af2ee072dab"
            ],
            [
                "f8e59af2ee072dab"
            ]
        ],
        "outputLabels": [
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fire_aktiv",
            "fire_finished",
            "idle",
            "pick_aktiv",
            "pick_failed",
            "pick_finished"
        ]
    },
    {
        "id": "5634d91b77501f70",
        "type": "debug",
        "z": "717abb2ca5ab1654",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 780,
        "wires": []
    },
    {
        "id": "ce9a8d952d611089",
        "type": "change",
        "z": "717abb2ca5ab1654",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1210,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "f28523b5186c0366",
        "type": "function",
        "z": "717abb2ca5ab1654",
        "name": "vda_status_finished FIRE",
        "func": "const nodeValue = msg.payload.value.value.value;\nif (nodeValue == true && flow.get(\"moduleState\") == \"FIREBUSY\") {\n    let state = flow.get(\"state\");\n    flow.set(\"moduleState\", \"WAITING_AFTER_FIRE\");\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"\n    \n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 760,
        "wires": [
            [
                "1d75029f2e9ebb40",
                "02eb86a3a529a935"
            ]
        ]
    },
    {
        "id": "8348043e59178366",
        "type": "change",
        "z": "717abb2ca5ab1654",
        "name": "OPCUA state pick_failed",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 520,
        "wires": [
            [
                "757ae4aea9efc8e8"
            ]
        ]
    },
    {
        "id": "698efc84d220a428",
        "type": "change",
        "z": "717abb2ca5ab1654",
        "name": "OPCUA state drop_failed",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 560,
        "wires": [
            [
                "757ae4aea9efc8e8"
            ]
        ]
    },
    {
        "id": "f8e59af2ee072dab",
        "type": "function",
        "z": "717abb2ca5ab1654",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"PICKBUSY\") {\n            flow.set(\"moduleState\", \"WAITING_AFTER_PICK\");\n            actionState.state = \"FINISHED\"; // Waiting for FTS\n        }\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=11\") {\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"errors\", []);\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1550,
        "y": 680,
        "wires": [
            [
                "1d75029f2e9ebb40",
                "02eb86a3a529a935"
            ]
        ]
    },
    {
        "id": "688dbbda2e10df6e",
        "type": "function",
        "z": "717abb2ca5ab1654",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"DROPBUSY\") {\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 720,
        "wires": [
            [
                "1d75029f2e9ebb40",
                "02eb86a3a529a935"
            ]
        ]
    },
    {
        "id": "1d75029f2e9ebb40",
        "type": "debug",
        "z": "717abb2ca5ab1654",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1800,
        "y": 520,
        "wires": []
    },
    {
        "id": "b5de95300ae41d02",
        "type": "function",
        "z": "717abb2ca5ab1654",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"OVEN\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", 0);\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"OVEN\");\nflow.set(\"errors\", []);\n\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.64\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\nflow.set(\"opcuaState\", \"connected\");\n\nreturn ",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "3ee0ae84d66ded0a",
        "type": "OPCUA-IIoT-Browser",
        "z": "717abb2ca5ab1654",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "235ad3137d70c021",
        "x": 380,
        "y": 620,
        "wires": [
            [
                "94532cd890c60107",
                "5794639bb9ea451c",
                "8636b456f97f635b"
            ]
        ]
    },
    {
        "id": "7ccbaf1d0777e2e2",
        "type": "OPCUA-IIoT-Inject",
        "z": "717abb2ca5ab1654",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 130,
        "y": 620,
        "wires": [
            [
                "3ee0ae84d66ded0a"
            ]
        ]
    },
    {
        "id": "5794639bb9ea451c",
        "type": "debug",
        "z": "717abb2ca5ab1654",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 520,
        "wires": []
    },
    {
        "id": "8636b456f97f635b",
        "type": "change",
        "z": "717abb2ca5ab1654",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "02eb86a3a529a935",
        "type": "link out",
        "z": "717abb2ca5ab1654",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1895,
        "y": 660,
        "wires": []
    },
    {
        "id": "2e2258e07850bacb",
        "type": "subflow:6a25ecd632542087",
        "z": "717abb2ca5ab1654",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-oven.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "b5de95300ae41d02"
            ]
        ]
    },
    {
        "id": "dcda3f9fe443f130",
        "type": "OPCUA-IIoT-Read",
        "z": "717abb2ca5ab1654",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "235ad3137d70c021",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 300,
        "wires": [
            [
                "eb97b940ceb6bf8a"
            ]
        ]
    },
    {
        "id": "6acb14762c28056d",
        "type": "function",
        "z": "717abb2ca5ab1654",
        "name": "Order Handling",
        "func": "if (flow.get(\"orderId\") == msg.payload.orderId || flow.get(\"orderId\") == \"0\") {\n    // orderId im Flow speichern\n    flow.set(\"orderId\", msg.payload.orderId);\n\n    // orderUpdateId Fallunterscheidung\n    if (msg.payload.orderUpdateId > flow.get(\"orderUpdateId\")) {\n\n        // duration in actionState\n        let actionState = flow.get(\"actionState\");\n        actionState.command = msg.payload.action.command;\n        actionState.id = msg.payload.action.id;\n        let loads = flow.get(\"loads\");\n        let newLoad = loads[0] ?? {};\n\n        // Command Fallunterscheidung\n        if (actionState.command == \"PICK\" && flow.get(\"moduleState\") == \"IDLE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"PICKBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"DROP\" && flow.get(\"moduleState\") == \"WAITING_AFTER_FIRE\") {\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"DROPBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [{ \"value\": true }];\n            msg.payload.nodesToWrite = [{ \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n        } else if (actionState.command == \"FIRE\" && flow.get(\"moduleState\") == \"WAITING_AFTER_PICK\") {\n            // state.loads bearbeiten\n            newLoad.duration = msg.payload.action.metadata.duration ? msg.payload.action.metadata.duration : 2\n\n            // ModulState busy setzen\n            flow.set(\"moduleState\", \"FIREBUSY\");\n\n            // OPCUA Write Content\n            msg.payload.valuesToWrite = [\n                { \"value\": true },\n                { \"value\": newLoad.duration }];\n            msg.payload.nodesToWrite = [\n                { \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" },\n                { \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Int16\" }];\n            actionState.duration = newLoad.duration;\n        } else {\n            const flowErrors = flow.get(\"errors\") ?? [];\n            const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n            let error = {\n                \"errorType\": \"Validation\",\n                \"errorLevel\": \"WARNING\",\n                \"errorReferences\": [\n                    { \"topic\": \"order\" },\n                    { \"headerId\": flow.get(\"headerId\") },\n                    { \"orderId\": msg.payload.orderId },\n                    { \"orderUpdateId\": msg.payload.orderUpdateId }\n                ],\n                \"errorMessage\": \"Command not supported\"\n            }\n            // Error in Flow\n            errors.push(error);\n            flow.set(\"errors\", errors);\n            return [null, msg];\n        }\n\n        // actionState in Flow speichern\n        flow.set(\"actionState\", actionState);\n\n        // loads for order im Flow speichern\n        newLoad.loadType = msg.payload.action.metadata.type;\n        flow.set(\"loads\", [newLoad]);\n\n        // orderUpdateId updaten\n        flow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\n        // OPCUA write Content\n        msg.payload.nodetype = \"inject\";\n        msg.payload.injectType = \"write\";\n\n        return [msg, null];\n    } else {\n        const flowErrors = flow.get(\"errors\") ?? [];\n        const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n        let error = {\n            \"errorType\": \"Validation\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": msg.payload.orderId },\n                { \"orderUpdateId\": msg.payload.orderUpdateId }\n            ],\n            \"errorMessage\": \"OrderUpdateId not valid\"\n        }\n        // Error in Flow\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        return [null, msg];\n    }\n} else {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": msg.payload.orderId },\n            { \"orderUpdateId\": msg.payload.orderUpdateId }\n        ],\n        \"errorMessage\": \"OrderId not valid\"\n    }\n    // Error in Flow\n    errors.push(error);\n    flow.set(\"errors\", errors);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 200,
        "wires": [
            [
                "7b2dbd202ada7bb1",
                "92975c1cbc348efa"
            ],
            [
                "10c5375250d51ab4"
            ]
        ]
    },
    {
        "id": "10c5375250d51ab4",
        "type": "function",
        "z": "717abb2ca5ab1654",
        "name": "Publish vda_status_FAILED",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 220,
        "wires": [
            [
                "2cdc66571c6d3099",
                "c3a6558945a16926"
            ]
        ]
    },
    {
        "id": "7b2dbd202ada7bb1",
        "type": "OPCUA-IIoT-Write",
        "z": "717abb2ca5ab1654",
        "connector": "235ad3137d70c021",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 1350,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "2cdc66571c6d3099",
        "type": "debug",
        "z": "717abb2ca5ab1654",
        "name": "Order State",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1830,
        "y": 180,
        "wires": []
    },
    {
        "id": "92975c1cbc348efa",
        "type": "function",
        "z": "717abb2ca5ab1654",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet flowErrors = flow.get(\"errors\") ?? [];\nlet errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.payload.action.id ? msg.payload.action.id : \"noIdfound\";\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nstate.errors = errors;\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 180,
        "wires": [
            [
                "2cdc66571c6d3099",
                "c3a6558945a16926"
            ]
        ]
    },
    {
        "id": "eb97b940ceb6bf8a",
        "type": "subflow:1b897516f5bf21fa",
        "z": "717abb2ca5ab1654",
        "name": "",
        "x": 720,
        "y": 300,
        "wires": [
            [
                "6acb14762c28056d"
            ],
            [
                "e75e0493bd973840",
                "83678cd8bbca56fa"
            ],
            [
                "c3a6558945a16926"
            ],
            []
        ]
    },
    {
        "id": "f0da0374bcfd55ff",
        "type": "function",
        "z": "717abb2ca5ab1654",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 280,
        "wires": [
            [
                "b6a25e05a6014c00",
                "c3a6558945a16926"
            ]
        ]
    },
    {
        "id": "b6a25e05a6014c00",
        "type": "function",
        "z": "717abb2ca5ab1654",
        "name": "vda_status_finished instantAction",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"FINISHED\");\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.actionState = actionState\nstate.timestamp = new Date().toISOString();\nstate.orderId = actionState.id;\nstate.orderUpdateId = \"0\";\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// flow update\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 280,
        "wires": [
            [
                "c3a6558945a16926"
            ]
        ]
    },
    {
        "id": "e75e0493bd973840",
        "type": "switch",
        "z": "717abb2ca5ab1654",
        "name": "handleInstantAction",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "factsheetRequest",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1010,
        "y": 280,
        "wires": [
            [
                "f0da0374bcfd55ff",
                "83678cd8bbca56fa"
            ]
        ]
    },
    {
        "id": "c3a6558945a16926",
        "type": "link out",
        "z": "717abb2ca5ab1654",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1905,
        "y": 320,
        "wires": []
    },
    {
        "id": "05b7d52c9224a4fe",
        "type": "catch",
        "z": "717abb2ca5ab1654",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 120,
        "wires": [
            [
                "30d26a5a8d1c5dd6"
            ]
        ]
    },
    {
        "id": "30d26a5a8d1c5dd6",
        "type": "debug",
        "z": "717abb2ca5ab1654",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 120,
        "wires": []
    },
    {
        "id": "83678cd8bbca56fa",
        "type": "debug",
        "z": "717abb2ca5ab1654",
        "name": "instantAction",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 340,
        "wires": []
    },
    {
        "id": "757ae4aea9efc8e8",
        "type": "debug",
        "z": "717abb2ca5ab1654",
        "name": "failed output",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1510,
        "y": 540,
        "wires": []
    },
    {
        "id": "37ae228747234fd2",
        "type": "subflow:468f2460ce66f11e",
        "z": "717abb2ca5ab1654",
        "name": "",
        "x": 750,
        "y": 420,
        "wires": [
            [
                "c3a6558945a16926"
            ]
        ]
    },
    {
        "id": "90c8027b331bcf9b",
        "type": "OPCUA-IIoT-Read",
        "z": "717abb2ca5ab1654",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "235ad3137d70c021",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 380,
        "wires": [
            [
                "37ae228747234fd2"
            ]
        ]
    },
    {
        "id": "a8ebfb94d5e048f9",
        "type": "OPCUA-IIoT-Inject",
        "z": "717abb2ca5ab1654",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=19",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 300,
        "wires": [
            [
                "dcda3f9fe443f130"
            ]
        ]
    },
    {
        "id": "6b3ff087d0227d35",
        "type": "OPCUA-IIoT-Inject",
        "z": "717abb2ca5ab1654",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 420,
        "wires": [
            [
                "90c8027b331bcf9b",
                "37ae228747234fd2"
            ]
        ]
    },
    {
        "id": "4698c28d8d76d2df",
        "type": "OPCUA-IIoT-Inject",
        "z": "e811f976a7becb7c",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=45",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 260,
        "wires": [
            [
                "61fe4deff23a453b"
            ]
        ]
    },
    {
        "id": "61fe4deff23a453b",
        "type": "OPCUA-IIoT-Read",
        "z": "e811f976a7becb7c",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "8b41c5e43074a4eb",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 260,
        "wires": [
            [
                "c8b72def27b09a7e"
            ]
        ]
    },
    {
        "id": "b42e9c64358f115b",
        "type": "switch",
        "z": "e811f976a7becb7c",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=37",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=21",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=34",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=24",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=36",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=19",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=38",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=35",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=26",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=28",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 19,
        "x": 850,
        "y": 1920,
        "wires": [
            [],
            [
                "42a3933e21d53d2f",
                "d5c3fd37b0d55971"
            ],
            [],
            [],
            [
                "bfd7e14dbd91dc6c",
                "0c67488c06d75700"
            ],
            [
                "d5c3fd37b0d55971",
                "0c67488c06d75700"
            ],
            [
                "c888f042e90e4194"
            ],
            [],
            [
                "ec521d97eecabf99",
                "d5c3fd37b0d55971"
            ],
            [
                "9361c8fe0b73ed60"
            ],
            [],
            [
                "c888f042e90e4194"
            ],
            [],
            [
                "0f8e9d8c8f4a575f",
                "d5c3fd37b0d55971"
            ],
            [
                "d5c3fd37b0d55971"
            ],
            [
                "78d6698d4bd8bae9",
                "c45f19c371602d69"
            ],
            [
                "d5c3fd37b0d55971",
                "c45f19c371602d69"
            ],
            [
                "c888f042e90e4194"
            ],
            []
        ],
        "outputLabels": [
            "bad_aktiv",
            "bad_finished",
            "default_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fahre_finished",
            "good_aktiv",
            "good_finished",
            "idle",
            "kalib_aktiv",
            "kalib_finished",
            "move_to_cam_aktiv",
            "move_to_cam_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished",
            "zurueck_finished",
            "zurueck_kurz_finished"
        ]
    },
    {
        "id": "ed98c16bc0f2d3e1",
        "type": "OPCUA-IIoT-Write",
        "z": "e811f976a7becb7c",
        "connector": "8b41c5e43074a4eb",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1950,
        "y": 260,
        "wires": [
            [
                "c404f5416d30e58a",
                "26f5b770c3c3eeb0"
            ]
        ]
    },
    {
        "id": "c404f5416d30e58a",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet actionState = flow.get(\"actionState\");\nactionState.state = \"RUNNING\";\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\n\n\n// flowVariable Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.payload = state;\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2250,
        "y": 260,
        "wires": [
            [
                "4e2c680ca0ad5de0",
                "6219976ae8a81f06"
            ]
        ]
    },
    {
        "id": "1654eb28e275c44d",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "internal state txt",
        "func": "msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/state\";\nmsg.action = \"subscribe\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1180,
        "wires": [
            [
                "89da011e5edca44f"
            ]
        ]
    },
    {
        "id": "b37349f25902dfc5",
        "type": "switch",
        "z": "e811f976a7becb7c",
        "name": "orderswitch",
        "property": "payload.action.command",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "CHECK_QUALITY",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1310,
        "y": 260,
        "wires": [
            [
                "70221ea5c599450d"
            ],
            [
                "6935a48b9e8b9b40"
            ],
            [
                "bdebc5cada83d1e5"
            ]
        ]
    },
    {
        "id": "70221ea5c599450d",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "PICK",
        "func": "// wenn nicht IDLE dann nichts tun\nif (flow.get(\"moduleState\") == \"IDLE\") {\n    // loads for order im Flow speichern\n    let loads = flow.get(\"loads\");\n    let newLoad = loads[0] ?? {};\n    newLoad.loadType = msg.payload.action.metadata.type;\n    flow.set(\"loads\", [newLoad]);\n\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RPICK\"); // modulestate zu \"RUNNING PICK\" setzen\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only PICK \"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 220,
        "wires": [
            [
                "ed98c16bc0f2d3e1"
            ],
            [
                "7edd04da1fa45447"
            ]
        ]
    },
    {
        "id": "bdebc5cada83d1e5",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "CHECK_QUALITY",
        "func": "// CHECK_QUALITY\nif (flow.get(\"moduleState\") == \"WCQ\") {\n    \n    // ModulState setzen\n    flow.set(\"moduleState\", \"RCQ\"); // Running Check Quality\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"move_to_camera\", \"nodeId\": \"ns=4;i=14\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only CHECK_QUALITY\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1610,
        "y": 300,
        "wires": [
            [
                "ed98c16bc0f2d3e1"
            ],
            [
                "7edd04da1fa45447"
            ]
        ]
    },
    {
        "id": "6935a48b9e8b9b40",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "DROP",
        "func": "// Drop\nif (flow.get(\"moduleState\") == \"WDROP\") {\n\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RDROP\");\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"drop\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only DROP\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 260,
        "wires": [
            [
                "ed98c16bc0f2d3e1"
            ],
            [
                "7edd04da1fa45447"
            ]
        ]
    },
    {
        "id": "0f8e9d8c8f4a575f",
        "type": "function",
        "z": "e811f976a7becb7c",
        "g": "aff14dfdae4dbb82",
        "name": "Nachricht für Controller mit Cam",
        "func": "let moduleState = flow.get(\"moduleState\");\nlet value = msg.payload.value.value.value;\n\nif (value != true) {\n    return;\n} else {\n    if (moduleState != \"RCQ\") {\n        msg.payload = {\n            \"value\": value,\n            \"moduleState\": moduleState\n        };\n        return msg;\n    } else {\n        // modulestate auf waiting for Result\n        flow.set(\"moduleState\", \"WR\");\n        let actionState = flow.get(\"actionState\");\n        let action = {};\n        action.command = actionState.command;\n        action.id = actionState.id;\n        action.metadata = actionState.metadata;\n        \n        // Timestamp\n        let now = new Date();\n        let timestamp = now.toISOString();\n\n        // Nachricht an den Controller mit Kamera\n        msg.payload = {\n            \"serialNumber\": flow.get(\"serialNumber\"),\n            \"orderId\": flow.get(\"orderId\"),\n            \"orderUpdateId\": flow.get(\"orderUpdateId\" ) + 10,\n            \"timestamp\": timestamp,\n            \"action\": action\n        }\n\n        msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/order\";\n\n        return msg;\n    }\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1410,
        "y": 1980,
        "wires": [
            [
                "1962f3637834741d",
                "9af9245fe6cabd23"
            ]
        ]
    },
    {
        "id": "c45f19c371602d69",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RPICK\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        flow.set(\"moduleState\", \"WCQ\");\n        actionState.state = \"FINISHED\"; // Waiting for FTS\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1760,
        "wires": [
            [
                "f2bd69dc761fafc5",
                "647caa775b5fad93"
            ],
            [
                "0445b95dc8b2b130"
            ]
        ]
    },
    {
        "id": "0c67488c06d75700",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RDROP\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde (erfolgreich)\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde (nicht erfolgreich)\n    else if (msg.payload.nodeId == \"ns=4;i=15\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1800,
        "wires": [
            [
                "f2bd69dc761fafc5",
                "647caa775b5fad93"
            ],
            [
                "0445b95dc8b2b130"
            ]
        ]
    },
    {
        "id": "ec521d97eecabf99",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "vda_status_finished GOOD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RGOOD\") {\n    flow.set(\"moduleState\", \"WDROP\"); // waiting for drop\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // actionstate von order holen und anpassen\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    \n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1880,
        "wires": [
            [
                "f2bd69dc761fafc5",
                "647caa775b5fad93"
            ]
        ]
    },
    {
        "id": "42a3933e21d53d2f",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "vda_status_finished BAD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RBAD\") {\n    \n    flow.set(\"moduleState\", \"IDLE\"); // return to IDLE\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // set actionstate\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    let loads = [];\n\n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = loads;\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", loads);\n    flow.set(\"actionState\", {});\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1840,
        "wires": [
            [
                "f2bd69dc761fafc5",
                "647caa775b5fad93"
            ]
        ]
    },
    {
        "id": "ca73f9f40d579204",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "state subscription handle",
        "func": "if (flow.get(\"moduleState\") != \"WR\") {\n    return;\n}\nlet actionStateCommand = msg.payload.actionState?.command ?? \"unknown\";\nlet actionStateState = msg.payload.actionState?.state ?? \"unknown\";\nlet result = msg.payload.actionState?.result ?? \"noResult\";\nlet actionState = flow.get(\"actionState\");\n\n//Vorbereitungen für OPCUA write\nmsg.payload.nodetype = \"inject\";\nmsg.payload.injectType = \"write\";\n\n// Fallunterscheidung für gutes oder schlechtes Werkstück\n\nif (actionStateCommand != \"CHECK_QUALITY\" || msg.payload.actionState.state != \"FINISHED\") {\n    return;\n}\n\nif (result == \"PASSED\") {\n    // Adresse für gutes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"good\", \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RGOOD\"); // Running Good Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else if (result == \"FAILED\") {\n    // Adresse für schlechtes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"bad\", \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RBAD\"); // Running Bad Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"FATAL\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Result not specified or no Result\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 1200,
        "wires": [
            [
                "3fe1d8b03cc71e89"
            ],
            [
                "0445b95dc8b2b130"
            ]
        ]
    },
    {
        "id": "1962f3637834741d",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "g": "aff14dfdae4dbb82",
        "name": "order to TXT",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 1960,
        "wires": []
    },
    {
        "id": "2bdd6b86dbfd8ac7",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "internal connection txt",
        "func": "const spsSerialNumber = flow.get(\"serialNumber\");\nflow.set('TXT_MQTT_topic', `module/v1/ff/NodeRed/${spsSerialNumber}`);\n\nmsg.topic = flow.get(\"TXT_MQTT_topic\") + \"/instantAction\";\nmsg.payload = {\n    \"host\": spsSerialNumber,\n    \"serialNumber\": spsSerialNumber,\n    \"timestamp\": new Date().toISOString(),\n    \"actions\": [\n        {\n            \"actionId\": \"SOME_ID\",\n            \"actionType\": \"factsheetRequest\",\n            \"metadata\": {}\n        }\n    ]\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 1120,
        "wires": [
            [
                "1654eb28e275c44d",
                "e230ef296fedef09"
            ]
        ]
    },
    {
        "id": "89da011e5edca44f",
        "type": "mqtt in",
        "z": "e811f976a7becb7c",
        "name": "dynamic Connection",
        "topic": "",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 1,
        "x": 1390,
        "y": 1180,
        "wires": [
            [
                "ca73f9f40d579204"
            ]
        ]
    },
    {
        "id": "3fe1d8b03cc71e89",
        "type": "OPCUA-IIoT-Write",
        "z": "e811f976a7becb7c",
        "connector": "8b41c5e43074a4eb",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 2090,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "9361c8fe0b73ed60",
        "type": "change",
        "z": "e811f976a7becb7c",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "78d6698d4bd8bae9",
        "type": "change",
        "z": "e811f976a7becb7c",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1760,
        "wires": [
            []
        ]
    },
    {
        "id": "bfd7e14dbd91dc6c",
        "type": "change",
        "z": "e811f976a7becb7c",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1240,
        "y": 1720,
        "wires": [
            []
        ]
    },
    {
        "id": "57c5e84c222c012d",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"AIQS\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"AIQS\");\nflow.set(\"errors\", []);\n\n// state bauen\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.70\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\n\nflow.set(\"opcuaState\", \"connected\");\nreturn ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "dfd5a2457d6bfd4a",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 520,
        "wires": [
            [
                "e6f7e7d86c9e4f06",
                "bdcef3a5ac9a4a28"
            ]
        ]
    },
    {
        "id": "2717ce023745be7f",
        "type": "OPCUA-IIoT-Browser",
        "z": "e811f976a7becb7c",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "8b41c5e43074a4eb",
        "x": 460,
        "y": 1840,
        "wires": [
            [
                "b99f23eb5a0f1c44",
                "e356e2f998e0f96d",
                "ed257f524b108284",
                "2d7d701418d52dc7"
            ]
        ]
    },
    {
        "id": "b99f23eb5a0f1c44",
        "type": "OPCUA-IIoT-Listener",
        "z": "e811f976a7becb7c",
        "connector": "8b41c5e43074a4eb",
        "action": "subscribe",
        "queueSize": "20",
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 640,
        "y": 1840,
        "wires": [
            [
                "b42e9c64358f115b",
                "2d7d701418d52dc7"
            ]
        ]
    },
    {
        "id": "e356e2f998e0f96d",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 1640,
        "wires": []
    },
    {
        "id": "34e241bcf5c439b4",
        "type": "OPCUA-IIoT-Inject",
        "z": "e811f976a7becb7c",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 250,
        "y": 1840,
        "wires": [
            [
                "2717ce023745be7f"
            ]
        ]
    },
    {
        "id": "ed257f524b108284",
        "type": "change",
        "z": "e811f976a7becb7c",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 860,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "f2bd69dc761fafc5",
        "type": "link out",
        "z": "e811f976a7becb7c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2285,
        "y": 1860,
        "wires": []
    },
    {
        "id": "d5c3fd37b0d55971",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "Finish listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 1620,
        "wires": []
    },
    {
        "id": "647caa775b5fad93",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "FINISHED_STATE_msg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2190,
        "y": 1580,
        "wires": []
    },
    {
        "id": "902f94a53a712148",
        "type": "subflow:6a25ecd632542087",
        "z": "e811f976a7becb7c",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-aiqs.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "57c5e84c222c012d"
            ]
        ]
    },
    {
        "id": "c8b72def27b09a7e",
        "type": "subflow:1b897516f5bf21fa",
        "z": "e811f976a7becb7c",
        "name": "",
        "x": 580,
        "y": 260,
        "wires": [
            [
                "5d6bedaf6d098f8e",
                "f5ec165526cca799"
            ],
            [
                "ae3cbccd9411ba94"
            ],
            [
                "f5979405bca84b37",
                "4e2c680ca0ad5de0"
            ],
            [
                "2bdd6b86dbfd8ac7"
            ]
        ]
    },
    {
        "id": "e6f7e7d86c9e4f06",
        "type": "link out",
        "z": "e811f976a7becb7c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2515,
        "y": 520,
        "wires": []
    },
    {
        "id": "ae3cbccd9411ba94",
        "type": "switch",
        "z": "e811f976a7becb7c",
        "name": "instantActionSwitch",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "factsheetRequest",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "startCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "storeCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "selectCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "testCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "resetCalibration",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "reset",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 970,
        "y": 660,
        "wires": [
            [
                "dfd5a2457d6bfd4a"
            ],
            [
                "c10838d37bbb91e1"
            ],
            [
                "aa5cf343fa610283"
            ],
            [
                "2b52d1666a9c3c28"
            ],
            [
                "e7000ebb6101c96b"
            ],
            [
                "4f649a8b4bd4d3e7"
            ],
            [
                "b8b6b14437206867",
                "447290c98fb2d68a"
            ],
            [
                "423892445e582244"
            ],
            [
                "abdbea1f2147a651"
            ]
        ]
    },
    {
        "id": "7edd04da1fa45447",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 320,
        "wires": [
            [
                "4e2c680ca0ad5de0",
                "be55475ec48cf19e"
            ]
        ]
    },
    {
        "id": "4e2c680ca0ad5de0",
        "type": "link out",
        "z": "e811f976a7becb7c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2475,
        "y": 300,
        "wires": []
    },
    {
        "id": "c2d2aa8af676c4b1",
        "type": "link out",
        "z": "e811f976a7becb7c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2255,
        "y": 1360,
        "wires": []
    },
    {
        "id": "0445b95dc8b2b130",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2110,
        "y": 1360,
        "wires": [
            [
                "c2d2aa8af676c4b1"
            ]
        ]
    },
    {
        "id": "c10838d37bbb91e1",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "startCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {ReferenceData[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            const refData = createReferenceData(nodeName, nodeValue);\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\" || moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"CALIBRATION\");\n\n    const isCalibActive = flow.get(\"calibration.state.status__kalibAktiv.nodeValue\") ?? false;\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.modulePaused = true;\n    msg.operatingMode = \"TEACHIN\";\n    msg.actionCommand = \"startCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=16\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: !isCalibActive }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not IDLE and cannot be set to CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 620,
        "wires": [
            [
                "e7e0014dac56a4d5",
                "4a5bcfc2f6e1abe7"
            ],
            [
                "aa455dac86d4714d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "aa455dac86d4714d",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 760,
        "wires": [
            [
                "e6f7e7d86c9e4f06"
            ]
        ]
    },
    {
        "id": "aa5cf343fa610283",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "stopCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"state.information\", []);\n\n    msg.actionCommand = \"stopCalibration\";\n    msg.calibrationData = [];\n    msg.modulePaused = false;\n    msg.operatingMode = \"AUTOMATIC\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 660,
        "wires": [
            [
                "b653db0e8d5fcf4b",
                "4a5bcfc2f6e1abe7"
            ],
            [
                "aa455dac86d4714d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "b653db0e8d5fcf4b",
        "type": "OPCUA-IIoT-Write",
        "z": "e811f976a7becb7c",
        "connector": "8b41c5e43074a4eb",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 680,
        "wires": [
            [
                "56a4aad6df755579",
                "d01bbd7928047299"
            ]
        ]
    },
    {
        "id": "2b52d1666a9c3c28",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "setCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"setCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 700,
        "wires": [
            [
                "4a5bcfc2f6e1abe7",
                "e7e0014dac56a4d5"
            ],
            [
                "aa455dac86d4714d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "e7000ebb6101c96b",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "storeCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: toUpdate.nodeValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"storeCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 740,
        "wires": [
            [
                "4a5bcfc2f6e1abe7",
                "e7e0014dac56a4d5"
            ],
            [
                "aa455dac86d4714d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "4f649a8b4bd4d3e7",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "selectCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    if (currentPosition?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (currentPosition) {\n            case \"TO_NIO_BIN\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitAusschuss.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitKamera.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"CHECK\": {\n                const nodeValue = 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                // We stop the movement, if the workpiece is detected by the photoelectric sensor\n                const nodeValue = 60000;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        createError(`${metadata.position} is not a valid position`);\n        return [null, msg];\n    }\n\n    const newPosition = metadata.position;\n    flow.set(\"calibration.positions.current\", newPosition);\n\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"selectCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 780,
        "wires": [
            [
                "4a5bcfc2f6e1abe7",
                "e7e0014dac56a4d5"
            ],
            [
                "aa455dac86d4714d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "b8b6b14437206867",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "testCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {Reference[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n * \n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @param {string} newCurrentPosition\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions(newCurrentPosition) {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": newCurrentPosition },\n        ]\n    }\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.position?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (metadata.position) {\n            case \"TO_NIO_BIN\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"CHECK\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: false }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=25\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions(metadata)];\n    msg.actionCommand = \"testCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 820,
        "wires": [
            [
                "b653db0e8d5fcf4b",
                "4a5bcfc2f6e1abe7"
            ],
            [
                "aa455dac86d4714d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "423892445e582244",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "resetCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    msg.actionCommand = \"resetCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=20\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 860,
        "wires": [
            [
                "b653db0e8d5fcf4b",
                "4a5bcfc2f6e1abe7"
            ],
            [
                "aa455dac86d4714d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "01bd23b8c8910a51",
        "type": "catch",
        "z": "e811f976a7becb7c",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "545b4aaf37af5646"
            ]
        ]
    },
    {
        "id": "545b4aaf37af5646",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "5d6bedaf6d098f8e",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "update-action-state",
        "func": "let orderAction = msg.orderAction;\n\n// get current actionState \nlet actionState = {};\nactionState.command = orderAction.command;\nactionState.id = orderAction.id;\nactionState.metadata = orderAction.metadata;\n\n// actionState in Flow speichern\nflow.set(\"actionState\", actionState);\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 260,
        "wires": [
            [
                "b37349f25902dfc5",
                "0eb9284e7a307cae"
            ]
        ]
    },
    {
        "id": "f5ec165526cca799",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "Order To Handle",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 160,
        "wires": []
    },
    {
        "id": "0eb9284e7a307cae",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "updated state message",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 160,
        "wires": []
    },
    {
        "id": "26f5b770c3c3eeb0",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "After Write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2150,
        "y": 180,
        "wires": []
    },
    {
        "id": "be55475ec48cf19e",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "Publish error",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2230,
        "y": 380,
        "wires": []
    },
    {
        "id": "6219976ae8a81f06",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "Publish running",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2480,
        "y": 160,
        "wires": []
    },
    {
        "id": "f5979405bca84b37",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "Errors after subflow",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 910,
        "y": 320,
        "wires": []
    },
    {
        "id": "e7e0014dac56a4d5",
        "type": "OPCUA-IIoT-Write",
        "z": "e811f976a7becb7c",
        "connector": "8b41c5e43074a4eb",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 620,
        "wires": [
            [
                "a139a595db87253a",
                "56a4aad6df755579"
            ]
        ]
    },
    {
        "id": "a139a595db87253a",
        "type": "delay",
        "z": "e811f976a7becb7c",
        "name": "",
        "pauseType": "delay",
        "timeout": "1.5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 620,
        "wires": [
            [
                "9080fba71889dd7f"
            ]
        ]
    },
    {
        "id": "9080fba71889dd7f",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "update-calibration-data",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nmsg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2000,
        "y": 620,
        "wires": [
            [
                "5792621ab9ed9d60"
            ]
        ]
    },
    {
        "id": "5792621ab9ed9d60",
        "type": "subflow:fb6b02d4d9963179",
        "z": "e811f976a7becb7c",
        "name": "",
        "x": 2250,
        "y": 620,
        "wires": [
            [
                "e6f7e7d86c9e4f06"
            ]
        ]
    },
    {
        "id": "bdcef3a5ac9a4a28",
        "type": "subflow:fb6b02d4d9963179",
        "z": "e811f976a7becb7c",
        "name": "",
        "x": 1720,
        "y": 500,
        "wires": [
            [
                "e6f7e7d86c9e4f06"
            ]
        ]
    },
    {
        "id": "2d7d701418d52dc7",
        "type": "subflow:7173b966cb38f0e0",
        "z": "e811f976a7becb7c",
        "name": "",
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "value": "TO_CAMERA,TO_NIO_BIN,TO_PICKUP,CALIBRATION_TESTIMAGE",
                "type": "str"
            },
            {
                "name": "CURRENT_POSITION",
                "value": "TO_PICKUP",
                "type": "str"
            }
        ],
        "x": 870,
        "y": 1720,
        "wires": []
    },
    {
        "id": "4a5bcfc2f6e1abe7",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "before-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 560,
        "wires": []
    },
    {
        "id": "56a4aad6df755579",
        "type": "debug",
        "z": "e811f976a7becb7c",
        "name": "after-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1840,
        "y": 560,
        "wires": []
    },
    {
        "id": "c888f042e90e4194",
        "type": "subflow:105d02aba31c4a1d",
        "z": "e811f976a7becb7c",
        "g": "560d87a37ea3206d",
        "x": 1390,
        "y": 2080,
        "wires": [
            [
                "5e2bda4e6e0fc62f"
            ]
        ]
    },
    {
        "id": "5e2bda4e6e0fc62f",
        "type": "subflow:fb6b02d4d9963179",
        "z": "e811f976a7becb7c",
        "g": "560d87a37ea3206d",
        "name": "",
        "x": 1660,
        "y": 2080,
        "wires": [
            [
                "f2bd69dc761fafc5"
            ]
        ]
    },
    {
        "id": "9af9245fe6cabd23",
        "type": "link out",
        "z": "e811f976a7becb7c",
        "g": "aff14dfdae4dbb82",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1775,
        "y": 1980,
        "wires": []
    },
    {
        "id": "dcf42524a6fd0a16",
        "type": "OPCUA-IIoT-Inject",
        "z": "e811f976a7becb7c",
        "g": "70e8a1e72bab6ed8",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 440,
        "wires": [
            [
                "72720acb4bb56133",
                "fa8f7be0e2ec5707"
            ]
        ]
    },
    {
        "id": "72720acb4bb56133",
        "type": "OPCUA-IIoT-Read",
        "z": "e811f976a7becb7c",
        "g": "70e8a1e72bab6ed8",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "8b41c5e43074a4eb",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 400,
        "wires": [
            [
                "fa8f7be0e2ec5707"
            ]
        ]
    },
    {
        "id": "fa8f7be0e2ec5707",
        "type": "subflow:468f2460ce66f11e",
        "z": "e811f976a7becb7c",
        "g": "70e8a1e72bab6ed8",
        "name": "",
        "x": 590,
        "y": 440,
        "wires": [
            [
                "4e2c680ca0ad5de0"
            ]
        ]
    },
    {
        "id": "447290c98fb2d68a",
        "type": "function",
        "z": "e811f976a7becb7c",
        "g": "862accde4aa78908",
        "name": "Order to take Picture",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    return {\n        topic: flow.get(\"TXT_MQTT_topic\") + \"/order\",\n        payload: {\n            serialNumber: flow.get(\"serialNumber\"),\n            orderId: `CHECK_QUALITY__${Date.now()}`,\n            orderUpdateId: Math.floor(Math.random() * 10),\n            timestamp: new Date().toISOString(),\n            action: {\n                id: `CHECK_QUALITY__${Date.now()}`,\n                command: \"CHECK_QUALITY\",\n                metadata: {}\n            },\n        }\n    };\n    return msg;\n} else {\n    // Ignore Message, if Module is not in calibration mode\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 980,
        "wires": [
            [
                "690bfd6eb41abf49"
            ]
        ]
    },
    {
        "id": "690bfd6eb41abf49",
        "type": "link out",
        "z": "e811f976a7becb7c",
        "g": "862accde4aa78908",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1455,
        "y": 980,
        "wires": []
    },
    {
        "id": "c0dd4c364a1fc97b",
        "type": "subflow:07a7fc5bcd60a12a",
        "z": "e811f976a7becb7c",
        "name": "",
        "x": 2250,
        "y": 680,
        "wires": [
            [
                "e6f7e7d86c9e4f06"
            ]
        ]
    },
    {
        "id": "d01bbd7928047299",
        "type": "delay",
        "z": "e811f976a7becb7c",
        "name": "",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 680,
        "wires": [
            [
                "c0dd4c364a1fc97b"
            ]
        ]
    },
    {
        "id": "abdbea1f2147a651",
        "type": "function",
        "z": "e811f976a7becb7c",
        "name": "reset",
        "func": "msg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n    ],\n    valuesToWrite: [\n        { value: true }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 900,
        "wires": [
            [
                "7c8f3d45921c6633",
                "4a5bcfc2f6e1abe7"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite"
        ]
    },
    {
        "id": "7c8f3d45921c6633",
        "type": "OPCUA-IIoT-Write",
        "z": "e811f976a7becb7c",
        "connector": "8b41c5e43074a4eb",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 900,
        "wires": [
            [
                "56a4aad6df755579"
            ]
        ]
    },
    {
        "id": "e230ef296fedef09",
        "type": "link out",
        "z": "e811f976a7becb7c",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 955,
        "y": 1120,
        "wires": []
    },
    {
        "id": "8bb2f51c9567aaf5",
        "type": "OPCUA-IIoT-Read",
        "z": "5983ec78decb4bc7",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "2a0ef4a50b3b9fe6",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 260,
        "wires": [
            [
                "1d7da5e3d8eda032"
            ]
        ]
    },
    {
        "id": "0b823eb2ce46e089",
        "type": "switch",
        "z": "5983ec78decb4bc7",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=37",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=21",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=34",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=24",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=36",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=19",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=38",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=35",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=26",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=28",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 19,
        "x": 850,
        "y": 1920,
        "wires": [
            [],
            [
                "1a9eba00b704c95c",
                "9c43fc9a387c02c2"
            ],
            [],
            [],
            [
                "c0753d70404c50af",
                "1e0f2d39d83c0b40"
            ],
            [
                "9c43fc9a387c02c2",
                "1e0f2d39d83c0b40"
            ],
            [
                "5c30fd08617e64cc"
            ],
            [],
            [
                "061a12675fed016e",
                "9c43fc9a387c02c2"
            ],
            [
                "620ae138182e62c6"
            ],
            [],
            [
                "5c30fd08617e64cc"
            ],
            [],
            [
                "c41634c33dc1a26c",
                "9c43fc9a387c02c2"
            ],
            [
                "9c43fc9a387c02c2"
            ],
            [
                "3247aba8d0fc4c7d",
                "d7a8df4cbc9623dc"
            ],
            [
                "9c43fc9a387c02c2",
                "d7a8df4cbc9623dc"
            ],
            [
                "5c30fd08617e64cc"
            ],
            []
        ],
        "outputLabels": [
            "bad_aktiv",
            "bad_finished",
            "default_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fahre_finished",
            "good_aktiv",
            "good_finished",
            "idle",
            "kalib_aktiv",
            "kalib_finished",
            "move_to_cam_aktiv",
            "move_to_cam_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished",
            "zurueck_finished",
            "zurueck_kurz_finished"
        ]
    },
    {
        "id": "563995de0fcaa40f",
        "type": "OPCUA-IIoT-Write",
        "z": "5983ec78decb4bc7",
        "connector": "2a0ef4a50b3b9fe6",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1950,
        "y": 260,
        "wires": [
            [
                "da75c99f349ee1cb",
                "11c6e4c82945ec54"
            ]
        ]
    },
    {
        "id": "da75c99f349ee1cb",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet actionState = flow.get(\"actionState\");\nactionState.state = \"RUNNING\";\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\n\n\n// flowVariable Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.payload = state;\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2250,
        "y": 260,
        "wires": [
            [
                "e67101ca9202dad1",
                "25ce02b6142ace7f"
            ]
        ]
    },
    {
        "id": "8ec41c79427207eb",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "internal state txt",
        "func": "msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/state\";\nmsg.action = \"subscribe\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1180,
        "wires": [
            [
                "8d3104eb632645ef"
            ]
        ]
    },
    {
        "id": "9ffc07c107be097d",
        "type": "switch",
        "z": "5983ec78decb4bc7",
        "name": "orderswitch",
        "property": "payload.action.command",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "CHECK_QUALITY",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1310,
        "y": 260,
        "wires": [
            [
                "b376663c2907c0ef"
            ],
            [
                "e5c49597cfa88163"
            ],
            [
                "ac5328cc22a328b1"
            ]
        ]
    },
    {
        "id": "b376663c2907c0ef",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "PICK",
        "func": "// wenn nicht IDLE dann nichts tun\nif (flow.get(\"moduleState\") == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RPICK\"); // modulestate zu \"RUNNING PICK\" setzen\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only PICK \"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 220,
        "wires": [
            [
                "563995de0fcaa40f"
            ],
            [
                "1a0f86ee1d96419a"
            ]
        ]
    },
    {
        "id": "ac5328cc22a328b1",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "CHECK_QUALITY",
        "func": "// CHECK_QUALITY\nif (flow.get(\"moduleState\") == \"WCQ\") {\n    \n    // ModulState setzen\n    flow.set(\"moduleState\", \"RCQ\"); // Running Check Quality\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"move_to_camera\", \"nodeId\": \"ns=4;i=14\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only CHECK_QUALITY\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1610,
        "y": 300,
        "wires": [
            [
                "563995de0fcaa40f"
            ],
            [
                "1a0f86ee1d96419a"
            ]
        ]
    },
    {
        "id": "e5c49597cfa88163",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "DROP",
        "func": "// Drop\nif (flow.get(\"moduleState\") == \"WDROP\") {\n\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RDROP\");\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"drop\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only DROP\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 260,
        "wires": [
            [
                "563995de0fcaa40f"
            ],
            [
                "1a0f86ee1d96419a"
            ]
        ]
    },
    {
        "id": "d7a8df4cbc9623dc",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RPICK\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        flow.set(\"moduleState\", \"WCQ\");\n        actionState.state = \"FINISHED\"; // Waiting for FTS\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1760,
        "wires": [
            [
                "ee4d6e5cc05394ad",
                "18fbc772b231dbbc"
            ],
            [
                "78c3b98da62b233c"
            ]
        ]
    },
    {
        "id": "1e0f2d39d83c0b40",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RDROP\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde (erfolgreich)\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde (nicht erfolgreich)\n    else if (msg.payload.nodeId == \"ns=4;i=15\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1800,
        "wires": [
            [
                "ee4d6e5cc05394ad",
                "18fbc772b231dbbc"
            ],
            [
                "78c3b98da62b233c"
            ]
        ]
    },
    {
        "id": "061a12675fed016e",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "vda_status_finished GOOD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RGOOD\") {\n    flow.set(\"moduleState\", \"WDROP\"); // waiting for drop\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // actionstate von order holen und anpassen\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    \n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1880,
        "wires": [
            [
                "ee4d6e5cc05394ad",
                "18fbc772b231dbbc"
            ]
        ]
    },
    {
        "id": "1a9eba00b704c95c",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "vda_status_finished BAD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RBAD\") {\n    \n    flow.set(\"moduleState\", \"IDLE\"); // return to IDLE\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // set actionstate\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    let loads = [];\n\n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = loads;\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", loads);\n    flow.set(\"actionState\", {});\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1840,
        "wires": [
            [
                "ee4d6e5cc05394ad",
                "18fbc772b231dbbc"
            ]
        ]
    },
    {
        "id": "d8263fafdc0357f3",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "state subscription handle",
        "func": "if (flow.get(\"moduleState\") != \"WR\") {\n    return;\n}\nlet actionStateCommand = msg.payload.actionState?.command ?? \"unknown\";\nlet actionStateState = msg.payload.actionState?.state ?? \"unknown\";\nlet result = msg.payload.actionState?.result ?? \"noResult\";\nlet actionState = flow.get(\"actionState\");\n\n//Vorbereitungen für OPCUA write\nmsg.payload.nodetype = \"inject\";\nmsg.payload.injectType = \"write\";\n\n// Fallunterscheidung für gutes oder schlechtes Werkstück\n\nif (actionStateCommand != \"CHECK_QUALITY\" || msg.payload.actionState.state != \"FINISHED\") {\n    return;\n}\n\nif (result == \"PASSED\") {\n    // Adresse für gutes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"good\", \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RGOOD\"); // Running Good Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else if (result == \"FAILED\") {\n    // Adresse für schlechtes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"bad\", \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RBAD\"); // Running Bad Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"FATAL\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Result not specified or no Result\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 1200,
        "wires": [
            [
                "0b495e0b363ce424"
            ],
            [
                "78c3b98da62b233c"
            ]
        ]
    },
    {
        "id": "01e46086075d7405",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "internal connection txt",
        "func": "const spsSerialNumber = flow.get(\"serialNumber\");\nflow.set('TXT_MQTT_topic', `module/v1/ff/NodeRed/${spsSerialNumber}`);\n\nmsg.topic = flow.get(\"TXT_MQTT_topic\") + \"/instantAction\";\nmsg.payload = {\n    \"host\": spsSerialNumber,\n    \"serialNumber\": spsSerialNumber,\n    \"timestamp\": new Date().toISOString(),\n    \"actions\": [\n        {\n            \"actionId\": \"SOME_ID\",\n            \"actionType\": \"factsheetRequest\",\n            \"metadata\": {}\n        }\n    ]\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 1120,
        "wires": [
            [
                "8ec41c79427207eb",
                "1933ed2865f6ad0d"
            ]
        ]
    },
    {
        "id": "8d3104eb632645ef",
        "type": "mqtt in",
        "z": "5983ec78decb4bc7",
        "name": "dynamic Connection",
        "topic": "",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 1,
        "x": 1390,
        "y": 1180,
        "wires": [
            [
                "d8263fafdc0357f3"
            ]
        ]
    },
    {
        "id": "0b495e0b363ce424",
        "type": "OPCUA-IIoT-Write",
        "z": "5983ec78decb4bc7",
        "connector": "2a0ef4a50b3b9fe6",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 2090,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "620ae138182e62c6",
        "type": "change",
        "z": "5983ec78decb4bc7",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "3247aba8d0fc4c7d",
        "type": "change",
        "z": "5983ec78decb4bc7",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1760,
        "wires": [
            []
        ]
    },
    {
        "id": "c0753d70404c50af",
        "type": "change",
        "z": "5983ec78decb4bc7",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1240,
        "y": 1720,
        "wires": [
            []
        ]
    },
    {
        "id": "cc04192852674c2b",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 520,
        "wires": [
            [
                "fdcb738a593f8bdb",
                "d2bf419f5fbd2c0b"
            ]
        ]
    },
    {
        "id": "0536bbd767a2c897",
        "type": "OPCUA-IIoT-Browser",
        "z": "5983ec78decb4bc7",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "2a0ef4a50b3b9fe6",
        "x": 460,
        "y": 1840,
        "wires": [
            [
                "2652e4976e66840f",
                "318f238d989476d3",
                "b7d3f7caf7523378",
                "70d62c90df563e15"
            ]
        ]
    },
    {
        "id": "2652e4976e66840f",
        "type": "OPCUA-IIoT-Listener",
        "z": "5983ec78decb4bc7",
        "connector": "2a0ef4a50b3b9fe6",
        "action": "subscribe",
        "queueSize": "20",
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 640,
        "y": 1840,
        "wires": [
            [
                "0b823eb2ce46e089",
                "70d62c90df563e15"
            ]
        ]
    },
    {
        "id": "318f238d989476d3",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 1640,
        "wires": []
    },
    {
        "id": "b0ae75598486eaf7",
        "type": "OPCUA-IIoT-Inject",
        "z": "5983ec78decb4bc7",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 250,
        "y": 1840,
        "wires": [
            [
                "0536bbd767a2c897"
            ]
        ]
    },
    {
        "id": "b7d3f7caf7523378",
        "type": "change",
        "z": "5983ec78decb4bc7",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 860,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "ee4d6e5cc05394ad",
        "type": "link out",
        "z": "5983ec78decb4bc7",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2285,
        "y": 1860,
        "wires": []
    },
    {
        "id": "9c43fc9a387c02c2",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "Finish listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 1620,
        "wires": []
    },
    {
        "id": "18fbc772b231dbbc",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "FINISHED_STATE_msg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2190,
        "y": 1580,
        "wires": []
    },
    {
        "id": "7e97c78e58b939b8",
        "type": "subflow:6a25ecd632542087",
        "z": "5983ec78decb4bc7",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-aiqs.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "64bf25e800c63fc0"
            ]
        ]
    },
    {
        "id": "1d7da5e3d8eda032",
        "type": "subflow:1b897516f5bf21fa",
        "z": "5983ec78decb4bc7",
        "name": "",
        "x": 580,
        "y": 260,
        "wires": [
            [
                "0391bd707926deed",
                "e86767fd73e5b7d5"
            ],
            [
                "52704fe34f2b674e"
            ],
            [
                "2ceff2e137d87f95",
                "e67101ca9202dad1"
            ],
            [
                "01e46086075d7405"
            ]
        ]
    },
    {
        "id": "fdcb738a593f8bdb",
        "type": "link out",
        "z": "5983ec78decb4bc7",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2515,
        "y": 520,
        "wires": []
    },
    {
        "id": "52704fe34f2b674e",
        "type": "switch",
        "z": "5983ec78decb4bc7",
        "name": "instantActionSwitch",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "factsheetRequest",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "startCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "storeCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "selectCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "testCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "resetCalibration",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "reset",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 970,
        "y": 660,
        "wires": [
            [
                "cc04192852674c2b"
            ],
            [
                "304c5b1c6d379df7"
            ],
            [
                "ba8f0337326f5e82"
            ],
            [
                "f9d5485c7b69205b"
            ],
            [
                "427dd3b310fca2e3"
            ],
            [
                "3248bb45be8eafc0"
            ],
            [
                "4abfc7b630b27aad",
                "d8e8ddfd4d983fb2"
            ],
            [
                "2cd15aaf150ece7c"
            ],
            [
                "165c8c2de90a0ff1"
            ]
        ]
    },
    {
        "id": "1a0f86ee1d96419a",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 320,
        "wires": [
            [
                "e67101ca9202dad1",
                "499dc8e36c4684a8"
            ]
        ]
    },
    {
        "id": "e67101ca9202dad1",
        "type": "link out",
        "z": "5983ec78decb4bc7",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2475,
        "y": 300,
        "wires": []
    },
    {
        "id": "7f79916a4455078e",
        "type": "link out",
        "z": "5983ec78decb4bc7",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2255,
        "y": 1360,
        "wires": []
    },
    {
        "id": "78c3b98da62b233c",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2110,
        "y": 1360,
        "wires": [
            [
                "7f79916a4455078e"
            ]
        ]
    },
    {
        "id": "304c5b1c6d379df7",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "startCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {ReferenceData[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            const refData = createReferenceData(nodeName, nodeValue);\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\" || moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"CALIBRATION\");\n\n    const isCalibActive = flow.get(\"calibration.state.status__kalibAktiv.nodeValue\") ?? false;\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.modulePaused = true;\n    msg.operatingMode = \"TEACHIN\";\n    msg.actionCommand = \"startCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=16\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: !isCalibActive }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not IDLE and cannot be set to CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 620,
        "wires": [
            [
                "af4667a8cafad082",
                "09411dc326c8ac40"
            ],
            [
                "6ad48b89712b8533"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "6ad48b89712b8533",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 760,
        "wires": [
            [
                "fdcb738a593f8bdb"
            ]
        ]
    },
    {
        "id": "ba8f0337326f5e82",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "stopCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"state.information\", []);\n\n    msg.actionCommand = \"stopCalibration\";\n    msg.calibrationData = [];\n    msg.modulePaused = false;\n    msg.operatingMode = \"AUTOMATIC\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 660,
        "wires": [
            [
                "7075e4d9abff5926",
                "09411dc326c8ac40"
            ],
            [
                "6ad48b89712b8533"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "7075e4d9abff5926",
        "type": "OPCUA-IIoT-Write",
        "z": "5983ec78decb4bc7",
        "connector": "2a0ef4a50b3b9fe6",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 680,
        "wires": [
            [
                "5336ab3b3fd1bc00",
                "737de66d2f4127d1"
            ]
        ]
    },
    {
        "id": "f9d5485c7b69205b",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "setCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"setCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 700,
        "wires": [
            [
                "09411dc326c8ac40",
                "af4667a8cafad082"
            ],
            [
                "6ad48b89712b8533"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "427dd3b310fca2e3",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "storeCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: toUpdate.nodeValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"storeCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 740,
        "wires": [
            [
                "09411dc326c8ac40",
                "af4667a8cafad082"
            ],
            [
                "6ad48b89712b8533"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "3248bb45be8eafc0",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "selectCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    if (currentPosition?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (currentPosition) {\n            case \"TO_NIO_BIN\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitAusschuss.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitKamera.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"CHECK\": {\n                const nodeValue = 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                // We stop the movement, if the workpiece is detected by the photoelectric sensor\n                const nodeValue = 60000;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        createError(`${metadata.position} is not a valid position`);\n        return [null, msg];\n    }\n\n    const newPosition = metadata.position;\n    flow.set(\"calibration.positions.current\", newPosition);\n\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"selectCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 780,
        "wires": [
            [
                "09411dc326c8ac40",
                "af4667a8cafad082"
            ],
            [
                "6ad48b89712b8533"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "4abfc7b630b27aad",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "testCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {Reference[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n * \n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @param {string} newCurrentPosition\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions(newCurrentPosition) {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": newCurrentPosition },\n        ]\n    }\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.position?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (metadata.position) {\n            case \"TO_NIO_BIN\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"CHECK\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: false }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=25\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions(metadata)];\n    msg.actionCommand = \"testCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 820,
        "wires": [
            [
                "7075e4d9abff5926",
                "09411dc326c8ac40"
            ],
            [
                "6ad48b89712b8533"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "2cd15aaf150ece7c",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "resetCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    msg.actionCommand = \"resetCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=20\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 860,
        "wires": [
            [
                "7075e4d9abff5926",
                "09411dc326c8ac40"
            ],
            [
                "6ad48b89712b8533"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "a4c2ea88dc1c3882",
        "type": "catch",
        "z": "5983ec78decb4bc7",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "a39a9bd5b4a9d95e"
            ]
        ]
    },
    {
        "id": "a39a9bd5b4a9d95e",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "0391bd707926deed",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "update-action-state",
        "func": "let orderAction = msg.orderAction;\n\n// get current actionState \nlet actionState = {};\nactionState.command = orderAction.command;\nactionState.id = orderAction.id;\nactionState.metadata = orderAction.metadata;\n\n// actionState in Flow speichern\nflow.set(\"actionState\", actionState);\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 260,
        "wires": [
            [
                "9ffc07c107be097d",
                "98e9408bbce90098"
            ]
        ]
    },
    {
        "id": "e86767fd73e5b7d5",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "Order To Handle",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 160,
        "wires": []
    },
    {
        "id": "98e9408bbce90098",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "updated state message",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 160,
        "wires": []
    },
    {
        "id": "11c6e4c82945ec54",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "After Write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2150,
        "y": 180,
        "wires": []
    },
    {
        "id": "499dc8e36c4684a8",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "Publish error",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2230,
        "y": 380,
        "wires": []
    },
    {
        "id": "25ce02b6142ace7f",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "Publish running",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2480,
        "y": 160,
        "wires": []
    },
    {
        "id": "2ceff2e137d87f95",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "Errors after subflow",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 910,
        "y": 320,
        "wires": []
    },
    {
        "id": "af4667a8cafad082",
        "type": "OPCUA-IIoT-Write",
        "z": "5983ec78decb4bc7",
        "connector": "2a0ef4a50b3b9fe6",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 620,
        "wires": [
            [
                "54156c0c90cadcd9",
                "5336ab3b3fd1bc00"
            ]
        ]
    },
    {
        "id": "54156c0c90cadcd9",
        "type": "delay",
        "z": "5983ec78decb4bc7",
        "name": "",
        "pauseType": "delay",
        "timeout": "1.5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 620,
        "wires": [
            [
                "157a28358fa23ff6"
            ]
        ]
    },
    {
        "id": "157a28358fa23ff6",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "update-calibration-data",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nmsg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2000,
        "y": 620,
        "wires": [
            [
                "6d2559cdd54e79ed"
            ]
        ]
    },
    {
        "id": "6d2559cdd54e79ed",
        "type": "subflow:fb6b02d4d9963179",
        "z": "5983ec78decb4bc7",
        "name": "",
        "x": 2250,
        "y": 620,
        "wires": [
            [
                "fdcb738a593f8bdb"
            ]
        ]
    },
    {
        "id": "d2bf419f5fbd2c0b",
        "type": "subflow:fb6b02d4d9963179",
        "z": "5983ec78decb4bc7",
        "name": "",
        "x": 1720,
        "y": 500,
        "wires": [
            [
                "fdcb738a593f8bdb"
            ]
        ]
    },
    {
        "id": "70d62c90df563e15",
        "type": "subflow:7173b966cb38f0e0",
        "z": "5983ec78decb4bc7",
        "name": "",
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "value": "TO_CAMERA,TO_NIO_BIN,TO_PICKUP,CALIBRATION_TESTIMAGE",
                "type": "str"
            },
            {
                "name": "CURRENT_POSITION",
                "value": "TO_PICKUP",
                "type": "str"
            }
        ],
        "x": 870,
        "y": 1720,
        "wires": []
    },
    {
        "id": "09411dc326c8ac40",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "before-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 560,
        "wires": []
    },
    {
        "id": "5336ab3b3fd1bc00",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "name": "after-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1840,
        "y": 560,
        "wires": []
    },
    {
        "id": "6aa2c767ceb31906",
        "type": "subflow:07a7fc5bcd60a12a",
        "z": "5983ec78decb4bc7",
        "name": "",
        "x": 2250,
        "y": 680,
        "wires": [
            [
                "fdcb738a593f8bdb"
            ]
        ]
    },
    {
        "id": "737de66d2f4127d1",
        "type": "delay",
        "z": "5983ec78decb4bc7",
        "name": "",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 680,
        "wires": [
            [
                "6aa2c767ceb31906"
            ]
        ]
    },
    {
        "id": "c41634c33dc1a26c",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "g": "02a99316069e846c",
        "name": "Nachricht für Controller mit Cam",
        "func": "let moduleState = flow.get(\"moduleState\");\nlet value = msg.payload.value.value.value;\n\nif (value != true) {\n    return;\n} else {\n    if (moduleState != \"RCQ\") {\n        msg.payload = {\n            \"value\": value,\n            \"moduleState\": moduleState\n        };\n        return msg;\n    } else {\n        // modulestate auf waiting for Result\n        flow.set(\"moduleState\", \"WR\");\n        let actionState = flow.get(\"actionState\");\n        let action = {};\n        action.command = actionState.command;\n        action.id = actionState.id;\n        action.metadata = actionState.metadata;\n        \n        // Timestamp\n        let now = new Date();\n        let timestamp = now.toISOString();\n\n        // Nachricht an den Controller mit Kamera\n        msg.payload = {\n            \"serialNumber\": flow.get(\"serialNumber\"),\n            \"orderId\": flow.get(\"orderId\"),\n            \"orderUpdateId\": flow.get(\"orderUpdateId\" ) + 10,\n            \"timestamp\": timestamp,\n            \"action\": action\n        }\n\n        msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/order\";\n\n        return msg;\n    }\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1410,
        "y": 1980,
        "wires": [
            [
                "c3e7e0944c5547b7",
                "6825856480022034"
            ]
        ]
    },
    {
        "id": "c3e7e0944c5547b7",
        "type": "debug",
        "z": "5983ec78decb4bc7",
        "g": "02a99316069e846c",
        "name": "order to TXT",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 1960,
        "wires": []
    },
    {
        "id": "6825856480022034",
        "type": "link out",
        "z": "5983ec78decb4bc7",
        "g": "02a99316069e846c",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1775,
        "y": 1980,
        "wires": []
    },
    {
        "id": "5c30fd08617e64cc",
        "type": "subflow:105d02aba31c4a1d",
        "z": "5983ec78decb4bc7",
        "g": "da420d3af67fe5a9",
        "x": 1390,
        "y": 2080,
        "wires": [
            [
                "2730ae1cd4ff848b"
            ]
        ]
    },
    {
        "id": "2730ae1cd4ff848b",
        "type": "subflow:fb6b02d4d9963179",
        "z": "5983ec78decb4bc7",
        "g": "da420d3af67fe5a9",
        "name": "",
        "x": 1660,
        "y": 2080,
        "wires": [
            [
                "ee4d6e5cc05394ad"
            ]
        ]
    },
    {
        "id": "781cee4c2fbbd5cc",
        "type": "OPCUA-IIoT-Inject",
        "z": "5983ec78decb4bc7",
        "g": "41988cae3f051d53",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 440,
        "wires": [
            [
                "31ebdff3f43512e3",
                "0837e84a0f2c7c79"
            ]
        ]
    },
    {
        "id": "31ebdff3f43512e3",
        "type": "OPCUA-IIoT-Read",
        "z": "5983ec78decb4bc7",
        "g": "41988cae3f051d53",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "2a0ef4a50b3b9fe6",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 400,
        "wires": [
            [
                "0837e84a0f2c7c79"
            ]
        ]
    },
    {
        "id": "0837e84a0f2c7c79",
        "type": "subflow:468f2460ce66f11e",
        "z": "5983ec78decb4bc7",
        "g": "41988cae3f051d53",
        "name": "",
        "x": 590,
        "y": 440,
        "wires": [
            [
                "e67101ca9202dad1"
            ]
        ]
    },
    {
        "id": "d8e8ddfd4d983fb2",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "g": "92b27bc5accb5f67",
        "name": "Order to take Picture",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    return {\n        topic: flow.get(\"TXT_MQTT_topic\") + \"/order\",\n        payload: {\n            serialNumber: flow.get(\"serialNumber\"),\n            orderId: `CHECK_QUALITY__${Date.now()}`,\n            orderUpdateId: Math.floor(Math.random() * 10),\n            timestamp: new Date().toISOString(),\n            action: {\n                id: `CHECK_QUALITY__${Date.now()}`,\n                command: \"CHECK_QUALITY\",\n                metadata: {}\n            },\n        }\n    };\n    return msg;\n} else {\n    // Ignore Message, if Module is not in calibration mode\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 980,
        "wires": [
            [
                "05fb4949e855ecdb"
            ]
        ]
    },
    {
        "id": "05fb4949e855ecdb",
        "type": "link out",
        "z": "5983ec78decb4bc7",
        "g": "92b27bc5accb5f67",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1455,
        "y": 980,
        "wires": []
    },
    {
        "id": "f427f718dfc3b610",
        "type": "OPCUA-IIoT-Inject",
        "z": "5983ec78decb4bc7",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=45",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 260,
        "wires": [
            [
                "8bb2f51c9567aaf5"
            ]
        ]
    },
    {
        "id": "64bf25e800c63fc0",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"AIQS\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"AIQS\");\nflow.set(\"errors\", []);\n\n// state bauen\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.71\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\n\nflow.set(\"opcuaState\", \"connected\");\nreturn ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "165c8c2de90a0ff1",
        "type": "function",
        "z": "5983ec78decb4bc7",
        "name": "reset",
        "func": "msg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n    ],\n    valuesToWrite: [\n        { value: true }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 900,
        "wires": [
            [
                "faf3b58e655ba919",
                "09411dc326c8ac40"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite"
        ]
    },
    {
        "id": "faf3b58e655ba919",
        "type": "OPCUA-IIoT-Write",
        "z": "5983ec78decb4bc7",
        "connector": "2a0ef4a50b3b9fe6",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 900,
        "wires": [
            [
                "5336ab3b3fd1bc00"
            ]
        ]
    },
    {
        "id": "1933ed2865f6ad0d",
        "type": "link out",
        "z": "5983ec78decb4bc7",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 955,
        "y": 1120,
        "wires": []
    },
    {
        "id": "55c9e17296335772",
        "type": "OPCUA-IIoT-Read",
        "z": "8464a92f18f7bec3",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "0c00108717efa66b",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 260,
        "wires": [
            [
                "3b0aac42b80792d4"
            ]
        ]
    },
    {
        "id": "d601148d40ab6894",
        "type": "switch",
        "z": "8464a92f18f7bec3",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=37",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=21",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=34",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=24",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=36",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=19",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=38",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=35",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=26",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=28",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 19,
        "x": 850,
        "y": 1920,
        "wires": [
            [],
            [
                "3e33b8afac279b75",
                "ef1b50b74b550f3d"
            ],
            [],
            [],
            [
                "bf992ece46d9c274",
                "4f950aa901170724"
            ],
            [
                "ef1b50b74b550f3d",
                "4f950aa901170724"
            ],
            [
                "840721abe690fff2"
            ],
            [],
            [
                "fd155052224487b1",
                "ef1b50b74b550f3d"
            ],
            [
                "61a9b0864ef0c321"
            ],
            [],
            [
                "840721abe690fff2"
            ],
            [],
            [
                "68b36603ad32ed4c",
                "ef1b50b74b550f3d"
            ],
            [
                "ef1b50b74b550f3d"
            ],
            [
                "82ee9382beec807f",
                "0594713a2c81fcec"
            ],
            [
                "ef1b50b74b550f3d",
                "0594713a2c81fcec"
            ],
            [
                "840721abe690fff2"
            ],
            []
        ],
        "outputLabels": [
            "bad_aktiv",
            "bad_finished",
            "default_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fahre_finished",
            "good_aktiv",
            "good_finished",
            "idle",
            "kalib_aktiv",
            "kalib_finished",
            "move_to_cam_aktiv",
            "move_to_cam_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished",
            "zurueck_finished",
            "zurueck_kurz_finished"
        ]
    },
    {
        "id": "1bb845e002024b19",
        "type": "OPCUA-IIoT-Write",
        "z": "8464a92f18f7bec3",
        "connector": "0c00108717efa66b",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1950,
        "y": 260,
        "wires": [
            [
                "a3fb73e65b17aa77",
                "eb58e1f8d2cc608f"
            ]
        ]
    },
    {
        "id": "a3fb73e65b17aa77",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet actionState = flow.get(\"actionState\");\nactionState.state = \"RUNNING\";\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\n\n\n// flowVariable Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.payload = state;\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2250,
        "y": 260,
        "wires": [
            [
                "6f100adfcdf484e6",
                "c305afbc0257eb35"
            ]
        ]
    },
    {
        "id": "e65185ea815e9ccc",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "internal state txt",
        "func": "msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/state\";\nmsg.action = \"subscribe\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1180,
        "wires": [
            [
                "edca742edac33cfa"
            ]
        ]
    },
    {
        "id": "a3763f38e530af6e",
        "type": "switch",
        "z": "8464a92f18f7bec3",
        "name": "orderswitch",
        "property": "payload.action.command",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "CHECK_QUALITY",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1310,
        "y": 260,
        "wires": [
            [
                "8a08e9e30065d83a"
            ],
            [
                "52151d9fae788128"
            ],
            [
                "e11a94bd125b59d0"
            ]
        ]
    },
    {
        "id": "8a08e9e30065d83a",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "PICK",
        "func": "// wenn nicht IDLE dann nichts tun\nif (flow.get(\"moduleState\") == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RPICK\"); // modulestate zu \"RUNNING PICK\" setzen\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only PICK \"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 220,
        "wires": [
            [
                "1bb845e002024b19"
            ],
            [
                "2a99460d89883bec"
            ]
        ]
    },
    {
        "id": "e11a94bd125b59d0",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "CHECK_QUALITY",
        "func": "// CHECK_QUALITY\nif (flow.get(\"moduleState\") == \"WCQ\") {\n    \n    // ModulState setzen\n    flow.set(\"moduleState\", \"RCQ\"); // Running Check Quality\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"move_to_camera\", \"nodeId\": \"ns=4;i=14\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only CHECK_QUALITY\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1610,
        "y": 300,
        "wires": [
            [
                "1bb845e002024b19"
            ],
            [
                "2a99460d89883bec"
            ]
        ]
    },
    {
        "id": "52151d9fae788128",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "DROP",
        "func": "// Drop\nif (flow.get(\"moduleState\") == \"WDROP\") {\n\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RDROP\");\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"drop\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only DROP\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 260,
        "wires": [
            [
                "1bb845e002024b19"
            ],
            [
                "2a99460d89883bec"
            ]
        ]
    },
    {
        "id": "0594713a2c81fcec",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RPICK\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        flow.set(\"moduleState\", \"WCQ\");\n        actionState.state = \"FINISHED\"; // Waiting for FTS\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1760,
        "wires": [
            [
                "3fc4c1aee2d7c1cc",
                "5ee4b5c68002b5f5"
            ],
            [
                "4f6713ec2ace4a3d"
            ]
        ]
    },
    {
        "id": "4f950aa901170724",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RDROP\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde (erfolgreich)\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde (nicht erfolgreich)\n    else if (msg.payload.nodeId == \"ns=4;i=15\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1800,
        "wires": [
            [
                "3fc4c1aee2d7c1cc",
                "5ee4b5c68002b5f5"
            ],
            [
                "4f6713ec2ace4a3d"
            ]
        ]
    },
    {
        "id": "fd155052224487b1",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "vda_status_finished GOOD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RGOOD\") {\n    flow.set(\"moduleState\", \"WDROP\"); // waiting for drop\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // actionstate von order holen und anpassen\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    \n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1880,
        "wires": [
            [
                "3fc4c1aee2d7c1cc",
                "5ee4b5c68002b5f5"
            ]
        ]
    },
    {
        "id": "3e33b8afac279b75",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "vda_status_finished BAD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RBAD\") {\n    \n    flow.set(\"moduleState\", \"IDLE\"); // return to IDLE\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // set actionstate\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    let loads = [];\n\n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = loads;\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", loads);\n    flow.set(\"actionState\", {});\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1840,
        "wires": [
            [
                "3fc4c1aee2d7c1cc",
                "5ee4b5c68002b5f5"
            ]
        ]
    },
    {
        "id": "7eca50039b322bd2",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "state subscription handle",
        "func": "if (flow.get(\"moduleState\") != \"WR\") {\n    return;\n}\nlet actionStateCommand = msg.payload.actionState?.command ?? \"unknown\";\nlet actionStateState = msg.payload.actionState?.state ?? \"unknown\";\nlet result = msg.payload.actionState?.result ?? \"noResult\";\nlet actionState = flow.get(\"actionState\");\n\n//Vorbereitungen für OPCUA write\nmsg.payload.nodetype = \"inject\";\nmsg.payload.injectType = \"write\";\n\n// Fallunterscheidung für gutes oder schlechtes Werkstück\n\nif (actionStateCommand != \"CHECK_QUALITY\" || msg.payload.actionState.state != \"FINISHED\") {\n    return;\n}\n\nif (result == \"PASSED\") {\n    // Adresse für gutes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"good\", \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RGOOD\"); // Running Good Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else if (result == \"FAILED\") {\n    // Adresse für schlechtes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"bad\", \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RBAD\"); // Running Bad Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"FATAL\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Result not specified or no Result\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 1200,
        "wires": [
            [
                "f0c81ce6685f80df"
            ],
            [
                "4f6713ec2ace4a3d"
            ]
        ]
    },
    {
        "id": "6d21867772ea0576",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "internal connection txt",
        "func": "const spsSerialNumber = flow.get(\"serialNumber\");\nflow.set('TXT_MQTT_topic', `module/v1/ff/NodeRed/${spsSerialNumber}`);\n\nmsg.topic = flow.get(\"TXT_MQTT_topic\") + \"/instantAction\";\nmsg.payload = {\n    \"host\": spsSerialNumber,\n    \"serialNumber\": spsSerialNumber,\n    \"timestamp\": new Date().toISOString(),\n    \"actions\": [\n        {\n            \"actionId\": \"SOME_ID\",\n            \"actionType\": \"factsheetRequest\",\n            \"metadata\": {}\n        }\n    ]\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 1120,
        "wires": [
            [
                "e65185ea815e9ccc",
                "b90bb9b723b79a8d"
            ]
        ]
    },
    {
        "id": "edca742edac33cfa",
        "type": "mqtt in",
        "z": "8464a92f18f7bec3",
        "name": "dynamic Connection",
        "topic": "",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 1,
        "x": 1390,
        "y": 1180,
        "wires": [
            [
                "7eca50039b322bd2"
            ]
        ]
    },
    {
        "id": "f0c81ce6685f80df",
        "type": "OPCUA-IIoT-Write",
        "z": "8464a92f18f7bec3",
        "connector": "0c00108717efa66b",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 2090,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "61a9b0864ef0c321",
        "type": "change",
        "z": "8464a92f18f7bec3",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "82ee9382beec807f",
        "type": "change",
        "z": "8464a92f18f7bec3",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1760,
        "wires": [
            []
        ]
    },
    {
        "id": "bf992ece46d9c274",
        "type": "change",
        "z": "8464a92f18f7bec3",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1240,
        "y": 1720,
        "wires": [
            []
        ]
    },
    {
        "id": "378ac6052c4dd4f0",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 520,
        "wires": [
            [
                "5ea501f68a0ed14d",
                "32d55f1ab247aadf"
            ]
        ]
    },
    {
        "id": "4351a4abad6f4642",
        "type": "OPCUA-IIoT-Browser",
        "z": "8464a92f18f7bec3",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "0c00108717efa66b",
        "x": 460,
        "y": 1840,
        "wires": [
            [
                "45bde374d0a108e9",
                "70a4463ad4a4041b",
                "483324f18fabf3db",
                "506652610ca6478e"
            ]
        ]
    },
    {
        "id": "45bde374d0a108e9",
        "type": "OPCUA-IIoT-Listener",
        "z": "8464a92f18f7bec3",
        "connector": "0c00108717efa66b",
        "action": "subscribe",
        "queueSize": "20",
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 640,
        "y": 1840,
        "wires": [
            [
                "d601148d40ab6894",
                "506652610ca6478e"
            ]
        ]
    },
    {
        "id": "70a4463ad4a4041b",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 1640,
        "wires": []
    },
    {
        "id": "87694a7952602ea0",
        "type": "OPCUA-IIoT-Inject",
        "z": "8464a92f18f7bec3",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 250,
        "y": 1840,
        "wires": [
            [
                "4351a4abad6f4642"
            ]
        ]
    },
    {
        "id": "483324f18fabf3db",
        "type": "change",
        "z": "8464a92f18f7bec3",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 860,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "3fc4c1aee2d7c1cc",
        "type": "link out",
        "z": "8464a92f18f7bec3",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2285,
        "y": 1860,
        "wires": []
    },
    {
        "id": "ef1b50b74b550f3d",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "Finish listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 1620,
        "wires": []
    },
    {
        "id": "5ee4b5c68002b5f5",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "FINISHED_STATE_msg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2190,
        "y": 1580,
        "wires": []
    },
    {
        "id": "aae549cbbc9f1529",
        "type": "subflow:6a25ecd632542087",
        "z": "8464a92f18f7bec3",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-aiqs.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "28d69f8a5e6a49d0"
            ]
        ]
    },
    {
        "id": "3b0aac42b80792d4",
        "type": "subflow:1b897516f5bf21fa",
        "z": "8464a92f18f7bec3",
        "name": "",
        "x": 580,
        "y": 260,
        "wires": [
            [
                "7b44b997244b14b3",
                "7c0220dde29b59cf"
            ],
            [
                "b9f341743e8b8793"
            ],
            [
                "9fedf973197860b5",
                "6f100adfcdf484e6"
            ],
            [
                "6d21867772ea0576"
            ]
        ]
    },
    {
        "id": "5ea501f68a0ed14d",
        "type": "link out",
        "z": "8464a92f18f7bec3",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2515,
        "y": 520,
        "wires": []
    },
    {
        "id": "b9f341743e8b8793",
        "type": "switch",
        "z": "8464a92f18f7bec3",
        "name": "instantActionSwitch",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "factsheetRequest",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "startCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "storeCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "selectCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "testCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "resetCalibration",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "reset",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 970,
        "y": 660,
        "wires": [
            [
                "378ac6052c4dd4f0"
            ],
            [
                "79959aad65a5e88c"
            ],
            [
                "691dc0d19064b73e"
            ],
            [
                "0297a870b3df8df9"
            ],
            [
                "31c24a0bdc921e06"
            ],
            [
                "9645044ec796e5f2"
            ],
            [
                "1f06ae7c6be32c9c",
                "bf54f3b280aea5d8"
            ],
            [
                "3a707bac703be171"
            ],
            [
                "63e80b2b87b2bdcc"
            ]
        ]
    },
    {
        "id": "2a99460d89883bec",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 320,
        "wires": [
            [
                "6f100adfcdf484e6",
                "1fc84e2dfd79f23a"
            ]
        ]
    },
    {
        "id": "6f100adfcdf484e6",
        "type": "link out",
        "z": "8464a92f18f7bec3",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2475,
        "y": 300,
        "wires": []
    },
    {
        "id": "29cc4a93307380c0",
        "type": "link out",
        "z": "8464a92f18f7bec3",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2255,
        "y": 1360,
        "wires": []
    },
    {
        "id": "4f6713ec2ace4a3d",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2110,
        "y": 1360,
        "wires": [
            [
                "29cc4a93307380c0"
            ]
        ]
    },
    {
        "id": "79959aad65a5e88c",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "startCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {ReferenceData[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            const refData = createReferenceData(nodeName, nodeValue);\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\" || moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"CALIBRATION\");\n\n    const isCalibActive = flow.get(\"calibration.state.status__kalibAktiv.nodeValue\") ?? false;\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.modulePaused = true;\n    msg.operatingMode = \"TEACHIN\";\n    msg.actionCommand = \"startCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=16\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: !isCalibActive }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not IDLE and cannot be set to CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 620,
        "wires": [
            [
                "8bd30b38cb2b2228",
                "b2252c2901ce2cc0"
            ],
            [
                "9e1e1a196e238481"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "9e1e1a196e238481",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 760,
        "wires": [
            [
                "5ea501f68a0ed14d"
            ]
        ]
    },
    {
        "id": "691dc0d19064b73e",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "stopCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"state.information\", []);\n\n    msg.actionCommand = \"stopCalibration\";\n    msg.calibrationData = [];\n    msg.modulePaused = false;\n    msg.operatingMode = \"AUTOMATIC\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 660,
        "wires": [
            [
                "320c1bfe2ab43045",
                "b2252c2901ce2cc0"
            ],
            [
                "9e1e1a196e238481"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "320c1bfe2ab43045",
        "type": "OPCUA-IIoT-Write",
        "z": "8464a92f18f7bec3",
        "connector": "0c00108717efa66b",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 680,
        "wires": [
            [
                "3857d98f403ac0c7",
                "dfd12804d8793826"
            ]
        ]
    },
    {
        "id": "0297a870b3df8df9",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "setCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"setCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 700,
        "wires": [
            [
                "b2252c2901ce2cc0",
                "8bd30b38cb2b2228"
            ],
            [
                "9e1e1a196e238481"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "31c24a0bdc921e06",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "storeCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: toUpdate.nodeValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"storeCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 740,
        "wires": [
            [
                "b2252c2901ce2cc0",
                "8bd30b38cb2b2228"
            ],
            [
                "9e1e1a196e238481"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "9645044ec796e5f2",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "selectCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    if (currentPosition?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (currentPosition) {\n            case \"TO_NIO_BIN\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitAusschuss.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitKamera.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"CHECK\": {\n                const nodeValue = 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                // We stop the movement, if the workpiece is detected by the photoelectric sensor\n                const nodeValue = 60000;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        createError(`${metadata.position} is not a valid position`);\n        return [null, msg];\n    }\n\n    const newPosition = metadata.position;\n    flow.set(\"calibration.positions.current\", newPosition);\n\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"selectCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 780,
        "wires": [
            [
                "b2252c2901ce2cc0",
                "8bd30b38cb2b2228"
            ],
            [
                "9e1e1a196e238481"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "1f06ae7c6be32c9c",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "testCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {Reference[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n * \n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @param {string} newCurrentPosition\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions(newCurrentPosition) {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": newCurrentPosition },\n        ]\n    }\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.position?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (metadata.position) {\n            case \"TO_NIO_BIN\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"CHECK\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: false }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=25\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions(metadata)];\n    msg.actionCommand = \"testCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 820,
        "wires": [
            [
                "320c1bfe2ab43045",
                "b2252c2901ce2cc0"
            ],
            [
                "9e1e1a196e238481"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "3a707bac703be171",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "resetCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    msg.actionCommand = \"resetCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=20\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 860,
        "wires": [
            [
                "320c1bfe2ab43045",
                "b2252c2901ce2cc0"
            ],
            [
                "9e1e1a196e238481"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "6f4bc86406ae600d",
        "type": "catch",
        "z": "8464a92f18f7bec3",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "9095eb459e57b238"
            ]
        ]
    },
    {
        "id": "9095eb459e57b238",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "7b44b997244b14b3",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "update-action-state",
        "func": "let orderAction = msg.orderAction;\n\n// get current actionState \nlet actionState = {};\nactionState.command = orderAction.command;\nactionState.id = orderAction.id;\nactionState.metadata = orderAction.metadata;\n\n// actionState in Flow speichern\nflow.set(\"actionState\", actionState);\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 260,
        "wires": [
            [
                "a3763f38e530af6e",
                "8ced417c085c471e"
            ]
        ]
    },
    {
        "id": "7c0220dde29b59cf",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "Order To Handle",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 160,
        "wires": []
    },
    {
        "id": "8ced417c085c471e",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "updated state message",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 160,
        "wires": []
    },
    {
        "id": "eb58e1f8d2cc608f",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "After Write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2150,
        "y": 180,
        "wires": []
    },
    {
        "id": "1fc84e2dfd79f23a",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "Publish error",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2230,
        "y": 380,
        "wires": []
    },
    {
        "id": "c305afbc0257eb35",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "Publish running",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2480,
        "y": 160,
        "wires": []
    },
    {
        "id": "9fedf973197860b5",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "Errors after subflow",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 910,
        "y": 320,
        "wires": []
    },
    {
        "id": "8bd30b38cb2b2228",
        "type": "OPCUA-IIoT-Write",
        "z": "8464a92f18f7bec3",
        "connector": "0c00108717efa66b",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 620,
        "wires": [
            [
                "cf0e9c8fbdd09f2b",
                "3857d98f403ac0c7"
            ]
        ]
    },
    {
        "id": "cf0e9c8fbdd09f2b",
        "type": "delay",
        "z": "8464a92f18f7bec3",
        "name": "",
        "pauseType": "delay",
        "timeout": "1.5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 620,
        "wires": [
            [
                "a602fcf627b0b9ef"
            ]
        ]
    },
    {
        "id": "a602fcf627b0b9ef",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "update-calibration-data",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nmsg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2000,
        "y": 620,
        "wires": [
            [
                "9f9b05d206ef4efa"
            ]
        ]
    },
    {
        "id": "9f9b05d206ef4efa",
        "type": "subflow:fb6b02d4d9963179",
        "z": "8464a92f18f7bec3",
        "name": "",
        "x": 2250,
        "y": 620,
        "wires": [
            [
                "5ea501f68a0ed14d"
            ]
        ]
    },
    {
        "id": "32d55f1ab247aadf",
        "type": "subflow:fb6b02d4d9963179",
        "z": "8464a92f18f7bec3",
        "name": "",
        "x": 1720,
        "y": 500,
        "wires": [
            [
                "5ea501f68a0ed14d"
            ]
        ]
    },
    {
        "id": "506652610ca6478e",
        "type": "subflow:7173b966cb38f0e0",
        "z": "8464a92f18f7bec3",
        "name": "",
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "value": "TO_CAMERA,TO_NIO_BIN,TO_PICKUP,CALIBRATION_TESTIMAGE",
                "type": "str"
            },
            {
                "name": "CURRENT_POSITION",
                "value": "TO_PICKUP",
                "type": "str"
            }
        ],
        "x": 870,
        "y": 1720,
        "wires": []
    },
    {
        "id": "b2252c2901ce2cc0",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "before-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 560,
        "wires": []
    },
    {
        "id": "3857d98f403ac0c7",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "name": "after-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1840,
        "y": 560,
        "wires": []
    },
    {
        "id": "0353ab726f617647",
        "type": "subflow:07a7fc5bcd60a12a",
        "z": "8464a92f18f7bec3",
        "name": "",
        "x": 2250,
        "y": 680,
        "wires": [
            [
                "5ea501f68a0ed14d"
            ]
        ]
    },
    {
        "id": "dfd12804d8793826",
        "type": "delay",
        "z": "8464a92f18f7bec3",
        "name": "",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 680,
        "wires": [
            [
                "0353ab726f617647"
            ]
        ]
    },
    {
        "id": "68b36603ad32ed4c",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "g": "5f52012546de3448",
        "name": "Nachricht für Controller mit Cam",
        "func": "let moduleState = flow.get(\"moduleState\");\nlet value = msg.payload.value.value.value;\n\nif (value != true) {\n    return;\n} else {\n    if (moduleState != \"RCQ\") {\n        msg.payload = {\n            \"value\": value,\n            \"moduleState\": moduleState\n        };\n        return msg;\n    } else {\n        // modulestate auf waiting for Result\n        flow.set(\"moduleState\", \"WR\");\n        let actionState = flow.get(\"actionState\");\n        let action = {};\n        action.command = actionState.command;\n        action.id = actionState.id;\n        action.metadata = actionState.metadata;\n        \n        // Timestamp\n        let now = new Date();\n        let timestamp = now.toISOString();\n\n        // Nachricht an den Controller mit Kamera\n        msg.payload = {\n            \"serialNumber\": flow.get(\"serialNumber\"),\n            \"orderId\": flow.get(\"orderId\"),\n            \"orderUpdateId\": flow.get(\"orderUpdateId\" ) + 10,\n            \"timestamp\": timestamp,\n            \"action\": action\n        }\n\n        msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/order\";\n\n        return msg;\n    }\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1410,
        "y": 1980,
        "wires": [
            [
                "9cf47619cbda5eb6",
                "224d482957f829ee"
            ]
        ]
    },
    {
        "id": "9cf47619cbda5eb6",
        "type": "debug",
        "z": "8464a92f18f7bec3",
        "g": "5f52012546de3448",
        "name": "order to TXT",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 1960,
        "wires": []
    },
    {
        "id": "224d482957f829ee",
        "type": "link out",
        "z": "8464a92f18f7bec3",
        "g": "5f52012546de3448",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1775,
        "y": 1980,
        "wires": []
    },
    {
        "id": "840721abe690fff2",
        "type": "subflow:105d02aba31c4a1d",
        "z": "8464a92f18f7bec3",
        "g": "939867a7fa679cd3",
        "x": 1390,
        "y": 2080,
        "wires": [
            [
                "e5e319b9e29e3efb"
            ]
        ]
    },
    {
        "id": "e5e319b9e29e3efb",
        "type": "subflow:fb6b02d4d9963179",
        "z": "8464a92f18f7bec3",
        "g": "939867a7fa679cd3",
        "name": "",
        "x": 1660,
        "y": 2080,
        "wires": [
            [
                "3fc4c1aee2d7c1cc"
            ]
        ]
    },
    {
        "id": "1cd9010796403284",
        "type": "OPCUA-IIoT-Inject",
        "z": "8464a92f18f7bec3",
        "g": "dbe76557bf1b2e57",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 440,
        "wires": [
            [
                "4bee5bcd05c146dd",
                "dfe57bc9cc92f06a"
            ]
        ]
    },
    {
        "id": "4bee5bcd05c146dd",
        "type": "OPCUA-IIoT-Read",
        "z": "8464a92f18f7bec3",
        "g": "dbe76557bf1b2e57",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "0c00108717efa66b",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 400,
        "wires": [
            [
                "dfe57bc9cc92f06a"
            ]
        ]
    },
    {
        "id": "dfe57bc9cc92f06a",
        "type": "subflow:468f2460ce66f11e",
        "z": "8464a92f18f7bec3",
        "g": "dbe76557bf1b2e57",
        "name": "",
        "x": 590,
        "y": 440,
        "wires": [
            [
                "6f100adfcdf484e6"
            ]
        ]
    },
    {
        "id": "bf54f3b280aea5d8",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "g": "a94292f1e209f59e",
        "name": "Order to take Picture",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    return {\n        topic: flow.get(\"TXT_MQTT_topic\") + \"/order\",\n        payload: {\n            serialNumber: flow.get(\"serialNumber\"),\n            orderId: `CHECK_QUALITY__${Date.now()}`,\n            orderUpdateId: Math.floor(Math.random() * 10),\n            timestamp: new Date().toISOString(),\n            action: {\n                id: `CHECK_QUALITY__${Date.now()}`,\n                command: \"CHECK_QUALITY\",\n                metadata: {}\n            },\n        }\n    };\n    return msg;\n} else {\n    // Ignore Message, if Module is not in calibration mode\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 980,
        "wires": [
            [
                "1dbbe2eabe308dd5"
            ]
        ]
    },
    {
        "id": "1dbbe2eabe308dd5",
        "type": "link out",
        "z": "8464a92f18f7bec3",
        "g": "a94292f1e209f59e",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1455,
        "y": 980,
        "wires": []
    },
    {
        "id": "6e17ad88efd988bb",
        "type": "OPCUA-IIoT-Inject",
        "z": "8464a92f18f7bec3",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=45",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 260,
        "wires": [
            [
                "55c9e17296335772"
            ]
        ]
    },
    {
        "id": "28d69f8a5e6a49d0",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"AIQS\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"AIQS\");\nflow.set(\"errors\", []);\n\n// state bauen\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.72\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\n\nflow.set(\"opcuaState\", \"connected\");\nreturn ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "63e80b2b87b2bdcc",
        "type": "function",
        "z": "8464a92f18f7bec3",
        "name": "reset",
        "func": "msg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n    ],\n    valuesToWrite: [\n        { value: true }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 900,
        "wires": [
            [
                "3a9e614d651076e0",
                "b2252c2901ce2cc0"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite"
        ]
    },
    {
        "id": "3a9e614d651076e0",
        "type": "OPCUA-IIoT-Write",
        "z": "8464a92f18f7bec3",
        "connector": "0c00108717efa66b",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 900,
        "wires": [
            [
                "3857d98f403ac0c7"
            ]
        ]
    },
    {
        "id": "b90bb9b723b79a8d",
        "type": "link out",
        "z": "8464a92f18f7bec3",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 955,
        "y": 1120,
        "wires": []
    },
    {
        "id": "2c39c3552fc8d550",
        "type": "OPCUA-IIoT-Read",
        "z": "1b1092be024196cd",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "bcbb883b31fd5d88",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 260,
        "wires": [
            [
                "fa35422bb750ebb7"
            ]
        ]
    },
    {
        "id": "de450c9776edcdd3",
        "type": "switch",
        "z": "1b1092be024196cd",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=37",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=21",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=34",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=24",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=36",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=19",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=38",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=35",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=26",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=28",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 19,
        "x": 850,
        "y": 1920,
        "wires": [
            [],
            [
                "f2d44ea58c2028ec",
                "1d79ed0d186a3013"
            ],
            [],
            [],
            [
                "188d2c3379a1d7af",
                "711acb5a093ab741"
            ],
            [
                "1d79ed0d186a3013",
                "711acb5a093ab741"
            ],
            [
                "64302493fb9a84f9"
            ],
            [],
            [
                "6dad2359c34a10cf",
                "1d79ed0d186a3013"
            ],
            [
                "c76e7b96dc57cd82"
            ],
            [],
            [
                "64302493fb9a84f9"
            ],
            [],
            [
                "3319ba635fab1198",
                "1d79ed0d186a3013"
            ],
            [
                "1d79ed0d186a3013"
            ],
            [
                "32ed26d90b833d6f",
                "ba3aa8ffe7d146d7"
            ],
            [
                "1d79ed0d186a3013",
                "ba3aa8ffe7d146d7"
            ],
            [
                "64302493fb9a84f9"
            ],
            []
        ],
        "outputLabels": [
            "bad_aktiv",
            "bad_finished",
            "default_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fahre_finished",
            "good_aktiv",
            "good_finished",
            "idle",
            "kalib_aktiv",
            "kalib_finished",
            "move_to_cam_aktiv",
            "move_to_cam_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished",
            "zurueck_finished",
            "zurueck_kurz_finished"
        ]
    },
    {
        "id": "0a8b57e3f42e894a",
        "type": "OPCUA-IIoT-Write",
        "z": "1b1092be024196cd",
        "connector": "bcbb883b31fd5d88",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1950,
        "y": 260,
        "wires": [
            [
                "62b36204b627298a",
                "055d84a199399dfa"
            ]
        ]
    },
    {
        "id": "62b36204b627298a",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet actionState = flow.get(\"actionState\");\nactionState.state = \"RUNNING\";\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\n\n\n// flowVariable Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.payload = state;\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2250,
        "y": 260,
        "wires": [
            [
                "e6c30e04c0c22070",
                "9645e69d304c5d27"
            ]
        ]
    },
    {
        "id": "eee7b2a286a76506",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "internal state txt",
        "func": "msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/state\";\nmsg.action = \"subscribe\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 1180,
        "wires": [
            [
                "c0fa3f531073d17f"
            ]
        ]
    },
    {
        "id": "850f73832ba4bdde",
        "type": "switch",
        "z": "1b1092be024196cd",
        "name": "orderswitch",
        "property": "payload.action.command",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "CHECK_QUALITY",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1310,
        "y": 260,
        "wires": [
            [
                "65404c9899c7ba5e"
            ],
            [
                "9a6fc6eef4798bd5"
            ],
            [
                "143a8ccab4969e8d"
            ]
        ]
    },
    {
        "id": "65404c9899c7ba5e",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "PICK",
        "func": "// wenn nicht IDLE dann nichts tun\nif (flow.get(\"moduleState\") == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RPICK\"); // modulestate zu \"RUNNING PICK\" setzen\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only PICK \"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 220,
        "wires": [
            [
                "0a8b57e3f42e894a"
            ],
            [
                "c5ea4579754dd339"
            ]
        ]
    },
    {
        "id": "143a8ccab4969e8d",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "CHECK_QUALITY",
        "func": "// CHECK_QUALITY\nif (flow.get(\"moduleState\") == \"WCQ\") {\n    \n    // ModulState setzen\n    flow.set(\"moduleState\", \"RCQ\"); // Running Check Quality\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"move_to_camera\", \"nodeId\": \"ns=4;i=14\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only CHECK_QUALITY\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1610,
        "y": 300,
        "wires": [
            [
                "0a8b57e3f42e894a"
            ],
            [
                "c5ea4579754dd339"
            ]
        ]
    },
    {
        "id": "9a6fc6eef4798bd5",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "DROP",
        "func": "// Drop\nif (flow.get(\"moduleState\") == \"WDROP\") {\n\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RDROP\");\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"drop\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only DROP\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 260,
        "wires": [
            [
                "0a8b57e3f42e894a"
            ],
            [
                "c5ea4579754dd339"
            ]
        ]
    },
    {
        "id": "ba3aa8ffe7d146d7",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RPICK\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        flow.set(\"moduleState\", \"WCQ\");\n        actionState.state = \"FINISHED\"; // Waiting for FTS\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1760,
        "wires": [
            [
                "fa4c5a3f99e5f939",
                "029a967b60cba159"
            ],
            [
                "1130f799c2ac2104"
            ]
        ]
    },
    {
        "id": "711acb5a093ab741",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RDROP\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde (erfolgreich)\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde (nicht erfolgreich)\n    else if (msg.payload.nodeId == \"ns=4;i=15\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1800,
        "wires": [
            [
                "fa4c5a3f99e5f939",
                "029a967b60cba159"
            ],
            [
                "1130f799c2ac2104"
            ]
        ]
    },
    {
        "id": "6dad2359c34a10cf",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "vda_status_finished GOOD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RGOOD\") {\n    flow.set(\"moduleState\", \"WDROP\"); // waiting for drop\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // actionstate von order holen und anpassen\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    \n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1880,
        "wires": [
            [
                "fa4c5a3f99e5f939",
                "029a967b60cba159"
            ]
        ]
    },
    {
        "id": "f2d44ea58c2028ec",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "vda_status_finished BAD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RBAD\") {\n    \n    flow.set(\"moduleState\", \"IDLE\"); // return to IDLE\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // set actionstate\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    let loads = [];\n\n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = loads;\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", loads);\n    flow.set(\"actionState\", {});\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1840,
        "wires": [
            [
                "fa4c5a3f99e5f939",
                "029a967b60cba159"
            ]
        ]
    },
    {
        "id": "1d4d96447177d994",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "state subscription handle",
        "func": "if (flow.get(\"moduleState\") != \"WR\") {\n    return;\n}\nlet actionStateCommand = msg.payload.actionState?.command ?? \"unknown\";\nlet actionStateState = msg.payload.actionState?.state ?? \"unknown\";\nlet result = msg.payload.actionState?.result ?? \"noResult\";\nlet actionState = flow.get(\"actionState\");\n\n//Vorbereitungen für OPCUA write\nmsg.payload.nodetype = \"inject\";\nmsg.payload.injectType = \"write\";\n\n// Fallunterscheidung für gutes oder schlechtes Werkstück\n\nif (actionStateCommand != \"CHECK_QUALITY\" || msg.payload.actionState.state != \"FINISHED\") {\n    return;\n}\n\nif (result == \"PASSED\") {\n    // Adresse für gutes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"good\", \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RGOOD\"); // Running Good Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else if (result == \"FAILED\") {\n    // Adresse für schlechtes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"bad\", \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RBAD\"); // Running Bad Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"FATAL\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Result not specified or no Result\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 1200,
        "wires": [
            [
                "86130c4b9b50786a"
            ],
            [
                "1130f799c2ac2104"
            ]
        ]
    },
    {
        "id": "0188f5d73859574a",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "internal connection txt",
        "func": "const spsSerialNumber = flow.get(\"serialNumber\");\nflow.set('TXT_MQTT_topic', `module/v1/ff/NodeRed/${spsSerialNumber}`);\n\nmsg.topic = flow.get(\"TXT_MQTT_topic\") + \"/instantAction\";\nmsg.payload = {\n    \"host\": spsSerialNumber,\n    \"serialNumber\": spsSerialNumber,\n    \"timestamp\": new Date().toISOString(),\n    \"actions\": [\n        {\n            \"actionId\": \"SOME_ID\",\n            \"actionType\": \"factsheetRequest\",\n            \"metadata\": {}\n        }\n    ]\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 1120,
        "wires": [
            [
                "eee7b2a286a76506",
                "63b8e9df09063d86"
            ]
        ]
    },
    {
        "id": "c0fa3f531073d17f",
        "type": "mqtt in",
        "z": "1b1092be024196cd",
        "name": "dynamic Connection",
        "topic": "",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 1,
        "x": 1390,
        "y": 1180,
        "wires": [
            [
                "1d4d96447177d994"
            ]
        ]
    },
    {
        "id": "86130c4b9b50786a",
        "type": "OPCUA-IIoT-Write",
        "z": "1b1092be024196cd",
        "connector": "bcbb883b31fd5d88",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 2090,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "c76e7b96dc57cd82",
        "type": "change",
        "z": "1b1092be024196cd",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "32ed26d90b833d6f",
        "type": "change",
        "z": "1b1092be024196cd",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1760,
        "wires": [
            []
        ]
    },
    {
        "id": "188d2c3379a1d7af",
        "type": "change",
        "z": "1b1092be024196cd",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1240,
        "y": 1720,
        "wires": [
            []
        ]
    },
    {
        "id": "153c18b1e1ccb37a",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 520,
        "wires": [
            [
                "fcf3a32b6f64b8a6",
                "9a7ffe4139b99835"
            ]
        ]
    },
    {
        "id": "3a870bda1bda87f2",
        "type": "OPCUA-IIoT-Browser",
        "z": "1b1092be024196cd",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "bcbb883b31fd5d88",
        "x": 460,
        "y": 1840,
        "wires": [
            [
                "89c1ff5b6316ba8f",
                "9a32d1b69b212aa7",
                "240364bfbd979c6d",
                "ee60bdc3fcab8bf2"
            ]
        ]
    },
    {
        "id": "89c1ff5b6316ba8f",
        "type": "OPCUA-IIoT-Listener",
        "z": "1b1092be024196cd",
        "connector": "bcbb883b31fd5d88",
        "action": "subscribe",
        "queueSize": "20",
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 640,
        "y": 1840,
        "wires": [
            [
                "de450c9776edcdd3",
                "ee60bdc3fcab8bf2"
            ]
        ]
    },
    {
        "id": "9a32d1b69b212aa7",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 1640,
        "wires": []
    },
    {
        "id": "5b72d04cba7f10bd",
        "type": "OPCUA-IIoT-Inject",
        "z": "1b1092be024196cd",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 250,
        "y": 1840,
        "wires": [
            [
                "3a870bda1bda87f2"
            ]
        ]
    },
    {
        "id": "240364bfbd979c6d",
        "type": "change",
        "z": "1b1092be024196cd",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 860,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "fa4c5a3f99e5f939",
        "type": "link out",
        "z": "1b1092be024196cd",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2285,
        "y": 1860,
        "wires": []
    },
    {
        "id": "1d79ed0d186a3013",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "Finish listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 1620,
        "wires": []
    },
    {
        "id": "029a967b60cba159",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "FINISHED_STATE_msg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2190,
        "y": 1580,
        "wires": []
    },
    {
        "id": "d2c21ce45c0f1721",
        "type": "subflow:6a25ecd632542087",
        "z": "1b1092be024196cd",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-aiqs.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "064ee8abb14f5a28"
            ]
        ]
    },
    {
        "id": "fa35422bb750ebb7",
        "type": "subflow:1b897516f5bf21fa",
        "z": "1b1092be024196cd",
        "name": "",
        "x": 580,
        "y": 260,
        "wires": [
            [
                "bcf68520e88fcfe3",
                "f7fcacf10c70a326"
            ],
            [
                "261ecc59c5ab4325"
            ],
            [
                "af6429d8c6e75f6f",
                "e6c30e04c0c22070"
            ],
            [
                "0188f5d73859574a"
            ]
        ]
    },
    {
        "id": "fcf3a32b6f64b8a6",
        "type": "link out",
        "z": "1b1092be024196cd",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2515,
        "y": 520,
        "wires": []
    },
    {
        "id": "261ecc59c5ab4325",
        "type": "switch",
        "z": "1b1092be024196cd",
        "name": "instantActionSwitch",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "factsheetRequest",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "startCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "storeCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "selectCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "testCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "resetCalibration",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "reset",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 970,
        "y": 660,
        "wires": [
            [
                "153c18b1e1ccb37a"
            ],
            [
                "dea42346f899e3e2"
            ],
            [
                "f80f1acc4918c58e"
            ],
            [
                "92aebca7ee0054a6"
            ],
            [
                "9b9ae0e4eb3e3ad8"
            ],
            [
                "d34ccf0aecde71ed"
            ],
            [
                "4412b8043b4f6591",
                "1f076ed3d2c2e1f9"
            ],
            [
                "9ce29c541c82b781"
            ],
            [
                "9dc93609d7c3707b"
            ]
        ]
    },
    {
        "id": "c5ea4579754dd339",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 320,
        "wires": [
            [
                "e6c30e04c0c22070",
                "bbbc5c8c2cbf2620"
            ]
        ]
    },
    {
        "id": "e6c30e04c0c22070",
        "type": "link out",
        "z": "1b1092be024196cd",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2475,
        "y": 300,
        "wires": []
    },
    {
        "id": "37552e6686b7069a",
        "type": "link out",
        "z": "1b1092be024196cd",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2265,
        "y": 1360,
        "wires": []
    },
    {
        "id": "1130f799c2ac2104",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2110,
        "y": 1360,
        "wires": [
            [
                "37552e6686b7069a"
            ]
        ]
    },
    {
        "id": "dea42346f899e3e2",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "startCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {ReferenceData[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            const refData = createReferenceData(nodeName, nodeValue);\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\" || moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"CALIBRATION\");\n\n    const isCalibActive = flow.get(\"calibration.state.status__kalibAktiv.nodeValue\") ?? false;\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.modulePaused = true;\n    msg.operatingMode = \"TEACHIN\";\n    msg.actionCommand = \"startCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=16\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: !isCalibActive }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not IDLE and cannot be set to CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 620,
        "wires": [
            [
                "de67fb91cecd8477",
                "062e95dc922e836f"
            ],
            [
                "ff51662f49291bf1"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "ff51662f49291bf1",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 760,
        "wires": [
            [
                "fcf3a32b6f64b8a6"
            ]
        ]
    },
    {
        "id": "f80f1acc4918c58e",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "stopCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"state.information\", []);\n\n    msg.actionCommand = \"stopCalibration\";\n    msg.calibrationData = [];\n    msg.modulePaused = false;\n    msg.operatingMode = \"AUTOMATIC\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 660,
        "wires": [
            [
                "2386334f48c6e920",
                "062e95dc922e836f"
            ],
            [
                "ff51662f49291bf1"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "2386334f48c6e920",
        "type": "OPCUA-IIoT-Write",
        "z": "1b1092be024196cd",
        "connector": "bcbb883b31fd5d88",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 680,
        "wires": [
            [
                "80e730e267ffb86e",
                "fecb6c261091c9ab"
            ]
        ]
    },
    {
        "id": "92aebca7ee0054a6",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "setCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"setCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 700,
        "wires": [
            [
                "062e95dc922e836f",
                "de67fb91cecd8477"
            ],
            [
                "ff51662f49291bf1"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "9b9ae0e4eb3e3ad8",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "storeCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: toUpdate.nodeValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"storeCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 740,
        "wires": [
            [
                "062e95dc922e836f",
                "de67fb91cecd8477"
            ],
            [
                "ff51662f49291bf1"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "d34ccf0aecde71ed",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "selectCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    if (currentPosition?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (currentPosition) {\n            case \"TO_NIO_BIN\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitAusschuss.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitKamera.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"CHECK\": {\n                const nodeValue = 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                // We stop the movement, if the workpiece is detected by the photoelectric sensor\n                const nodeValue = 60000;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        createError(`${metadata.position} is not a valid position`);\n        return [null, msg];\n    }\n\n    const newPosition = metadata.position;\n    flow.set(\"calibration.positions.current\", newPosition);\n\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"selectCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 780,
        "wires": [
            [
                "062e95dc922e836f",
                "de67fb91cecd8477"
            ],
            [
                "ff51662f49291bf1"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "4412b8043b4f6591",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "testCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {Reference[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n * \n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @param {string} newCurrentPosition\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions(newCurrentPosition) {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": newCurrentPosition },\n        ]\n    }\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.position?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (metadata.position) {\n            case \"TO_NIO_BIN\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"CHECK\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: false }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=25\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions(metadata)];\n    msg.actionCommand = \"testCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 820,
        "wires": [
            [
                "2386334f48c6e920",
                "062e95dc922e836f"
            ],
            [
                "ff51662f49291bf1"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "9ce29c541c82b781",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "resetCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    msg.actionCommand = \"resetCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=20\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 860,
        "wires": [
            [
                "2386334f48c6e920",
                "062e95dc922e836f"
            ],
            [
                "ff51662f49291bf1"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "31ae269c7e4c7a60",
        "type": "catch",
        "z": "1b1092be024196cd",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "5cfd716cedd830fd"
            ]
        ]
    },
    {
        "id": "5cfd716cedd830fd",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "bcf68520e88fcfe3",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "update-action-state",
        "func": "let orderAction = msg.orderAction;\n\n// get current actionState \nlet actionState = {};\nactionState.command = orderAction.command;\nactionState.id = orderAction.id;\nactionState.metadata = orderAction.metadata;\n\n// actionState in Flow speichern\nflow.set(\"actionState\", actionState);\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 260,
        "wires": [
            [
                "850f73832ba4bdde",
                "4ee2ea3e7b92e619"
            ]
        ]
    },
    {
        "id": "f7fcacf10c70a326",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "Order To Handle",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 160,
        "wires": []
    },
    {
        "id": "4ee2ea3e7b92e619",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "updated state message",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 160,
        "wires": []
    },
    {
        "id": "055d84a199399dfa",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "After Write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2150,
        "y": 180,
        "wires": []
    },
    {
        "id": "bbbc5c8c2cbf2620",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "Publish error",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2230,
        "y": 380,
        "wires": []
    },
    {
        "id": "9645e69d304c5d27",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "Publish running",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2480,
        "y": 160,
        "wires": []
    },
    {
        "id": "af6429d8c6e75f6f",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "Errors after subflow",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 910,
        "y": 320,
        "wires": []
    },
    {
        "id": "de67fb91cecd8477",
        "type": "OPCUA-IIoT-Write",
        "z": "1b1092be024196cd",
        "connector": "bcbb883b31fd5d88",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 620,
        "wires": [
            [
                "47a231b7f233aa48",
                "80e730e267ffb86e"
            ]
        ]
    },
    {
        "id": "47a231b7f233aa48",
        "type": "delay",
        "z": "1b1092be024196cd",
        "name": "",
        "pauseType": "delay",
        "timeout": "1.5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 620,
        "wires": [
            [
                "202e26a74a33a417"
            ]
        ]
    },
    {
        "id": "202e26a74a33a417",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "update-calibration-data",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nmsg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2000,
        "y": 620,
        "wires": [
            [
                "82a9d36b9c54df4a"
            ]
        ]
    },
    {
        "id": "82a9d36b9c54df4a",
        "type": "subflow:fb6b02d4d9963179",
        "z": "1b1092be024196cd",
        "name": "",
        "x": 2250,
        "y": 620,
        "wires": [
            [
                "fcf3a32b6f64b8a6"
            ]
        ]
    },
    {
        "id": "9a7ffe4139b99835",
        "type": "subflow:fb6b02d4d9963179",
        "z": "1b1092be024196cd",
        "name": "",
        "x": 1720,
        "y": 500,
        "wires": [
            [
                "fcf3a32b6f64b8a6"
            ]
        ]
    },
    {
        "id": "ee60bdc3fcab8bf2",
        "type": "subflow:7173b966cb38f0e0",
        "z": "1b1092be024196cd",
        "name": "",
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "value": "TO_CAMERA,TO_NIO_BIN,TO_PICKUP,CALIBRATION_TESTIMAGE",
                "type": "str"
            },
            {
                "name": "CURRENT_POSITION",
                "value": "TO_PICKUP",
                "type": "str"
            }
        ],
        "x": 870,
        "y": 1720,
        "wires": []
    },
    {
        "id": "062e95dc922e836f",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "before-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 560,
        "wires": []
    },
    {
        "id": "80e730e267ffb86e",
        "type": "debug",
        "z": "1b1092be024196cd",
        "name": "after-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1840,
        "y": 560,
        "wires": []
    },
    {
        "id": "e0d379cddc5b5262",
        "type": "subflow:07a7fc5bcd60a12a",
        "z": "1b1092be024196cd",
        "name": "",
        "x": 2250,
        "y": 680,
        "wires": [
            [
                "fcf3a32b6f64b8a6"
            ]
        ]
    },
    {
        "id": "fecb6c261091c9ab",
        "type": "delay",
        "z": "1b1092be024196cd",
        "name": "",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 680,
        "wires": [
            [
                "e0d379cddc5b5262"
            ]
        ]
    },
    {
        "id": "3319ba635fab1198",
        "type": "function",
        "z": "1b1092be024196cd",
        "g": "ad86cf337e1bde88",
        "name": "Nachricht für Controller mit Cam",
        "func": "let moduleState = flow.get(\"moduleState\");\nlet value = msg.payload.value.value.value;\n\nif (value != true) {\n    return;\n} else {\n    if (moduleState != \"RCQ\") {\n        msg.payload = {\n            \"value\": value,\n            \"moduleState\": moduleState\n        };\n        return msg;\n    } else {\n        // modulestate auf waiting for Result\n        flow.set(\"moduleState\", \"WR\");\n        let actionState = flow.get(\"actionState\");\n        let action = {};\n        action.command = actionState.command;\n        action.id = actionState.id;\n        action.metadata = actionState.metadata;\n        \n        // Timestamp\n        let now = new Date();\n        let timestamp = now.toISOString();\n\n        // Nachricht an den Controller mit Kamera\n        msg.payload = {\n            \"serialNumber\": flow.get(\"serialNumber\"),\n            \"orderId\": flow.get(\"orderId\"),\n            \"orderUpdateId\": flow.get(\"orderUpdateId\" ) + 10,\n            \"timestamp\": timestamp,\n            \"action\": action\n        }\n\n        msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/order\";\n\n        return msg;\n    }\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1410,
        "y": 1980,
        "wires": [
            [
                "318ccf97af04b4ec",
                "f9f34853b704e98a"
            ]
        ]
    },
    {
        "id": "318ccf97af04b4ec",
        "type": "debug",
        "z": "1b1092be024196cd",
        "g": "ad86cf337e1bde88",
        "name": "order to TXT",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 1960,
        "wires": []
    },
    {
        "id": "f9f34853b704e98a",
        "type": "link out",
        "z": "1b1092be024196cd",
        "g": "ad86cf337e1bde88",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1775,
        "y": 1980,
        "wires": []
    },
    {
        "id": "64302493fb9a84f9",
        "type": "subflow:105d02aba31c4a1d",
        "z": "1b1092be024196cd",
        "g": "c49eb867beb3380f",
        "x": 1390,
        "y": 2080,
        "wires": [
            [
                "aa93bb735679ddfa"
            ]
        ]
    },
    {
        "id": "aa93bb735679ddfa",
        "type": "subflow:fb6b02d4d9963179",
        "z": "1b1092be024196cd",
        "g": "c49eb867beb3380f",
        "name": "",
        "x": 1660,
        "y": 2080,
        "wires": [
            [
                "fa4c5a3f99e5f939"
            ]
        ]
    },
    {
        "id": "161eb1db24684544",
        "type": "OPCUA-IIoT-Inject",
        "z": "1b1092be024196cd",
        "g": "a1f9318bc31d47e4",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 440,
        "wires": [
            [
                "5445f42677a66cab",
                "d30288bc7ae85c30"
            ]
        ]
    },
    {
        "id": "5445f42677a66cab",
        "type": "OPCUA-IIoT-Read",
        "z": "1b1092be024196cd",
        "g": "a1f9318bc31d47e4",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "bcbb883b31fd5d88",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 400,
        "wires": [
            [
                "d30288bc7ae85c30"
            ]
        ]
    },
    {
        "id": "d30288bc7ae85c30",
        "type": "subflow:468f2460ce66f11e",
        "z": "1b1092be024196cd",
        "g": "a1f9318bc31d47e4",
        "name": "",
        "x": 590,
        "y": 440,
        "wires": [
            [
                "e6c30e04c0c22070"
            ]
        ]
    },
    {
        "id": "1f076ed3d2c2e1f9",
        "type": "function",
        "z": "1b1092be024196cd",
        "g": "1698cba31e843cb7",
        "name": "Order to take Picture",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    return {\n        topic: flow.get(\"TXT_MQTT_topic\") + \"/order\",\n        payload: {\n            serialNumber: flow.get(\"serialNumber\"),\n            orderId: `CHECK_QUALITY__${Date.now()}`,\n            orderUpdateId: Math.floor(Math.random() * 10),\n            timestamp: new Date().toISOString(),\n            action: {\n                id: `CHECK_QUALITY__${Date.now()}`,\n                command: \"CHECK_QUALITY\",\n                metadata: {}\n            },\n        }\n    };\n    return msg;\n} else {\n    // Ignore Message, if Module is not in calibration mode\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 980,
        "wires": [
            [
                "7b431bd530678e41"
            ]
        ]
    },
    {
        "id": "7b431bd530678e41",
        "type": "link out",
        "z": "1b1092be024196cd",
        "g": "1698cba31e843cb7",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1455,
        "y": 980,
        "wires": []
    },
    {
        "id": "7cb22787f5a80fb8",
        "type": "OPCUA-IIoT-Inject",
        "z": "1b1092be024196cd",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=45",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 260,
        "wires": [
            [
                "2c39c3552fc8d550"
            ]
        ]
    },
    {
        "id": "064ee8abb14f5a28",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"AIQS\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"AIQS\");\nflow.set(\"errors\", []);\n\n// state bauen\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.73\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\n\nflow.set(\"opcuaState\", \"connected\");\nreturn ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "9dc93609d7c3707b",
        "type": "function",
        "z": "1b1092be024196cd",
        "name": "reset",
        "func": "msg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n    ],\n    valuesToWrite: [\n        { value: true }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 900,
        "wires": [
            [
                "b61b2e382e68e2fa",
                "062e95dc922e836f"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite"
        ]
    },
    {
        "id": "b61b2e382e68e2fa",
        "type": "OPCUA-IIoT-Write",
        "z": "1b1092be024196cd",
        "connector": "bcbb883b31fd5d88",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 900,
        "wires": [
            [
                "80e730e267ffb86e"
            ]
        ]
    },
    {
        "id": "63b8e9df09063d86",
        "type": "link out",
        "z": "1b1092be024196cd",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 955,
        "y": 1120,
        "wires": []
    },
    {
        "id": "30bc65fba56d80cb",
        "type": "OPCUA-IIoT-Read",
        "z": "2a102a482beaf61c",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "712b60d60ce311d2",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 260,
        "wires": [
            [
                "063467ae6e46d7b3"
            ]
        ]
    },
    {
        "id": "771281b6e7e1cacb",
        "type": "switch",
        "z": "2a102a482beaf61c",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=37",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=21",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=34",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=15",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=9",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=24",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=36",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=19",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=38",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=35",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=12",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=8",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=26",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=28",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 19,
        "x": 850,
        "y": 1920,
        "wires": [
            [],
            [
                "320bbbac587daeda",
                "6a8d668d01d461d9"
            ],
            [],
            [],
            [
                "43bd63c88085a460",
                "6344e10ed7e06e69"
            ],
            [
                "6a8d668d01d461d9",
                "6344e10ed7e06e69"
            ],
            [
                "11d42c1894748abb"
            ],
            [],
            [
                "1e92f737059dab78",
                "6a8d668d01d461d9"
            ],
            [
                "3b11f7bf96cdccfd"
            ],
            [],
            [
                "11d42c1894748abb"
            ],
            [],
            [
                "3e6dc1ec1d4b7727",
                "6a8d668d01d461d9"
            ],
            [
                "6a8d668d01d461d9"
            ],
            [
                "c245af51c7e7e770",
                "a0154cce58c3ac0b"
            ],
            [
                "6a8d668d01d461d9",
                "a0154cce58c3ac0b"
            ],
            [
                "11d42c1894748abb"
            ],
            []
        ],
        "outputLabels": [
            "bad_aktiv",
            "bad_finished",
            "default_finished",
            "drop_aktiv",
            "drop_failed",
            "drop_finished",
            "fahre_finished",
            "good_aktiv",
            "good_finished",
            "idle",
            "kalib_aktiv",
            "kalib_finished",
            "move_to_cam_aktiv",
            "move_to_cam_finished",
            "pick_aktiv",
            "pick_failed",
            "pick_finished",
            "zurueck_finished",
            "zurueck_kurz_finished"
        ]
    },
    {
        "id": "08f8a9c64e079c45",
        "type": "OPCUA-IIoT-Write",
        "z": "2a102a482beaf61c",
        "connector": "712b60d60ce311d2",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1950,
        "y": 260,
        "wires": [
            [
                "be57387b3dfde232",
                "d40cd6a280276c2c"
            ]
        ]
    },
    {
        "id": "be57387b3dfde232",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\nlet actionState = flow.get(\"actionState\");\nactionState.state = \"RUNNING\";\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\n\n\n// flowVariable Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.payload = state;\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2250,
        "y": 260,
        "wires": [
            [
                "e020a2cfab753f17",
                "5c1ed0cb19949ac2"
            ]
        ]
    },
    {
        "id": "b9623969bdc70eb9",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "internal state txt",
        "func": "msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/state\";\nmsg.action = \"subscribe\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 1180,
        "wires": [
            [
                "1a8cfd7c9b2c646e"
            ]
        ]
    },
    {
        "id": "933971e577ec8d00",
        "type": "switch",
        "z": "2a102a482beaf61c",
        "name": "orderswitch",
        "property": "payload.action.command",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "CHECK_QUALITY",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1310,
        "y": 260,
        "wires": [
            [
                "e52f5d08aa82d9b2"
            ],
            [
                "bbf1b2ae4cd28b4f"
            ],
            [
                "1adb99c3ba20d302"
            ]
        ]
    },
    {
        "id": "e52f5d08aa82d9b2",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "PICK",
        "func": "// wenn nicht IDLE dann nichts tun\nif (flow.get(\"moduleState\") == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RPICK\"); // modulestate zu \"RUNNING PICK\" setzen\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"pick\", \"nodeId\": \"ns=4;i=4\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only PICK \"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 220,
        "wires": [
            [
                "08f8a9c64e079c45"
            ],
            [
                "7aa8d9b18fc9af30"
            ]
        ]
    },
    {
        "id": "1adb99c3ba20d302",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "CHECK_QUALITY",
        "func": "// CHECK_QUALITY\nif (flow.get(\"moduleState\") == \"WCQ\") {\n    \n    // ModulState setzen\n    flow.set(\"moduleState\", \"RCQ\"); // Running Check Quality\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"move_to_camera\", \"nodeId\": \"ns=4;i=14\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only CHECK_QUALITY\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1610,
        "y": 300,
        "wires": [
            [
                "08f8a9c64e079c45"
            ],
            [
                "7aa8d9b18fc9af30"
            ]
        ]
    },
    {
        "id": "bbf1b2ae4cd28b4f",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "DROP",
        "func": "// Drop\nif (flow.get(\"moduleState\") == \"WDROP\") {\n\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RDROP\");\n\n    // OPCUA Write Content\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"drop\", \"nodeId\": \"ns=4;i=5\", \"datatypeName\": \"Boolean\" }];\n\n    // OPCUA write Content\n    msg.payload.nodetype = \"inject\";\n    msg.payload.injectType = \"write\";\n\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate accepts only DROP\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 260,
        "wires": [
            [
                "08f8a9c64e079c45"
            ],
            [
                "7aa8d9b18fc9af30"
            ]
        ]
    },
    {
        "id": "a0154cce58c3ac0b",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "vda_status_finished PICK",
        "func": "// wenn \"TRUE\" im OPCUA und die richtige interne state\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RPICK\") {\n\n    // state\n    let state = flow.get(\"state\");\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // erfolgreich mit der NodeId\n    if (msg.payload.nodeId == \"ns=4;i=8\") {\n        flow.set(\"moduleState\", \"WCQ\");\n        actionState.state = \"FINISHED\"; // Waiting for FTS\n    }\n\n    // nicht erfolgreich mit der NodeId\n    else if (msg.payload.nodeId == \"ns=4;i=12\") {\n\n        let error = {\n            timestamp,\n            \"errorType\": \"PICK_failed\",\n            \"errorMessage\": \"PICK failed\",\n            \"errorLevel\": \"FATAL\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        actionState.state = \"FAILED\"; // FAILED PICK\n        errors.push(error);\n        flow.set(\"errors\", errors);\n        flow.set(\"moduleState\", \"IDLE\");\n    }\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1760,
        "wires": [
            [
                "ef0c06909fe7fe61",
                "4a82585a8030fd3e"
            ],
            [
                "38cdd0bca7a74edd"
            ]
        ]
    },
    {
        "id": "6344e10ed7e06e69",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "vda_status_finished DROP",
        "func": "// wenn OPCUA den Wert True liefert\nif (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RDROP\") {\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n    let headerId = flow.get(\"headerId\");\n    let actionState = flow.get(\"actionState\");\n    let state = flow.get(\"state\");\n    let flowErrors = flow.get(\"errors\") ?? [];\n    let errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // wenn drop_finished gesetzt wurde (erfolgreich)\n    if (msg.payload.nodeId == \"ns=4;i=9\") {\n        actionState.state = \"FINISHED\";\n    }\n\n    // wenn drop_failed gesetzt wurde (nicht erfolgreich)\n    else if (msg.payload.nodeId == \"ns=4;i=15\") {\n        actionState.state = \"FAILED\";\n        let error = {\n            timestamp,\n            \"errorType\": \"DROP_failed\",\n            \"errorMessage\": \"DROP failed\",\n            \"errorLevel\": \"WARNING\",\n            \"errorReferences\": [\n                { \"topic\": \"order\" },\n                { \"headerId\": flow.get(\"headerId\") },\n                { \"orderId\": flow.get(\"orderId\") },\n                { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n            ],\n        }\n        errors.push(error);\n    } else {\n        return\n    }\n\n    // state\n    state.headerId = headerId;\n    state.loads = [];\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    state.errors = errors;\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", []);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1800,
        "wires": [
            [
                "ef0c06909fe7fe61",
                "4a82585a8030fd3e"
            ],
            [
                "38cdd0bca7a74edd"
            ]
        ]
    },
    {
        "id": "1e92f737059dab78",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "vda_status_finished GOOD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RGOOD\") {\n    flow.set(\"moduleState\", \"WDROP\"); // waiting for drop\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // actionstate von order holen und anpassen\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    \n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1640,
        "y": 1880,
        "wires": [
            [
                "ef0c06909fe7fe61",
                "4a82585a8030fd3e"
            ]
        ]
    },
    {
        "id": "320bbbac587daeda",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "vda_status_finished BAD",
        "func": "if (msg.payload.value.value.value == true && flow.get(\"moduleState\") == \"RBAD\") {\n    \n    flow.set(\"moduleState\", \"IDLE\"); // return to IDLE\n    // Timestamp\n    let now = new Date();\n    let timestamp = now.toISOString();\n\n    // set actionstate\n    let actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n    let loads = [];\n\n    // state bauen\n    let state = flow.get(\"state\");\n    state.headerId = flow.get(\"headerId\");\n    state.loads = loads;\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // Flow Update\n    flow.set(\"headerId\", state.headerId + 1);\n    flow.set(\"actionState\", actionState);\n    flow.set(\"errors\", []);\n\n    flow.set(\"orderId\", \"0\");\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"loads\", loads);\n    flow.set(\"actionState\", {});\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nelse {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1630,
        "y": 1840,
        "wires": [
            [
                "ef0c06909fe7fe61",
                "4a82585a8030fd3e"
            ]
        ]
    },
    {
        "id": "55335a5640a8fd7b",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "state subscription handle",
        "func": "if (flow.get(\"moduleState\") != \"WR\") {\n    return;\n}\nlet actionStateCommand = msg.payload.actionState?.command ?? \"unknown\";\nlet actionStateState = msg.payload.actionState?.state ?? \"unknown\";\nlet result = msg.payload.actionState?.result ?? \"noResult\";\nlet actionState = flow.get(\"actionState\");\n\n//Vorbereitungen für OPCUA write\nmsg.payload.nodetype = \"inject\";\nmsg.payload.injectType = \"write\";\n\n// Fallunterscheidung für gutes oder schlechtes Werkstück\n\nif (actionStateCommand != \"CHECK_QUALITY\" || msg.payload.actionState.state != \"FINISHED\") {\n    return;\n}\n\nif (result == \"PASSED\") {\n    // Adresse für gutes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"good\", \"nodeId\": \"ns=4;i=6\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RGOOD\"); // Running Good Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else if (result == \"FAILED\") {\n    // Adresse für schlechtes Werkstück\n    msg.payload.valuesToWrite = [{ \"value\": true }];\n    msg.payload.nodesToWrite = [{ \"name\": \"bad\", \"nodeId\": \"ns=4;i=7\", \"datatypeName\": \"Boolean\" }];\n    flow.set(\"moduleState\", \"RBAD\"); // Running Bad Quality\n    actionState.result = result;\n    flow.set(\"actionState\", actionState);\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"FATAL\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Result not specified or no Result\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 1200,
        "wires": [
            [
                "e2fd42c38820666e"
            ],
            [
                "38cdd0bca7a74edd"
            ]
        ]
    },
    {
        "id": "31ca015f71eb566a",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "internal connection txt",
        "func": "const spsSerialNumber = flow.get(\"serialNumber\");\nflow.set('TXT_MQTT_topic', `module/v1/ff/NodeRed/${spsSerialNumber}`);\n\nmsg.topic = flow.get(\"TXT_MQTT_topic\") + \"/instantAction\";\nmsg.payload = {\n    \"host\": spsSerialNumber,\n    \"serialNumber\": spsSerialNumber,\n    \"timestamp\": new Date().toISOString(),\n    \"actions\": [\n        {\n            \"actionId\": \"SOME_ID\",\n            \"actionType\": \"factsheetRequest\",\n            \"metadata\": {}\n        }\n    ]\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 1120,
        "wires": [
            [
                "b9623969bdc70eb9",
                "57d6c8e571728e65"
            ]
        ]
    },
    {
        "id": "1a8cfd7c9b2c646e",
        "type": "mqtt in",
        "z": "2a102a482beaf61c",
        "name": "dynamic Connection",
        "topic": "",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 1,
        "x": 1390,
        "y": 1180,
        "wires": [
            [
                "55335a5640a8fd7b"
            ]
        ]
    },
    {
        "id": "e2fd42c38820666e",
        "type": "OPCUA-IIoT-Write",
        "z": "2a102a482beaf61c",
        "connector": "712b60d60ce311d2",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 2090,
        "y": 1180,
        "wires": [
            []
        ]
    },
    {
        "id": "3b11f7bf96cdccfd",
        "type": "change",
        "z": "2a102a482beaf61c",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "c245af51c7e7e770",
        "type": "change",
        "z": "2a102a482beaf61c",
        "name": "OPCUA state PICK",
        "rules": [
            {
                "t": "set",
                "p": "pick_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 1760,
        "wires": [
            []
        ]
    },
    {
        "id": "43bd63c88085a460",
        "type": "change",
        "z": "2a102a482beaf61c",
        "name": "OPCUA state DROP",
        "rules": [
            {
                "t": "set",
                "p": "drop_failed",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1240,
        "y": 1720,
        "wires": [
            []
        ]
    },
    {
        "id": "61d126cba29d4057",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nconst factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 520,
        "wires": [
            [
                "da76d2f9b15675b9",
                "d6a692ce4bd9e961"
            ]
        ]
    },
    {
        "id": "46a56617db3448c4",
        "type": "OPCUA-IIoT-Browser",
        "z": "2a102a482beaf61c",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "712b60d60ce311d2",
        "x": 460,
        "y": 1840,
        "wires": [
            [
                "c5f364dcdc7522ad",
                "d82b7c38113ffa98",
                "88276714437fb877",
                "adfa196979fef958"
            ]
        ]
    },
    {
        "id": "c5f364dcdc7522ad",
        "type": "OPCUA-IIoT-Listener",
        "z": "2a102a482beaf61c",
        "connector": "712b60d60ce311d2",
        "action": "subscribe",
        "queueSize": "20",
        "name": "",
        "topic": "",
        "justValue": false,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": true,
        "x": 640,
        "y": 1840,
        "wires": [
            [
                "771281b6e7e1cacb",
                "adfa196979fef958"
            ]
        ]
    },
    {
        "id": "d82b7c38113ffa98",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 1640,
        "wires": []
    },
    {
        "id": "11ddc4991064b622",
        "type": "OPCUA-IIoT-Inject",
        "z": "2a102a482beaf61c",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 250,
        "y": 1840,
        "wires": [
            [
                "46a56617db3448c4"
            ]
        ]
    },
    {
        "id": "88276714437fb877",
        "type": "change",
        "z": "2a102a482beaf61c",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 860,
        "y": 1680,
        "wires": [
            []
        ]
    },
    {
        "id": "ef0c06909fe7fe61",
        "type": "link out",
        "z": "2a102a482beaf61c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2285,
        "y": 1860,
        "wires": []
    },
    {
        "id": "6a8d668d01d461d9",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "Finish listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1150,
        "y": 1620,
        "wires": []
    },
    {
        "id": "4a82585a8030fd3e",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "FINISHED_STATE_msg",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2190,
        "y": 1580,
        "wires": []
    },
    {
        "id": "df4030ce6ba2ce82",
        "type": "subflow:6a25ecd632542087",
        "z": "2a102a482beaf61c",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-aiqs.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "ff3229ebcc44360c"
            ]
        ]
    },
    {
        "id": "063467ae6e46d7b3",
        "type": "subflow:1b897516f5bf21fa",
        "z": "2a102a482beaf61c",
        "name": "",
        "x": 580,
        "y": 260,
        "wires": [
            [
                "525aaa331702e522",
                "45fbaa9aaddf00a5"
            ],
            [
                "6a96814a7817bc08"
            ],
            [
                "6ca9009a9544b085",
                "e020a2cfab753f17"
            ],
            [
                "31ca015f71eb566a"
            ]
        ]
    },
    {
        "id": "da76d2f9b15675b9",
        "type": "link out",
        "z": "2a102a482beaf61c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2515,
        "y": 520,
        "wires": []
    },
    {
        "id": "6a96814a7817bc08",
        "type": "switch",
        "z": "2a102a482beaf61c",
        "name": "instantActionSwitch",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "factsheetRequest",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "startCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "storeCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "selectCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "testCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "resetCalibration",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "reset",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 970,
        "y": 660,
        "wires": [
            [
                "61d126cba29d4057"
            ],
            [
                "f0fcdd3221413632"
            ],
            [
                "cf16d807c903526e"
            ],
            [
                "95b3789371a68d78"
            ],
            [
                "af616d3e4c8db29a"
            ],
            [
                "4876feb760569f69"
            ],
            [
                "cb67fc157e718290",
                "a6be67d2813c9253"
            ],
            [
                "89bab3bfd6d2648e"
            ],
            [
                "1c1373f6b9725823"
            ]
        ]
    },
    {
        "id": "7aa8d9b18fc9af30",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 320,
        "wires": [
            [
                "e020a2cfab753f17",
                "8977180d36c986b6"
            ]
        ]
    },
    {
        "id": "e020a2cfab753f17",
        "type": "link out",
        "z": "2a102a482beaf61c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2475,
        "y": 300,
        "wires": []
    },
    {
        "id": "26bd923618076388",
        "type": "link out",
        "z": "2a102a482beaf61c",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2255,
        "y": 1360,
        "wires": []
    },
    {
        "id": "38cdd0bca7a74edd",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2110,
        "y": 1360,
        "wires": [
            [
                "26bd923618076388"
            ]
        ]
    },
    {
        "id": "f0fcdd3221413632",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "startCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {ReferenceData[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            const refData = createReferenceData(nodeName, nodeValue);\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\" || moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"CALIBRATION\");\n\n    const isCalibActive = flow.get(\"calibration.state.status__kalibAktiv.nodeValue\") ?? false;\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.modulePaused = true;\n    msg.operatingMode = \"TEACHIN\";\n    msg.actionCommand = \"startCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=16\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: !isCalibActive }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not IDLE and cannot be set to CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 620,
        "wires": [
            [
                "7a691cfe07e7a9fb",
                "c2e1dfc750e42fe8"
            ],
            [
                "eac37612cbcb7347"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "eac37612cbcb7347",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 760,
        "wires": [
            [
                "da76d2f9b15675b9"
            ]
        ]
    },
    {
        "id": "cf16d807c903526e",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "stopCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"state.information\", []);\n\n    msg.actionCommand = \"stopCalibration\";\n    msg.calibrationData = [];\n    msg.modulePaused = false;\n    msg.operatingMode = \"AUTOMATIC\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 660,
        "wires": [
            [
                "5055f51eee1897d4",
                "c2e1dfc750e42fe8"
            ],
            [
                "eac37612cbcb7347"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "5055f51eee1897d4",
        "type": "OPCUA-IIoT-Write",
        "z": "2a102a482beaf61c",
        "connector": "712b60d60ce311d2",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 680,
        "wires": [
            [
                "a7f8dbdca4eca760",
                "6994267b1f3d7117"
            ]
        ]
    },
    {
        "id": "95b3789371a68d78",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "setCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"setCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 700,
        "wires": [
            [
                "c2e1dfc750e42fe8",
                "7a691cfe07e7a9fb"
            ],
            [
                "eac37612cbcb7347"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "af616d3e4c8db29a",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "storeCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: toUpdate.nodeValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"storeCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 740,
        "wires": [
            [
                "c2e1dfc750e42fe8",
                "7a691cfe07e7a9fb"
            ],
            [
                "eac37612cbcb7347"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "4876feb760569f69",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "selectCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    if (currentPosition?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (currentPosition) {\n            case \"TO_NIO_BIN\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitAusschuss.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                const nodeValue = flow.get(\"calibration.state.calib__zeitKamera.nodeValue\") ?? 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"CHECK\": {\n                const nodeValue = 0;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                // We stop the movement, if the workpiece is detected by the photoelectric sensor\n                const nodeValue = 60000;\n                nodesToWrite = [{ nodeId: \"ns=4;i=23\", \"datatypeName\": \"Int32\" }];\n                valuesToWrite = [{ value: nodeValue }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        createError(`${metadata.position} is not a valid position`);\n        return [null, msg];\n    }\n\n    const newPosition = metadata.position;\n    flow.set(\"calibration.positions.current\", newPosition);\n\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"selectCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 780,
        "wires": [
            [
                "c2e1dfc750e42fe8",
                "7a691cfe07e7a9fb"
            ],
            [
                "eac37612cbcb7347"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "cb67fc157e718290",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "testCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {Reference[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n * \n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @param {string} newCurrentPosition\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions(newCurrentPosition) {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": newCurrentPosition },\n        ]\n    }\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.position?.length > 0) {\n        let nodesToWrite = [];\n        let valuesToWrite = [];\n\n        switch (metadata.position) {\n            case \"TO_NIO_BIN\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"TO_CAMERA\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n            case \"CHECK\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=22\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: false }];\n                break;\n            }\n            case \"TO_PICKUP\": {\n                nodesToWrite = [{ nodeId: \"ns=4;i=25\", \"datatypeName\": \"Boolean\" }];\n                valuesToWrite = [{ value: true }];\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions(metadata)];\n    msg.actionCommand = \"testCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 820,
        "wires": [
            [
                "5055f51eee1897d4",
                "c2e1dfc750e42fe8"
            ],
            [
                "eac37612cbcb7347"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "89bab3bfd6d2648e",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "resetCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    msg.actionCommand = \"resetCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=20\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 860,
        "wires": [
            [
                "5055f51eee1897d4",
                "c2e1dfc750e42fe8"
            ],
            [
                "eac37612cbcb7347"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "b6809bd9b97165a8",
        "type": "catch",
        "z": "2a102a482beaf61c",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 140,
        "wires": [
            [
                "c1326069954e1cfd"
            ]
        ]
    },
    {
        "id": "c1326069954e1cfd",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 390,
        "y": 140,
        "wires": []
    },
    {
        "id": "525aaa331702e522",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "update-action-state",
        "func": "let orderAction = msg.orderAction;\n\n// get current actionState \nlet actionState = {};\nactionState.command = orderAction.command;\nactionState.id = orderAction.id;\nactionState.metadata = orderAction.metadata;\n\n// actionState in Flow speichern\nflow.set(\"actionState\", actionState);\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 260,
        "wires": [
            [
                "933971e577ec8d00",
                "f748fb2dd7d4e6e9"
            ]
        ]
    },
    {
        "id": "45fbaa9aaddf00a5",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "Order To Handle",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 160,
        "wires": []
    },
    {
        "id": "f748fb2dd7d4e6e9",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "updated state message",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1230,
        "y": 160,
        "wires": []
    },
    {
        "id": "d40cd6a280276c2c",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "After Write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2150,
        "y": 180,
        "wires": []
    },
    {
        "id": "8977180d36c986b6",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "Publish error",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2230,
        "y": 380,
        "wires": []
    },
    {
        "id": "5c1ed0cb19949ac2",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "Publish running",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2480,
        "y": 160,
        "wires": []
    },
    {
        "id": "6ca9009a9544b085",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "Errors after subflow",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 910,
        "y": 320,
        "wires": []
    },
    {
        "id": "7a691cfe07e7a9fb",
        "type": "OPCUA-IIoT-Write",
        "z": "2a102a482beaf61c",
        "connector": "712b60d60ce311d2",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 620,
        "wires": [
            [
                "22aeb9f00cfea811",
                "a7f8dbdca4eca760"
            ]
        ]
    },
    {
        "id": "22aeb9f00cfea811",
        "type": "delay",
        "z": "2a102a482beaf61c",
        "name": "",
        "pauseType": "delay",
        "timeout": "1.5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 620,
        "wires": [
            [
                "5092ed9e5bdfa633"
            ]
        ]
    },
    {
        "id": "5092ed9e5bdfa633",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "update-calibration-data",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nmsg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2000,
        "y": 620,
        "wires": [
            [
                "e23fb4d2138b5c11"
            ]
        ]
    },
    {
        "id": "e23fb4d2138b5c11",
        "type": "subflow:fb6b02d4d9963179",
        "z": "2a102a482beaf61c",
        "name": "",
        "x": 2250,
        "y": 620,
        "wires": [
            [
                "da76d2f9b15675b9"
            ]
        ]
    },
    {
        "id": "d6a692ce4bd9e961",
        "type": "subflow:fb6b02d4d9963179",
        "z": "2a102a482beaf61c",
        "name": "",
        "x": 1720,
        "y": 500,
        "wires": [
            [
                "da76d2f9b15675b9"
            ]
        ]
    },
    {
        "id": "adfa196979fef958",
        "type": "subflow:7173b966cb38f0e0",
        "z": "2a102a482beaf61c",
        "name": "",
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "value": "TO_CAMERA,TO_NIO_BIN,TO_PICKUP,CALIBRATION_TESTIMAGE",
                "type": "str"
            },
            {
                "name": "CURRENT_POSITION",
                "value": "TO_PICKUP",
                "type": "str"
            }
        ],
        "x": 870,
        "y": 1720,
        "wires": []
    },
    {
        "id": "c2e1dfc750e42fe8",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "before-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 560,
        "wires": []
    },
    {
        "id": "a7f8dbdca4eca760",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "name": "after-write",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1840,
        "y": 560,
        "wires": []
    },
    {
        "id": "869eb6ffd9b6f852",
        "type": "subflow:07a7fc5bcd60a12a",
        "z": "2a102a482beaf61c",
        "name": "",
        "x": 2250,
        "y": 680,
        "wires": [
            [
                "da76d2f9b15675b9"
            ]
        ]
    },
    {
        "id": "6994267b1f3d7117",
        "type": "delay",
        "z": "2a102a482beaf61c",
        "name": "",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1810,
        "y": 680,
        "wires": [
            [
                "869eb6ffd9b6f852"
            ]
        ]
    },
    {
        "id": "3e6dc1ec1d4b7727",
        "type": "function",
        "z": "2a102a482beaf61c",
        "g": "5456ca6e757fd98c",
        "name": "Nachricht für Controller mit Cam",
        "func": "let moduleState = flow.get(\"moduleState\");\nlet value = msg.payload.value.value.value;\n\nif (value != true) {\n    return;\n} else {\n    if (moduleState != \"RCQ\") {\n        msg.payload = {\n            \"value\": value,\n            \"moduleState\": moduleState\n        };\n        return msg;\n    } else {\n        // modulestate auf waiting for Result\n        flow.set(\"moduleState\", \"WR\");\n        let actionState = flow.get(\"actionState\");\n        let action = {};\n        action.command = actionState.command;\n        action.id = actionState.id;\n        action.metadata = actionState.metadata;\n        \n        // Timestamp\n        let now = new Date();\n        let timestamp = now.toISOString();\n\n        // Nachricht an den Controller mit Kamera\n        msg.payload = {\n            \"serialNumber\": flow.get(\"serialNumber\"),\n            \"orderId\": flow.get(\"orderId\"),\n            \"orderUpdateId\": flow.get(\"orderUpdateId\" ) + 10,\n            \"timestamp\": timestamp,\n            \"action\": action\n        }\n\n        msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/order\";\n\n        return msg;\n    }\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1410,
        "y": 1980,
        "wires": [
            [
                "d7cf5c1c7eb941da",
                "f4d035248a74db5b"
            ]
        ]
    },
    {
        "id": "d7cf5c1c7eb941da",
        "type": "debug",
        "z": "2a102a482beaf61c",
        "g": "5456ca6e757fd98c",
        "name": "order to TXT",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1650,
        "y": 1960,
        "wires": []
    },
    {
        "id": "f4d035248a74db5b",
        "type": "link out",
        "z": "2a102a482beaf61c",
        "g": "5456ca6e757fd98c",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1775,
        "y": 1980,
        "wires": []
    },
    {
        "id": "11d42c1894748abb",
        "type": "subflow:105d02aba31c4a1d",
        "z": "2a102a482beaf61c",
        "g": "dc41eb65e9d073ae",
        "x": 1390,
        "y": 2080,
        "wires": [
            [
                "b59e7bd20a2a8685"
            ]
        ]
    },
    {
        "id": "b59e7bd20a2a8685",
        "type": "subflow:fb6b02d4d9963179",
        "z": "2a102a482beaf61c",
        "g": "dc41eb65e9d073ae",
        "name": "",
        "x": 1660,
        "y": 2080,
        "wires": [
            [
                "ef0c06909fe7fe61"
            ]
        ]
    },
    {
        "id": "0a3f05f5b2f69deb",
        "type": "OPCUA-IIoT-Inject",
        "z": "2a102a482beaf61c",
        "g": "ffcb1614f967f203",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 440,
        "wires": [
            [
                "1923fe0a5404d562",
                "5a76ea7d68985e91"
            ]
        ]
    },
    {
        "id": "1923fe0a5404d562",
        "type": "OPCUA-IIoT-Read",
        "z": "2a102a482beaf61c",
        "g": "ffcb1614f967f203",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "712b60d60ce311d2",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 400,
        "wires": [
            [
                "5a76ea7d68985e91"
            ]
        ]
    },
    {
        "id": "5a76ea7d68985e91",
        "type": "subflow:468f2460ce66f11e",
        "z": "2a102a482beaf61c",
        "g": "ffcb1614f967f203",
        "name": "",
        "x": 590,
        "y": 440,
        "wires": [
            [
                "e020a2cfab753f17"
            ]
        ]
    },
    {
        "id": "a6be67d2813c9253",
        "type": "function",
        "z": "2a102a482beaf61c",
        "g": "baaef4559a65316c",
        "name": "Order to take Picture",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    return {\n        topic: flow.get(\"TXT_MQTT_topic\") + \"/order\",\n        payload: {\n            serialNumber: flow.get(\"serialNumber\"),\n            orderId: `CHECK_QUALITY__${Date.now()}`,\n            orderUpdateId: Math.floor(Math.random() * 10),\n            timestamp: new Date().toISOString(),\n            action: {\n                id: `CHECK_QUALITY__${Date.now()}`,\n                command: \"CHECK_QUALITY\",\n                metadata: {}\n            },\n        }\n    };\n    return msg;\n} else {\n    // Ignore Message, if Module is not in calibration mode\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 980,
        "wires": [
            [
                "e6e147eb63c68172"
            ]
        ]
    },
    {
        "id": "e6e147eb63c68172",
        "type": "link out",
        "z": "2a102a482beaf61c",
        "g": "baaef4559a65316c",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1455,
        "y": 980,
        "wires": []
    },
    {
        "id": "5f4c9c188fde2f2a",
        "type": "OPCUA-IIoT-Inject",
        "z": "2a102a482beaf61c",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=45",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 260,
        "wires": [
            [
                "30bc65fba56d80cb"
            ]
        ]
    },
    {
        "id": "ff3229ebcc44360c",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"AIQS\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"AIQS\");\nflow.set(\"errors\", []);\n\n// state bauen\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.74\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\n\nflow.set(\"opcuaState\", \"connected\");\nreturn ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "1c1373f6b9725823",
        "type": "function",
        "z": "2a102a482beaf61c",
        "name": "reset",
        "func": "msg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: \"ns=4;i=18\", \"datatypeName\": \"Boolean\" }\n    ],\n    valuesToWrite: [\n        { value: true }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 900,
        "wires": [
            [
                "3b224a2098dceb7b",
                "c2e1dfc750e42fe8"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite"
        ]
    },
    {
        "id": "3b224a2098dceb7b",
        "type": "OPCUA-IIoT-Write",
        "z": "2a102a482beaf61c",
        "connector": "8b41c5e43074a4eb",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1650,
        "y": 900,
        "wires": [
            [
                "a7f8dbdca4eca760"
            ]
        ]
    },
    {
        "id": "57d6c8e571728e65",
        "type": "link out",
        "z": "2a102a482beaf61c",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 955,
        "y": 1120,
        "wires": []
    },
    {
        "id": "aaed958c7022b10a",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"HBW\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"HBW\");\nflow.set(\"errors\", []);\n\n// state bauen\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"operatingMode\": \"AUTOMATIC\",\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    },\n    \"information\": []\n});\n\nconst factsheet = msg.factsheet ?? {};\nfactsheet.serialNumber = \"Unknown\";\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.80\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\n\nflow.set(\"opcuaState\", \"connected\");\nreturn ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "f9927dfe37e8e27f",
        "type": "subflow:6a25ecd632542087",
        "z": "2ad740b531e49822",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-hbw.json",
                "type": "str"
            }
        ],
        "x": 190,
        "y": 100,
        "wires": [
            [
                "aaed958c7022b10a"
            ]
        ]
    },
    {
        "id": "fcf77a9845f76f41",
        "type": "OPCUA-IIoT-Listener",
        "z": "2ad740b531e49822",
        "connector": "42eb75176feb84b0",
        "action": "subscribe",
        "queueSize": "30",
        "name": "",
        "topic": "",
        "justValue": true,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 620,
        "y": 940,
        "wires": [
            [
                "c3e119d9757fd050",
                "c5ccb16a81f4f566",
                "6fefc60673edaf63",
                "ba8ec3da0014670a"
            ]
        ]
    },
    {
        "id": "97970d1b5a4c3c3f",
        "type": "OPCUA-IIoT-Inject",
        "z": "2ad740b531e49822",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=116",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=315",
                "datatypeName": "String"
            }
        ],
        "x": 210,
        "y": 240,
        "wires": [
            [
                "b5a607c13baf1586"
            ]
        ]
    },
    {
        "id": "b5a607c13baf1586",
        "type": "OPCUA-IIoT-Read",
        "z": "2ad740b531e49822",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "42eb75176feb84b0",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 470,
        "y": 240,
        "wires": [
            [
                "3a878b74d6a4ddd4"
            ]
        ]
    },
    {
        "id": "3757839fcde6c5fd",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "vda_status_finished PICK",
        "func": "const nodeValue = msg.payload.value.value.value;\nconst moduleStsate = flow.get(\"moduleState\");\nif (nodeValue == true && moduleStsate == \"RPICK\") {\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n    const actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"moduleState\", \"IDLE\");\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 1060,
        "wires": [
            [
                "b75beea52e4f9c13",
                "1d48fde7b9bf2caa"
            ]
        ]
    },
    {
        "id": "c3e119d9757fd050",
        "type": "switch",
        "z": "2ad740b531e49822",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=57",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=258",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=256",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=246",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=247",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=250",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=260",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=242",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=243",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 810,
        "y": 1020,
        "wires": [
            [
                "06bd3b4c3025c317"
            ],
            [
                "acc18ffddbc90490"
            ],
            [],
            [
                "9d9c6f288ab91c24"
            ],
            [
                "9d9c6f288ab91c24",
                "8b0eeac95fdcb351"
            ],
            [],
            [
                "acc18ffddbc90490"
            ],
            [
                "9d9c6f288ab91c24"
            ],
            [
                "9d9c6f288ab91c24",
                "3757839fcde6c5fd"
            ]
        ],
        "outputLabels": [
            "busy",
            "anfahren_beendet",
            "default_beendet",
            "drop_aktiv",
            "drop_finished",
            "kalib_aktiv",
            "kalib_finished",
            "pick_aktiv",
            "pick_finished"
        ]
    },
    {
        "id": "8b0eeac95fdcb351",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "vda_status_finished DROP",
        "func": "const nodeValue = msg.payload.value.value.value;\nconst moduleState = flow.get(\"moduleState\");\nif (nodeValue == true && moduleState == \"RDROP\") {\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n    const actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\";\n    // get the workpieceId from the flow state (set during initial determination of the rack position)\n    let workpieceId = flow.get(\"workpieceId\");\n    // unknown should never happen if a workpiece is introduced via DPS\n    actionState.result = workpieceId ?? \"unknown\"; \n\n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"workpieceId\", undefined);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 1020,
        "wires": [
            [
                "b75beea52e4f9c13",
                "1d48fde7b9bf2caa"
            ]
        ]
    },
    {
        "id": "b75beea52e4f9c13",
        "type": "debug",
        "z": "2ad740b531e49822",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1820,
        "y": 1020,
        "wires": []
    },
    {
        "id": "06bd3b4c3025c317",
        "type": "change",
        "z": "2ad740b531e49822",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_busy",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1270,
        "y": 940,
        "wires": [
            []
        ]
    },
    {
        "id": "c5ccb16a81f4f566",
        "type": "debug",
        "z": "2ad740b531e49822",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 810,
        "y": 820,
        "wires": []
    },
    {
        "id": "f8df7c7885fd966b",
        "type": "OPCUA-IIoT-Browser",
        "z": "2ad740b531e49822",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": "1",
        "delayPerMessage": 0.2,
        "connector": "42eb75176feb84b0",
        "x": 440,
        "y": 940,
        "wires": [
            [
                "fcf77a9845f76f41",
                "e3b010195a40d201",
                "f90c5b5b41e4ad38",
                "6fefc60673edaf63",
                "1c606ec89e040197",
                "fe3c38b0771ffa45",
                "d3478dc5191e8ecd",
                "88202721928d9afe",
                "c0c9c7b876e18fb7",
                "771f75df45224559",
                "1848f823945822f9",
                "f55387242780d0e0",
                "9c0fad6b6b01de80"
            ]
        ]
    },
    {
        "id": "0d73eef90c957f23",
        "type": "OPCUA-IIoT-Inject",
        "z": "2ad740b531e49822",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "hbw",
        "addressSpaceItems": [],
        "x": 290,
        "y": 940,
        "wires": [
            [
                "f8df7c7885fd966b"
            ]
        ]
    },
    {
        "id": "e3b010195a40d201",
        "type": "debug",
        "z": "2ad740b531e49822",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 800,
        "y": 780,
        "wires": []
    },
    {
        "id": "f90c5b5b41e4ad38",
        "type": "change",
        "z": "2ad740b531e49822",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 820,
        "y": 860,
        "wires": [
            []
        ]
    },
    {
        "id": "1d48fde7b9bf2caa",
        "type": "link out",
        "z": "2ad740b531e49822",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1985,
        "y": 1100,
        "wires": []
    },
    {
        "id": "3a878b74d6a4ddd4",
        "type": "subflow:1b897516f5bf21fa",
        "z": "2ad740b531e49822",
        "name": "",
        "x": 750,
        "y": 240,
        "wires": [
            [
                "1cd6c4140e7c4e7a"
            ],
            [
                "af718d4f89dcb1f5"
            ],
            [
                "5d0c19257761e5cf"
            ],
            []
        ]
    },
    {
        "id": "d3a7be281851ea48",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nlet factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 420,
        "wires": [
            [
                "349824aaaa43c43d",
                "5d0c19257761e5cf"
            ]
        ]
    },
    {
        "id": "6299e10365010d76",
        "type": "link out",
        "z": "2ad740b531e49822",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2345,
        "y": 640,
        "wires": []
    },
    {
        "id": "af718d4f89dcb1f5",
        "type": "switch",
        "z": "2ad740b531e49822",
        "name": "instantActionSwitch",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "factsheetRequest",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "startCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "storeCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "selectCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "testCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "resetCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "SET_STORAGE",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "reset",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 10,
        "x": 990,
        "y": 520,
        "wires": [
            [
                "d3a7be281851ea48"
            ],
            [
                "2a787b06bb3595cf"
            ],
            [
                "81d4a69f93f32cea"
            ],
            [
                "54e4e5bfd7740d12"
            ],
            [
                "cd570a686172ed49"
            ],
            [
                "849209fa3e9e0ae7"
            ],
            [
                "8e3b81245cc46127"
            ],
            [
                "9743756ff01d6a48"
            ],
            [
                "83c90a18acb9a6c9"
            ],
            [
                "4a16f4c01177cedd"
            ]
        ]
    },
    {
        "id": "2a787b06bb3595cf",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "startCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {ReferenceData[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            const refData = createReferenceData(nodeName, nodeValue);\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\" || moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"CALIBRATION\");\n\n    const isCalibActive = flow.get(\"calibration.state.status__kalibAktiv.nodeValue\") ?? false;\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.modulePaused = true;\n    msg.operatingMode = \"TEACHIN\";\n    msg.actionCommand = \"startCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=251\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: !isCalibActive }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not IDLE and cannot be set to CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 480,
        "wires": [
            [
                "3b3f8cb9e09473d1",
                "18f8cc93b5036c87"
            ],
            [
                "37f071027f4bacb4"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "37f071027f4bacb4",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1730,
        "y": 640,
        "wires": [
            [
                "6299e10365010d76"
            ]
        ]
    },
    {
        "id": "81d4a69f93f32cea",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "stopCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"state.information\", []);\n\n    msg.actionCommand = \"stopCalibration\";\n    msg.calibrationData = [];\n    msg.modulePaused = false;\n    msg.operatingMode = \"AUTOMATIC\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=259\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 520,
        "wires": [
            [
                "a23ba60c96e906cf",
                "18f8cc93b5036c87"
            ],
            [
                "37f071027f4bacb4"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "a23ba60c96e906cf",
        "type": "OPCUA-IIoT-Write",
        "z": "2ad740b531e49822",
        "connector": "42eb75176feb84b0",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1710,
        "y": 520,
        "wires": [
            [
                "72814b1293a95903",
                "430dd01d357069c8"
            ]
        ]
    },
    {
        "id": "54e4e5bfd7740d12",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "setCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n */\nfunction createError(message) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", error);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"setCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 560,
        "wires": [
            [
                "3b3f8cb9e09473d1",
                "18f8cc93b5036c87"
            ],
            [
                "37f071027f4bacb4"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "cd570a686172ed49",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "storeCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n */\nfunction createError(message) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", error);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: toUpdate.nodeValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"storeCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 680,
        "wires": [
            [
                "3b3f8cb9e09473d1",
                "18f8cc93b5036c87"
            ],
            [
                "37f071027f4bacb4"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "849209fa3e9e0ae7",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "selectCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/** @type {Record<string, PositionTargetData>} */\nconst positions = {\n    \"REF\": {\n        \"befehl__anfahren_position_dreh\": 0,\n        \"befehl__anfahren_position_x\": 0,\n        \"befehl__anfahren_position_y\": 0,\n    },\n    \"RACK_REIHE_A_SPALTE_1\": {\n        \"befehl__anfahren_position_dreh\": undefined,\n        \"befehl__anfahren_position_x\": \"kalib__spalte_1\",\n        \"befehl__anfahren_position_y\": \"kalib__reihe_A\"\n    },\n    \"RACK_REIHE_B_SPALTE_2\": {\n        \"befehl__anfahren_position_dreh\": undefined,\n        \"befehl__anfahren_position_x\": \"kalib__spalte_2\",\n        \"befehl__anfahren_position_y\": \"kalib__reihe_B\",\n    },\n    \"RACK_REIHE_C_SPALTE_3\": {\n        \"befehl__anfahren_position_dreh\": undefined,\n        \"befehl__anfahren_position_x\": \"kalib__spalte_3\",\n        \"befehl__anfahren_position_y\": \"kalib__reihe_C\"\n    },\n    \"RAMPE\": {\n        \"befehl__anfahren_position_dreh\": \"kalib__rampe_position_dreh\",\n        \"befehl__anfahren_position_x\": \"kalib__rampe_position_X\",\n        \"befehl__anfahren_position_y\": \"kalib__rampe_position_Y\"\n    },\n    \"PICK\": {\n        \"befehl__anfahren_position_dreh\": \"kalib__FTS_position_Dreh\",\n        \"befehl__anfahren_position_x\": undefined,\n        \"befehl__anfahren_position_y\": undefined,\n    },\n    \"DROP\": {\n        \"befehl__anfahren_position_dreh\": \"kalib__FTS_position_Dreh\",\n        \"befehl__anfahren_position_x\": undefined,\n        \"befehl__anfahren_position_y\": undefined,\n    },\n};\n\n/**\n * @param {string} message\n */\nfunction createError(message) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", error);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @param {string} newCurrentPosition\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions(newCurrentPosition) {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": newCurrentPosition },\n        ]\n    }\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.position?.length > 0) {\n        /** @type {Reference[]} */\n        const targetRefs = [];\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        /** @type {PositionTargetData} */\n        const targetData = positions[metadata.position];\n        for (let [key, value] of Object.entries(targetData)) {\n            /** @type {Reference | null} */\n            let newRef = null;\n            if (value == undefined) {\n                continue;\n            } else if (typeof value == \"string\") {\n                const nodeValue = flow.get(`calibration.state.${value}.nodeValue`);\n                /** @type {Reference} */\n                newRef = {\n                    referenceKey: key,\n                    referenceValue: nodeValue,\n                };\n            } else {\n                /** @type {Reference} */\n                newRef = {\n                    referenceKey: key,\n                    referenceValue: value,\n                };\n            }\n            targetRefs.push(newRef);\n        }\n\n        for (let { referenceKey, referenceValue } of targetRefs) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaPark() {\n    return {\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=316\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        createError(`${metadata.position} is not a valid position`);\n        return [null, msg];\n    }\n\n    const newPosition = metadata.position;\n    flow.set(\"calibration.positions.current\", newPosition);\n\n    const newData = (newPosition == \"PARK\") ? createOpcuaPark() : createOpcuaUpdate(metadata);\n    const { nodesToWrite, valuesToWrite } = newData;\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions(newPosition)];\n    msg.actionCommand = \"selectCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1330,
        "y": 600,
        "wires": [
            [
                "3b3f8cb9e09473d1",
                "18f8cc93b5036c87"
            ],
            [
                "37f071027f4bacb4"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "8e3b81245cc46127",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "testCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {Reference[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n * \n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    return {\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=257\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"testCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 640,
        "wires": [
            [
                "a23ba60c96e906cf",
                "18f8cc93b5036c87"
            ],
            [
                "37f071027f4bacb4"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "9743756ff01d6a48",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "resetCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    msg.actionCommand = \"resetCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=255\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 720,
        "wires": [
            [
                "3b3f8cb9e09473d1",
                "18f8cc93b5036c87"
            ],
            [
                "37f071027f4bacb4"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "87cffef8bba52f33",
        "type": "OPCUA-IIoT-Write",
        "z": "2ad740b531e49822",
        "connector": "42eb75176feb84b0",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1670,
        "y": 160,
        "wires": [
            [
                "6a4d7967d3c61057",
                "5da5e82bdec5d169"
            ]
        ]
    },
    {
        "id": "a400034b458562d5",
        "type": "switch",
        "z": "2ad740b531e49822",
        "name": "orderswitch",
        "property": "order",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1230,
        "y": 200,
        "wires": [
            [
                "dc0a9a6578ca89f7"
            ],
            [
                "3ff8bd1c0fa20ecc"
            ]
        ]
    },
    {
        "id": "dc0a9a6578ca89f7",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "PICK",
        "func": "/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @typedef {object} RackPosition\n * @property {{\"#address\": string, value: string }} name\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n * @property {{\"#address\": string, value: string}} workpieceId\n */\n\nfunction getEmptyRackPositions() {\n    /** @type Record<string, RackPosition> */\n    const rackPositions = flow.get(\"rack.positions\") ?? {};\n    return Object.keys(rackPositions)\n        .sort((a, b) => {\n            const letterA = a.charAt(0);\n            const letterB = b.charAt(0);\n            const numberA = parseInt(a.substring(1));\n            const numberB = parseInt(b.substring(1));\n\n            if (numberA === numberB) {\n                return letterA.localeCompare(letterB);\n            } else {\n                return numberA - numberB;\n            }\n        })\n        .map(k => rackPositions[k])\n        .filter(r => r.belegt?.value == false);\n}\n\n/**\n * @param {string} type\n * @param {string} workpieceId\n * @return {{valuesToWrite: Array<object>, nodesToWrite: Array<object>}}\n */\nfunction createPickCommand(type, workpieceId) {\n    const emptyRackPositions = getEmptyRackPositions();\n    const emptyRackPosition = emptyRackPositions[0];\n    node.status({ fill: \"grey\", shape: \"dot\", text: emptyRackPosition?.name?.value ?? \"UNKNOWN\" });\n    if (!emptyRackPosition) {\n        throw new Error(\"No empty rack\");\n    }\n    return {\n        nodesToWrite: [\n            { nodeId: 'ns=4;i=245' /* PICK-RACK */, \"datatypeName\": \"String\" },\n            { nodeId: 'ns=4;i=244'/* PICK */, \"datatypeName\": \"Boolean\" },\n            { nodeId: emptyRackPosition.belegt['#address'], \"datatypeName\": \"Boolean\" },\n            { nodeId: emptyRackPosition.type['#address'], \"datatypeName\": \"String\" },\n            { nodeId: emptyRackPosition.workpieceId['#address'], \"datatypeName\": \"String\" }\n        ],\n        valuesToWrite: [\n            { value: emptyRackPosition.name.value },\n            { value: true },\n            { value: true },\n            { value: type },\n            { value: workpieceId }\n        ]\n    };\n}\n\n/**\n * @typedef {object} OrderPayload\n * @property {string} timestamp\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} serialNumber\n * @property {{id: string, command: string, metadata: {type: string, workpieceId: string}}} action \n * \n * @param {OrderPayload} payload\n * @return {[type: string, workpieceId: string]}\n */\nfunction extractPickParams(payload) {\n    const actionMetadata = payload.action.metadata;\n    return [actionMetadata.type, actionMetadata.workpieceId];\n}\n\n// wenn nicht IDLE dann nichts tun\nconst currentModuleState = flow.get(\"moduleState\") ?? \"UNKNOWN\";\nnode.status({ fill: \"green\", shape: \"dot\", text: currentModuleState });\nif (currentModuleState == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RPICK\"); // modulestate zu \"RUNNING PICK\" setzen\n    node.status({ fill: \"grey\", shape: \"dot\", text: \"RPICK\" });\n\n    // Retrieve current Storage information and pick the next \n    try {\n        const [type, workpieceId] = extractPickParams(msg.payload);\n        node.status({ fill: \"green\", shape: \"dot\", text: `${type} / ${workpieceId}` });\n        const opcuaCommand = createPickCommand(type, workpieceId);\n        node.warn({ opcuaCommand });\n        msg.payload = {\n            \"nodetype\": \"inject\",\n            \"injectType\": \"write\",\n            ...opcuaCommand\n        };\n        return [msg, null];\n    } catch (err) {\n        flow.set(\"moduleState\", \"IDLE\");\n        createError(err.message);\n        return [null, msg];\n    }\n} else {\n    createError(\"Module is not IDLE\");\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Not IDLE\" });\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 140,
        "wires": [
            [
                "87cffef8bba52f33"
            ],
            [
                "a960745fe3635ec6"
            ]
        ]
    },
    {
        "id": "3ff8bd1c0fa20ecc",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "DROP",
        "func": "/**\n * @param {string} message\n * @param {\"WARNING\"|\"FATAL\"} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @typedef {object} RackPosition\n * @property {{\"#address\": string, value: string}} name\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n * @property {{\"#address\": string, value: string}} workpieceId\n */\n\n/** @param {string} type */\nfunction getRackPositionByType(type) {\n    /** @type Record<string, RackPosition> */\n    const rackPositions = flow.get(\"rack.positions\") ?? {};\n    return Object.keys(rackPositions)\n        .sort((a, b) => {\n            const letterA = a.charAt(0);\n            const letterB = b.charAt(0);\n            const numberA = parseInt(a.substring(1));\n            const numberB = parseInt(b.substring(1));\n\n            if (numberA === numberB) {\n                return letterA.localeCompare(letterB);\n            } else {\n                return numberA - numberB;\n            }\n        })\n        .map(k => rackPositions[k])\n        .filter(r => {\n            node.warn({ r });\n            return r.type?.value == type;\n        });\n}\n\n/**\n * @param {string} type\n * @return {{valuesToWrite: Array<object>, nodesToWrite: Array<object>}}\n */\nfunction createDropCommand(type) {\n    node.status({ fill: 'green', shape: 'dot', text: `${type}` });\n    const rackPositionsForType = getRackPositionByType(type);\n    node.warn({ rackPositionsForType });\n    const firstRackPositionForType = rackPositionsForType[0];\n    node.warn({ firstRackPositionForType });\n    node.status({ fill: 'gray', shape: 'dot', text: firstRackPositionForType?.name?.value ?? \"N/A\" });\n    if (!firstRackPositionForType) {\n        throw new Error(\"Type not available\");\n    }\n    // set the retrieved workpiece's ID to the flow state to access it when finishing the drop command \n    flow.set(\"workpieceId\", firstRackPositionForType?.workpieceId?.value);\n    return {\n        nodesToWrite: [\n            { nodeId: 'ns=4;i=248' /* DROP-RACK */, \"datatypeName\": \"String\" },\n            { nodeId: 'ns=4;i=249'/* DROP */, \"datatypeName\": \"Boolean\" },\n            { nodeId: firstRackPositionForType.belegt['#address'], \"datatypeName\": \"Boolean\" },\n            { nodeId: firstRackPositionForType.type['#address'], \"datatypeName\": \"String\" },\n            { nodeId: firstRackPositionForType.workpieceId['#address'], \"datatypeName\": \"String\" }\n        ],\n        valuesToWrite: [\n            { value: firstRackPositionForType.name.value },\n            { value: true },\n            { value: false },\n            { value: \"\" },\n            { value: \"\" }\n        ]\n    };\n}\n\n/**\n * @typedef {object} OrderPayload\n * @property {string} timestamp\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} serialNumber\n * @property {{id: string, command: string, metadata: {type: string, workpieceId: string}}} action \n * \n * @param {OrderPayload} payload\n * @return {string}\n */\nfunction extractDropParams(payload) {\n    const actionMetadata = payload.action.metadata;\n    return actionMetadata.type;\n}\n\n// wenn nicht IDLE dann nichts tun\nconst currentModuleState = flow.get(\"moduleState\") ?? \"UNKNOWN\";\nnode.status({ fill: \"grey\", shape: \"dot\", text: currentModuleState });\nif (currentModuleState == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RDROP\"); // modulestate zu \"RUNNING PICK\" setzen\n\n    // Retrieve current Storage information and pick the next \n    try {\n        const type = extractDropParams(msg.payload);\n        const opcuaCommand = createDropCommand(type);\n        msg.payload = {\n            \"nodetype\": \"inject\",\n            \"injectType\": \"write\",\n            ...opcuaCommand\n        };\n        return [msg, null];\n    } catch (err) {\n        flow.set(\"moduleState\", \"IDLE\");\n        createError(err.message);\n        return [null, msg];\n    }\n} else {\n    createError(\"Module is not IDLE\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 200,
        "wires": [
            [
                "87cffef8bba52f33"
            ],
            [
                "a960745fe3635ec6"
            ]
        ]
    },
    {
        "id": "1cd6c4140e7c4e7a",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "Order Update Check",
        "func": "// actionState in Flow speichern\nflow.set(\"actionState\", msg.payload.action);\n\n// orderUpdateId updaten\nflow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1020,
        "y": 200,
        "wires": [
            [
                "a400034b458562d5"
            ]
        ]
    },
    {
        "id": "a960745fe3635ec6",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"orderId\", 0);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 220,
        "wires": [
            [
                "5d0c19257761e5cf"
            ]
        ]
    },
    {
        "id": "5d0c19257761e5cf",
        "type": "link out",
        "z": "2ad740b531e49822",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2195,
        "y": 260,
        "wires": []
    },
    {
        "id": "8e56157ec61364e9",
        "type": "catch",
        "z": "2ad740b531e49822",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 180,
        "y": 160,
        "wires": [
            [
                "ee5c67ad1d1df2a6"
            ]
        ]
    },
    {
        "id": "ee5c67ad1d1df2a6",
        "type": "debug",
        "z": "2ad740b531e49822",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 410,
        "y": 160,
        "wires": []
    },
    {
        "id": "ba8ec3da0014670a",
        "type": "switch",
        "z": "2ad740b531e49822",
        "name": "update-rack-state",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=262",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=263",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=261",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=265",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=264",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=266",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=268",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=267",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=269",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=271",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=270",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=272",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=274",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=273",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=275",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=277",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=276",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=278",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=280",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=279",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=281",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=283",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=282",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=284",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=286",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=285",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=287",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 27,
        "x": 810,
        "y": 1340,
        "wires": [
            [
                "1c606ec89e040197"
            ],
            [
                "1c606ec89e040197"
            ],
            [
                "1c606ec89e040197"
            ],
            [
                "fe3c38b0771ffa45"
            ],
            [
                "fe3c38b0771ffa45"
            ],
            [
                "fe3c38b0771ffa45"
            ],
            [
                "d3478dc5191e8ecd"
            ],
            [
                "d3478dc5191e8ecd"
            ],
            [
                "d3478dc5191e8ecd"
            ],
            [
                "88202721928d9afe"
            ],
            [
                "88202721928d9afe"
            ],
            [
                "88202721928d9afe"
            ],
            [
                "c0c9c7b876e18fb7"
            ],
            [
                "c0c9c7b876e18fb7"
            ],
            [
                "c0c9c7b876e18fb7"
            ],
            [
                "771f75df45224559"
            ],
            [
                "771f75df45224559"
            ],
            [
                "771f75df45224559"
            ],
            [
                "1848f823945822f9"
            ],
            [
                "1848f823945822f9"
            ],
            [
                "1848f823945822f9"
            ],
            [
                "f55387242780d0e0"
            ],
            [
                "f55387242780d0e0"
            ],
            [
                "f55387242780d0e0"
            ],
            [
                "9c0fad6b6b01de80"
            ],
            [
                "9c0fad6b6b01de80"
            ],
            [
                "9c0fad6b6b01de80"
            ]
        ],
        "outputLabels": [
            "A1_belegt",
            "A1_type",
            "A1_workpieceId",
            "A2_belegt",
            "A2_type",
            "A2_workpieceId",
            "A3_belegt",
            "A3_type",
            "A3.workpieceId",
            "B1_belegt",
            "B1_type",
            "B1_workpieceId",
            "B2_belegt",
            "B2_type",
            "B2_workpieceId",
            "B3_belegt",
            "B3_type",
            "B3_workpieceId",
            "C1_belegt",
            "C1_type",
            "C1_workpieceId",
            "C2_belegt",
            "C2_type",
            "C2_workpieceId",
            "C3_belegt",
            "C3_type",
            "C3_workpieceId"
        ]
    },
    {
        "id": "1c606ec89e040197",
        "type": "subflow:ea935d7649fccac4",
        "z": "2ad740b531e49822",
        "name": "A1",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "A1",
                "type": "str"
            }
        ],
        "x": 1050,
        "y": 1160,
        "wires": []
    },
    {
        "id": "fe3c38b0771ffa45",
        "type": "subflow:ea935d7649fccac4",
        "z": "2ad740b531e49822",
        "name": "A2",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "A2",
                "type": "str"
            }
        ],
        "x": 1050,
        "y": 1220,
        "wires": []
    },
    {
        "id": "d3478dc5191e8ecd",
        "type": "subflow:ea935d7649fccac4",
        "z": "2ad740b531e49822",
        "name": "A3",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "A3",
                "type": "str"
            }
        ],
        "x": 1050,
        "y": 1280,
        "wires": []
    },
    {
        "id": "88202721928d9afe",
        "type": "subflow:ea935d7649fccac4",
        "z": "2ad740b531e49822",
        "name": "B1",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "B1",
                "type": "str"
            }
        ],
        "x": 1050,
        "y": 1340,
        "wires": []
    },
    {
        "id": "c0c9c7b876e18fb7",
        "type": "subflow:ea935d7649fccac4",
        "z": "2ad740b531e49822",
        "name": "B2",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "B2",
                "type": "str"
            }
        ],
        "x": 1050,
        "y": 1400,
        "wires": []
    },
    {
        "id": "771f75df45224559",
        "type": "subflow:ea935d7649fccac4",
        "z": "2ad740b531e49822",
        "name": "B3",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "B3",
                "type": "str"
            }
        ],
        "x": 1050,
        "y": 1460,
        "wires": []
    },
    {
        "id": "1848f823945822f9",
        "type": "subflow:ea935d7649fccac4",
        "z": "2ad740b531e49822",
        "name": "C1",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "C1",
                "type": "str"
            }
        ],
        "x": 1050,
        "y": 1520,
        "wires": []
    },
    {
        "id": "f55387242780d0e0",
        "type": "subflow:ea935d7649fccac4",
        "z": "2ad740b531e49822",
        "name": "C2",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "C2",
                "type": "str"
            }
        ],
        "x": 1050,
        "y": 1580,
        "wires": []
    },
    {
        "id": "9c0fad6b6b01de80",
        "type": "subflow:ea935d7649fccac4",
        "z": "2ad740b531e49822",
        "name": "C3",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "C3",
                "type": "str"
            }
        ],
        "x": 1050,
        "y": 1640,
        "wires": []
    },
    {
        "id": "5da5e82bdec5d169",
        "type": "debug",
        "z": "2ad740b531e49822",
        "name": "write-order",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1850,
        "y": 120,
        "wires": []
    },
    {
        "id": "bfb1270cf7115b83",
        "type": "inject",
        "z": "2ad740b531e49822",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.2",
        "crontab": "",
        "once": true,
        "onceDelay": "0.2",
        "topic": "rack.positions",
        "payload": "rack.positions",
        "payloadType": "flow",
        "x": 330,
        "y": 660,
        "wires": [
            [
                "e6a494ff9888dad3"
            ]
        ]
    },
    {
        "id": "e6a494ff9888dad3",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "order-rackpositions",
        "func": "const rackPositions = msg.payload ?? {};\n\nmsg.payload = Object.keys(rackPositions).reduce((sorted, key) => {\n    return {\n        ...sorted,\n        [key]: rackPositions[key]\n    }\n}, {});\nmsg.topic = \"ordered-rackpositions\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 660,
        "wires": [
            [
                "d6cd1ab8ca34e836"
            ]
        ]
    },
    {
        "id": "d6cd1ab8ca34e836",
        "type": "change",
        "z": "2ad740b531e49822",
        "name": "set-positions",
        "rules": [
            {
                "t": "set",
                "p": "rack.positions",
                "pt": "flow",
                "to": "payload",
                "tot": "msg",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 750,
        "y": 660,
        "wires": [
            []
        ]
    },
    {
        "id": "3b3f8cb9e09473d1",
        "type": "OPCUA-IIoT-Write",
        "z": "2ad740b531e49822",
        "connector": "42eb75176feb84b0",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1710,
        "y": 580,
        "wires": [
            [
                "72814b1293a95903",
                "34d58e752a0c7938"
            ]
        ]
    },
    {
        "id": "83c90a18acb9a6c9",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "set-storage",
        "func": "/**\n * @typedef {object} RackPosition\n * @property {{value: string}} name\n * @property {{\"#address\": string, value: string}} workpieceId\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n */\n\n/**\n * @typedef {object} Load\n * @property {string} loadType\n * @property {string} loadId\n * @property {string} [loadPosition]\n * \n * @param {string} rackPosition\n * @param {string} workpieceId\n * @param {string} type\n */\nfunction createLoad(rackPosition, workpieceId, type) {\n    return {\n        loadType: type,\n        loadId: workpieceId,\n        loadPosition: rackPosition,\n    };\n}\n\n/**\n * @param {Record<string, { type: string, workpieceId: string}>} contents\n * @returns {Load[]}\n */\nfunction fillLoads(contents) {\n    return Object.entries(contents).map(([key, val]) => createLoad(key, val.workpieceId ?? \"\", val.type ?? \"\"));\n}\n\n/**\n * @typedef {object} OpcuaCommand\n * @property {array} nodesToWrite\n * @property {array} valuesToWrite\n * \n * @param {Load[]} loads\n * @returns {OpcuaCommand}\n */\nfunction createOpcuaCommand(loads) {\n    const rackPositions = flow.get(\"rack.positions\") ?? {};\n    const nodesToWrite = [];\n    const valuesToWrite = [];\n\n    for (let [rackPos, entry] of Object.entries(rackPositions)) {\n        const targetLoad = loads.find(l => l.loadPosition == rackPos);\n        nodesToWrite.push({ nodeId: entry.workpieceId['#address'], datatypeName: \"String\" });\n        valuesToWrite.push({ value: targetLoad?.loadId ?? \"\" });\n        nodesToWrite.push({ nodeId: entry.type['#address'], datatypeName: \"String\" });\n        valuesToWrite.push({ value: targetLoad?.loadType ?? \"\" });\n        nodesToWrite.push({ nodeId: entry.belegt['#address'], datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: !!targetLoad && !!targetLoad?.loadType });\n    }\n\n    return { nodesToWrite, valuesToWrite };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\") {\n    const actionMetadata = msg.actionMetadata ?? { contents: {} };\n    const newLoads = fillLoads(actionMetadata.contents);\n    const { nodesToWrite, valuesToWrite } = createOpcuaCommand(newLoads);\n\n    msg.loads = newLoads;\n    msg.actionCommand = \"SET_STORAGE\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not IDLE and cannot be filled with workpieces\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1290,
        "y": 760,
        "wires": [
            [
                "3b3f8cb9e09473d1",
                "18f8cc93b5036c87"
            ],
            [
                "37f071027f4bacb4"
            ]
        ]
    },
    {
        "id": "6fefc60673edaf63",
        "type": "subflow:7173b966cb38f0e0",
        "z": "2ad740b531e49822",
        "name": "",
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "value": "REF,RACK_REIHE_A_SPALTE_1,RACK_REIHE_B_SPALTE_2,RACK_REIHE_C_SPALTE_3,RAMPE,PICK,DROP,PARK",
                "type": "str"
            },
            {
                "name": "CURRENT_POSITION",
                "value": "REF",
                "type": "str"
            }
        ],
        "x": 830,
        "y": 900,
        "wires": []
    },
    {
        "id": "72814b1293a95903",
        "type": "debug",
        "z": "2ad740b531e49822",
        "name": "after-write-order",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2000,
        "y": 640,
        "wires": []
    },
    {
        "id": "acc18ffddbc90490",
        "type": "delay",
        "z": "2ad740b531e49822",
        "name": "Verzögerung",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 1250,
        "y": 1120,
        "wires": [
            [
                "75ac0bb21e23f4e4"
            ]
        ]
    },
    {
        "id": "d3b93afcf4a3a61f",
        "type": "subflow:fb6b02d4d9963179",
        "z": "2ad740b531e49822",
        "name": "",
        "x": 2310,
        "y": 580,
        "wires": [
            [
                "6299e10365010d76"
            ]
        ]
    },
    {
        "id": "058ba4b29f9b0ee6",
        "type": "subflow:fb6b02d4d9963179",
        "z": "2ad740b531e49822",
        "name": "",
        "x": 1750,
        "y": 1120,
        "wires": [
            [
                "1d48fde7b9bf2caa"
            ]
        ]
    },
    {
        "id": "349824aaaa43c43d",
        "type": "subflow:fb6b02d4d9963179",
        "z": "2ad740b531e49822",
        "name": "",
        "x": 1710,
        "y": 420,
        "wires": [
            [
                "5d0c19257761e5cf"
            ]
        ]
    },
    {
        "id": "430dd01d357069c8",
        "type": "subflow:07a7fc5bcd60a12a",
        "z": "2ad740b531e49822",
        "name": "",
        "x": 2050,
        "y": 520,
        "wires": [
            [
                "6299e10365010d76"
            ]
        ]
    },
    {
        "id": "75ac0bb21e23f4e4",
        "type": "subflow:105d02aba31c4a1d",
        "z": "2ad740b531e49822",
        "x": 1470,
        "y": 1120,
        "wires": [
            [
                "058ba4b29f9b0ee6"
            ]
        ]
    },
    {
        "id": "6a4d7967d3c61057",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.actionId ?? actionState.id;\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1910,
        "y": 160,
        "wires": [
            [
                "5d0c19257761e5cf"
            ]
        ]
    },
    {
        "id": "9d9c6f288ab91c24",
        "type": "debug",
        "z": "2ad740b531e49822",
        "name": "opcua-status",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1250,
        "y": 980,
        "wires": []
    },
    {
        "id": "18f8cc93b5036c87",
        "type": "debug",
        "z": "2ad740b531e49822",
        "name": "before-write-order",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1730,
        "y": 680,
        "wires": []
    },
    {
        "id": "34d58e752a0c7938",
        "type": "delay",
        "z": "2ad740b531e49822",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1860,
        "y": 580,
        "wires": [
            [
                "8d70926077892873"
            ]
        ]
    },
    {
        "id": "8d70926077892873",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "update-calibration-data",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nmsg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2040,
        "y": 580,
        "wires": [
            [
                "d3b93afcf4a3a61f"
            ]
        ]
    },
    {
        "id": "2afdd84f46e20aa2",
        "type": "OPCUA-IIoT-Inject",
        "z": "2ad740b531e49822",
        "g": "2a3a170984a0b0b4",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 200,
        "y": 400,
        "wires": [
            [
                "88f413abe5572359",
                "177fbb831c55dd70"
            ]
        ]
    },
    {
        "id": "88f413abe5572359",
        "type": "OPCUA-IIoT-Read",
        "z": "2ad740b531e49822",
        "g": "2a3a170984a0b0b4",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "42eb75176feb84b0",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 390,
        "y": 360,
        "wires": [
            [
                "177fbb831c55dd70"
            ]
        ]
    },
    {
        "id": "177fbb831c55dd70",
        "type": "subflow:468f2460ce66f11e",
        "z": "2ad740b531e49822",
        "g": "2a3a170984a0b0b4",
        "name": "",
        "x": 610,
        "y": 400,
        "wires": [
            [
                "5d0c19257761e5cf"
            ]
        ]
    },
    {
        "id": "4a16f4c01177cedd",
        "type": "function",
        "z": "2ad740b531e49822",
        "name": "reset",
        "func": "msg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: \"ns=4;i=259\", \"datatypeName\": \"Boolean\" }\n    ],\n    valuesToWrite: [\n        { value: true }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1270,
        "y": 800,
        "wires": [
            [
                "62234f6bedbc7956",
                "18f8cc93b5036c87"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite"
        ]
    },
    {
        "id": "62234f6bedbc7956",
        "type": "OPCUA-IIoT-Write",
        "z": "2ad740b531e49822",
        "connector": "42eb75176feb84b0",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1710,
        "y": 800,
        "wires": [
            [
                "72814b1293a95903"
            ]
        ]
    },
    {
        "id": "ff43a8084dd3f482",
        "type": "subflow:6a25ecd632542087",
        "z": "fd2a2507d5769687",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-hbw.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "8f126a2af39d84b1"
            ]
        ]
    },
    {
        "id": "d7e2425fa4992751",
        "type": "OPCUA-IIoT-Listener",
        "z": "fd2a2507d5769687",
        "connector": "7934c6af334404ef",
        "action": "subscribe",
        "queueSize": "30",
        "name": "",
        "topic": "",
        "justValue": true,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 900,
        "wires": [
            [
                "7dfa6b22d44987c5",
                "d0f47593363e29f7",
                "aab6119b3fc80b58",
                "ae9fec7187452918"
            ]
        ]
    },
    {
        "id": "4e68fd05fde8834d",
        "type": "OPCUA-IIoT-Read",
        "z": "fd2a2507d5769687",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "7934c6af334404ef",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 200,
        "wires": [
            [
                "e2dc36f907dc2657"
            ]
        ]
    },
    {
        "id": "39bd41c4b3c858b0",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "vda_status_finished PICK",
        "func": "const nodeValue = msg.payload.value.value.value;\nconst moduleStsate = flow.get(\"moduleState\");\nif (nodeValue == true && moduleStsate == \"RPICK\") {\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n    const actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"moduleState\", \"IDLE\");\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1020,
        "wires": [
            [
                "04e8c7fb5012c205",
                "1df8cbd17e5cde13"
            ]
        ]
    },
    {
        "id": "7dfa6b22d44987c5",
        "type": "switch",
        "z": "fd2a2507d5769687",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=57",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=258",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=256",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=246",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=247",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=250",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=260",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=242",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=243",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 980,
        "wires": [
            [
                "13a446658e7a15c1"
            ],
            [
                "e73809a8e41d243f"
            ],
            [],
            [
                "dfc69caf74d22c95"
            ],
            [
                "dfc69caf74d22c95",
                "39d98b77acdaf0be"
            ],
            [],
            [
                "e73809a8e41d243f"
            ],
            [
                "dfc69caf74d22c95"
            ],
            [
                "dfc69caf74d22c95",
                "39bd41c4b3c858b0"
            ]
        ],
        "outputLabels": [
            "busy",
            "anfahren_beendet",
            "default_beendet",
            "drop_aktiv",
            "drop_finished",
            "kalib_aktiv",
            "kalib_finished",
            "pick_aktiv",
            "pick_finished"
        ]
    },
    {
        "id": "39d98b77acdaf0be",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "vda_status_finished DROP",
        "func": "const nodeValue = msg.payload.value.value.value;\nconst moduleState = flow.get(\"moduleState\");\nif (nodeValue == true && moduleState == \"RDROP\") {\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n    const actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\";\n    // get the workpieceId from the flow state (set during initial determination of the rack position)\n    let workpieceId = flow.get(\"workpieceId\");\n    // unknown should never happen if a workpiece is introduced via DPS\n    actionState.result = workpieceId ?? \"unknown\"; \n\n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"workpieceId\", undefined);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 980,
        "wires": [
            [
                "04e8c7fb5012c205",
                "1df8cbd17e5cde13"
            ]
        ]
    },
    {
        "id": "04e8c7fb5012c205",
        "type": "debug",
        "z": "fd2a2507d5769687",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1780,
        "y": 980,
        "wires": []
    },
    {
        "id": "13a446658e7a15c1",
        "type": "change",
        "z": "fd2a2507d5769687",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_busy",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 900,
        "wires": [
            []
        ]
    },
    {
        "id": "d0f47593363e29f7",
        "type": "debug",
        "z": "fd2a2507d5769687",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 780,
        "wires": []
    },
    {
        "id": "cc6fa5227a3ae1e8",
        "type": "OPCUA-IIoT-Browser",
        "z": "fd2a2507d5769687",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": "1",
        "delayPerMessage": 0.2,
        "connector": "7934c6af334404ef",
        "x": 400,
        "y": 900,
        "wires": [
            [
                "d7e2425fa4992751",
                "76fe5372d60f586b",
                "76796127a05d7c52",
                "aab6119b3fc80b58",
                "9b87fb7895e4b341",
                "c1e826cbcd3e6ea0",
                "74b6e542dbdbc5cb",
                "e0d24230baf9b98a",
                "f842d3ab744396a9",
                "266ef9aa77d73bbd",
                "e3fb863bb518ccc9",
                "864a40a395c8fa8f",
                "5a3afa75da189b8f"
            ]
        ]
    },
    {
        "id": "aa6fb6408d5c2774",
        "type": "OPCUA-IIoT-Inject",
        "z": "fd2a2507d5769687",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "hbw",
        "addressSpaceItems": [],
        "x": 250,
        "y": 900,
        "wires": [
            [
                "cc6fa5227a3ae1e8"
            ]
        ]
    },
    {
        "id": "76fe5372d60f586b",
        "type": "debug",
        "z": "fd2a2507d5769687",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 740,
        "wires": []
    },
    {
        "id": "76796127a05d7c52",
        "type": "change",
        "z": "fd2a2507d5769687",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "1df8cbd17e5cde13",
        "type": "link out",
        "z": "fd2a2507d5769687",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1945,
        "y": 1060,
        "wires": []
    },
    {
        "id": "e2dc36f907dc2657",
        "type": "subflow:1b897516f5bf21fa",
        "z": "fd2a2507d5769687",
        "name": "",
        "x": 710,
        "y": 200,
        "wires": [
            [
                "93ff68ee1932ced7"
            ],
            [
                "308878dc4ccda3bb"
            ],
            [
                "c0a328943becf51f"
            ],
            []
        ]
    },
    {
        "id": "e26032b731ef180a",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nlet factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 380,
        "wires": [
            [
                "cd88a9c8b70520bb",
                "c0a328943becf51f"
            ]
        ]
    },
    {
        "id": "67c21c1828baa896",
        "type": "link out",
        "z": "fd2a2507d5769687",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2305,
        "y": 600,
        "wires": []
    },
    {
        "id": "308878dc4ccda3bb",
        "type": "switch",
        "z": "fd2a2507d5769687",
        "name": "instantActionSwitch",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "factsheetRequest",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "startCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "storeCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "selectCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "testCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "resetCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "SET_STORAGE",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "reset",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 10,
        "x": 950,
        "y": 480,
        "wires": [
            [
                "e26032b731ef180a"
            ],
            [
                "9fc56b6458f44af6"
            ],
            [
                "b1ebd8a93c32e30b"
            ],
            [
                "51dfb634970a0aa3"
            ],
            [
                "fcb3c5bab99c021a"
            ],
            [
                "fa4cea71e6e6137b"
            ],
            [
                "af8551810d412832"
            ],
            [
                "0fd4d73f9de211f2"
            ],
            [
                "e39ebb18f7878da3"
            ],
            [
                "ff3436eb4f63eb6e"
            ]
        ]
    },
    {
        "id": "9fc56b6458f44af6",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "startCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {ReferenceData[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            const refData = createReferenceData(nodeName, nodeValue);\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\" || moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"CALIBRATION\");\n\n    const isCalibActive = flow.get(\"calibration.state.status__kalibAktiv.nodeValue\") ?? false;\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.modulePaused = true;\n    msg.operatingMode = \"TEACHIN\";\n    msg.actionCommand = \"startCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=251\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: !isCalibActive }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not IDLE and cannot be set to CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 440,
        "wires": [
            [
                "ca89af0dd7dca629",
                "f774fb45e5fb328d"
            ],
            [
                "c0bf5a3d35222b1d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "c0bf5a3d35222b1d",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 600,
        "wires": [
            [
                "67c21c1828baa896"
            ]
        ]
    },
    {
        "id": "b1ebd8a93c32e30b",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "stopCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"state.information\", []);\n\n    msg.actionCommand = \"stopCalibration\";\n    msg.calibrationData = [];\n    msg.modulePaused = false;\n    msg.operatingMode = \"AUTOMATIC\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=259\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 480,
        "wires": [
            [
                "98d2c01a1abaac3d",
                "f774fb45e5fb328d"
            ],
            [
                "c0bf5a3d35222b1d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "98d2c01a1abaac3d",
        "type": "OPCUA-IIoT-Write",
        "z": "fd2a2507d5769687",
        "connector": "7934c6af334404ef",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1670,
        "y": 480,
        "wires": [
            [
                "c18e9cbe4d9252e8",
                "37c83bf94a055297"
            ]
        ]
    },
    {
        "id": "51dfb634970a0aa3",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "setCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n */\nfunction createError(message) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", error);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"setCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 520,
        "wires": [
            [
                "ca89af0dd7dca629",
                "f774fb45e5fb328d"
            ],
            [
                "c0bf5a3d35222b1d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "fcb3c5bab99c021a",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "storeCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n */\nfunction createError(message) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", error);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: toUpdate.nodeValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"storeCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 640,
        "wires": [
            [
                "ca89af0dd7dca629",
                "f774fb45e5fb328d"
            ],
            [
                "c0bf5a3d35222b1d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "fa4cea71e6e6137b",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "selectCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/** @type {Record<string, PositionTargetData>} */\nconst positions = {\n    \"REF\": {\n        \"befehl__anfahren_position_dreh\": 0,\n        \"befehl__anfahren_position_x\": 0,\n        \"befehl__anfahren_position_y\": 0,\n    },\n    \"RACK_REIHE_A_SPALTE_1\": {\n        \"befehl__anfahren_position_dreh\": undefined,\n        \"befehl__anfahren_position_x\": \"kalib__spalte_1\",\n        \"befehl__anfahren_position_y\": \"kalib__reihe_A\"\n    },\n    \"RACK_REIHE_B_SPALTE_2\": {\n        \"befehl__anfahren_position_dreh\": undefined,\n        \"befehl__anfahren_position_x\": \"kalib__spalte_2\",\n        \"befehl__anfahren_position_y\": \"kalib__reihe_B\",\n    },\n    \"RACK_REIHE_C_SPALTE_3\": {\n        \"befehl__anfahren_position_dreh\": undefined,\n        \"befehl__anfahren_position_x\": \"kalib__spalte_3\",\n        \"befehl__anfahren_position_y\": \"kalib__reihe_C\"\n    },\n    \"RAMPE\": {\n        \"befehl__anfahren_position_dreh\": \"kalib__rampe_position_dreh\",\n        \"befehl__anfahren_position_x\": \"kalib__rampe_position_X\",\n        \"befehl__anfahren_position_y\": \"kalib__rampe_position_Y\"\n    },\n    \"PICK\": {\n        \"befehl__anfahren_position_dreh\": \"kalib__FTS_position_Dreh\",\n        \"befehl__anfahren_position_x\": undefined,\n        \"befehl__anfahren_position_y\": undefined,\n    },\n    \"DROP\": {\n        \"befehl__anfahren_position_dreh\": \"kalib__FTS_position_Dreh\",\n        \"befehl__anfahren_position_x\": undefined,\n        \"befehl__anfahren_position_y\": undefined,\n    },\n};\n\n/**\n * @param {string} message\n */\nfunction createError(message) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", error);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @param {string} newCurrentPosition\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions(newCurrentPosition) {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": newCurrentPosition },\n        ]\n    }\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.position?.length > 0) {\n        /** @type {Reference[]} */\n        const targetRefs = [];\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        /** @type {PositionTargetData} */\n        const targetData = positions[metadata.position];\n        for (let [key, value] of Object.entries(targetData)) {\n            /** @type {Reference | null} */\n            let newRef = null;\n            if (value == undefined) {\n                continue;\n            } else if (typeof value == \"string\") {\n                const nodeValue = flow.get(`calibration.state.${value}.nodeValue`);\n                /** @type {Reference} */\n                newRef = {\n                    referenceKey: key,\n                    referenceValue: nodeValue,\n                };\n            } else {\n                /** @type {Reference} */\n                newRef = {\n                    referenceKey: key,\n                    referenceValue: value,\n                };\n            }\n            targetRefs.push(newRef);\n        }\n\n        for (let { referenceKey, referenceValue } of targetRefs) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaPark() {\n    return {\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=316\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        createError(`${metadata.position} is not a valid position`);\n        return [null, msg];\n    }\n\n    const newPosition = metadata.position;\n    flow.set(\"calibration.positions.current\", newPosition);\n\n    const newData = (newPosition == \"PARK\") ? createOpcuaPark() : createOpcuaUpdate(metadata);\n    const { nodesToWrite, valuesToWrite } = newData;\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions(newPosition)];\n    msg.actionCommand = \"selectCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1290,
        "y": 560,
        "wires": [
            [
                "ca89af0dd7dca629",
                "f774fb45e5fb328d"
            ],
            [
                "c0bf5a3d35222b1d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "af8551810d412832",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "testCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {Reference[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n * \n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    return {\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=257\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"testCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 600,
        "wires": [
            [
                "98d2c01a1abaac3d",
                "f774fb45e5fb328d"
            ],
            [
                "c0bf5a3d35222b1d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "0fd4d73f9de211f2",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "resetCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    msg.actionCommand = \"resetCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=255\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 680,
        "wires": [
            [
                "ca89af0dd7dca629",
                "f774fb45e5fb328d"
            ],
            [
                "c0bf5a3d35222b1d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "4306d35d32c4362d",
        "type": "OPCUA-IIoT-Write",
        "z": "fd2a2507d5769687",
        "connector": "7934c6af334404ef",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1630,
        "y": 120,
        "wires": [
            [
                "c3f098ec62c4010b",
                "0a3adc723b4e8369"
            ]
        ]
    },
    {
        "id": "8f418cde5566d15d",
        "type": "switch",
        "z": "fd2a2507d5769687",
        "name": "orderswitch",
        "property": "order",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1190,
        "y": 160,
        "wires": [
            [
                "28c4842e65a986d9"
            ],
            [
                "69701a09b34f4cca"
            ]
        ]
    },
    {
        "id": "28c4842e65a986d9",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "PICK",
        "func": "/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @typedef {object} RackPosition\n * @property {{\"#address\": string, value: string }} name\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n * @property {{\"#address\": string, value: string}} workpieceId\n */\n\nfunction getEmptyRackPositions() {\n    /** @type Record<string, RackPosition> */\n    const rackPositions = flow.get(\"rack.positions\") ?? {};\n    return Object.keys(rackPositions)\n        .sort((a, b) => {\n            const letterA = a.charAt(0);\n            const letterB = b.charAt(0);\n            const numberA = parseInt(a.substring(1));\n            const numberB = parseInt(b.substring(1));\n\n            if (numberA === numberB) {\n                return letterA.localeCompare(letterB);\n            } else {\n                return numberA - numberB;\n            }\n        })\n        .map(k => rackPositions[k])\n        .filter(r => r.belegt?.value == false);\n}\n\n/**\n * @param {string} type\n * @param {string} workpieceId\n * @return {{valuesToWrite: Array<object>, nodesToWrite: Array<object>}}\n */\nfunction createPickCommand(type, workpieceId) {\n    const emptyRackPositions = getEmptyRackPositions();\n    const emptyRackPosition = emptyRackPositions[0];\n    node.status({ fill: \"grey\", shape: \"dot\", text: emptyRackPosition?.name?.value ?? \"UNKNOWN\" });\n    if (!emptyRackPosition) {\n        throw new Error(\"No empty rack\");\n    }\n    return {\n        nodesToWrite: [\n            { nodeId: 'ns=4;i=245' /* PICK-RACK */, \"datatypeName\": \"String\" },\n            { nodeId: 'ns=4;i=244'/* PICK */, \"datatypeName\": \"Boolean\" },\n            { nodeId: emptyRackPosition.belegt['#address'], \"datatypeName\": \"Boolean\" },\n            { nodeId: emptyRackPosition.type['#address'], \"datatypeName\": \"String\" },\n            { nodeId: emptyRackPosition.workpieceId['#address'], \"datatypeName\": \"String\" }\n        ],\n        valuesToWrite: [\n            { value: emptyRackPosition.name.value },\n            { value: true },\n            { value: true },\n            { value: type },\n            { value: workpieceId }\n        ]\n    };\n}\n\n/**\n * @typedef {object} OrderPayload\n * @property {string} timestamp\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} serialNumber\n * @property {{id: string, command: string, metadata: {type: string, workpieceId: string}}} action \n * \n * @param {OrderPayload} payload\n * @return {[type: string, workpieceId: string]}\n */\nfunction extractPickParams(payload) {\n    const actionMetadata = payload.action.metadata;\n    return [actionMetadata.type, actionMetadata.workpieceId];\n}\n\n// wenn nicht IDLE dann nichts tun\nconst currentModuleState = flow.get(\"moduleState\") ?? \"UNKNOWN\";\nnode.status({ fill: \"green\", shape: \"dot\", text: currentModuleState });\nif (currentModuleState == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RPICK\"); // modulestate zu \"RUNNING PICK\" setzen\n    node.status({ fill: \"grey\", shape: \"dot\", text: \"RPICK\" });\n\n    // Retrieve current Storage information and pick the next \n    try {\n        const [type, workpieceId] = extractPickParams(msg.payload);\n        node.status({ fill: \"green\", shape: \"dot\", text: `${type} / ${workpieceId}` });\n        const opcuaCommand = createPickCommand(type, workpieceId);\n        node.warn({ opcuaCommand });\n        msg.payload = {\n            \"nodetype\": \"inject\",\n            \"injectType\": \"write\",\n            ...opcuaCommand\n        };\n        return [msg, null];\n    } catch (err) {\n        flow.set(\"moduleState\", \"IDLE\");\n        createError(err.message);\n        return [null, msg];\n    }\n} else {\n    createError(\"Module is not IDLE\");\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Not IDLE\" });\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 100,
        "wires": [
            [
                "4306d35d32c4362d"
            ],
            [
                "cff95e975877c10b"
            ]
        ]
    },
    {
        "id": "69701a09b34f4cca",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "DROP",
        "func": "/**\n * @param {string} message\n * @param {\"WARNING\"|\"FATAL\"} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @typedef {object} RackPosition\n * @property {{\"#address\": string, value: string}} name\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n * @property {{\"#address\": string, value: string}} workpieceId\n */\n\n/** @param {string} type */\nfunction getRackPositionByType(type) {\n    /** @type Record<string, RackPosition> */\n    const rackPositions = flow.get(\"rack.positions\") ?? {};\n    return Object.keys(rackPositions)\n        .sort((a, b) => {\n            const letterA = a.charAt(0);\n            const letterB = b.charAt(0);\n            const numberA = parseInt(a.substring(1));\n            const numberB = parseInt(b.substring(1));\n\n            if (numberA === numberB) {\n                return letterA.localeCompare(letterB);\n            } else {\n                return numberA - numberB;\n            }\n        })\n        .map(k => rackPositions[k])\n        .filter(r => {\n            node.warn({ r });\n            return r.type?.value == type;\n        });\n}\n\n/**\n * @param {string} type\n * @return {{valuesToWrite: Array<object>, nodesToWrite: Array<object>}}\n */\nfunction createDropCommand(type) {\n    node.status({ fill: 'green', shape: 'dot', text: `${type}` });\n    const rackPositionsForType = getRackPositionByType(type);\n    node.warn({ rackPositionsForType });\n    const firstRackPositionForType = rackPositionsForType[0];\n    node.warn({ firstRackPositionForType });\n    node.status({ fill: 'gray', shape: 'dot', text: firstRackPositionForType?.name?.value ?? \"N/A\" });\n    if (!firstRackPositionForType) {\n        throw new Error(\"Type not available\");\n    }\n    // set the retrieved workpiece's ID to the flow state to access it when finishing the drop command \n    flow.set(\"workpieceId\", firstRackPositionForType?.workpieceId?.value);\n    return {\n        nodesToWrite: [\n            { nodeId: 'ns=4;i=248' /* DROP-RACK */, \"datatypeName\": \"String\" },\n            { nodeId: 'ns=4;i=249'/* DROP */, \"datatypeName\": \"Boolean\" },\n            { nodeId: firstRackPositionForType.belegt['#address'], \"datatypeName\": \"Boolean\" },\n            { nodeId: firstRackPositionForType.type['#address'], \"datatypeName\": \"String\" },\n            { nodeId: firstRackPositionForType.workpieceId['#address'], \"datatypeName\": \"String\" }\n        ],\n        valuesToWrite: [\n            { value: firstRackPositionForType.name.value },\n            { value: true },\n            { value: false },\n            { value: \"\" },\n            { value: \"\" }\n        ]\n    };\n}\n\n/**\n * @typedef {object} OrderPayload\n * @property {string} timestamp\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} serialNumber\n * @property {{id: string, command: string, metadata: {type: string, workpieceId: string}}} action \n * \n * @param {OrderPayload} payload\n * @return {string}\n */\nfunction extractDropParams(payload) {\n    const actionMetadata = payload.action.metadata;\n    return actionMetadata.type;\n}\n\n// wenn nicht IDLE dann nichts tun\nconst currentModuleState = flow.get(\"moduleState\") ?? \"UNKNOWN\";\nnode.status({ fill: \"grey\", shape: \"dot\", text: currentModuleState });\nif (currentModuleState == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RDROP\"); // modulestate zu \"RUNNING PICK\" setzen\n\n    // Retrieve current Storage information and pick the next \n    try {\n        const type = extractDropParams(msg.payload);\n        const opcuaCommand = createDropCommand(type);\n        msg.payload = {\n            \"nodetype\": \"inject\",\n            \"injectType\": \"write\",\n            ...opcuaCommand\n        };\n        return [msg, null];\n    } catch (err) {\n        flow.set(\"moduleState\", \"IDLE\");\n        createError(err.message);\n        return [null, msg];\n    }\n} else {\n    createError(\"Module is not IDLE\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 160,
        "wires": [
            [
                "4306d35d32c4362d"
            ],
            [
                "cff95e975877c10b"
            ]
        ]
    },
    {
        "id": "93ff68ee1932ced7",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "Order Update Check",
        "func": "// actionState in Flow speichern\nflow.set(\"actionState\", msg.payload.action);\n\n// orderUpdateId updaten\nflow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 160,
        "wires": [
            [
                "8f418cde5566d15d"
            ]
        ]
    },
    {
        "id": "cff95e975877c10b",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"orderId\", 0);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1650,
        "y": 180,
        "wires": [
            [
                "c0a328943becf51f"
            ]
        ]
    },
    {
        "id": "c0a328943becf51f",
        "type": "link out",
        "z": "fd2a2507d5769687",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2155,
        "y": 220,
        "wires": []
    },
    {
        "id": "ed101613da71182d",
        "type": "catch",
        "z": "fd2a2507d5769687",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 140,
        "y": 120,
        "wires": [
            [
                "22a062bc2002d493"
            ]
        ]
    },
    {
        "id": "22a062bc2002d493",
        "type": "debug",
        "z": "fd2a2507d5769687",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 370,
        "y": 120,
        "wires": []
    },
    {
        "id": "ae9fec7187452918",
        "type": "switch",
        "z": "fd2a2507d5769687",
        "name": "update-rack-state",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=262",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=263",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=261",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=265",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=264",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=266",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=268",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=267",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=269",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=271",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=270",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=272",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=274",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=273",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=275",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=277",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=276",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=278",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=280",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=279",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=281",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=283",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=282",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=284",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=286",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=285",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=287",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 27,
        "x": 770,
        "y": 1300,
        "wires": [
            [
                "9b87fb7895e4b341"
            ],
            [
                "9b87fb7895e4b341"
            ],
            [
                "9b87fb7895e4b341"
            ],
            [
                "c1e826cbcd3e6ea0"
            ],
            [
                "c1e826cbcd3e6ea0"
            ],
            [
                "c1e826cbcd3e6ea0"
            ],
            [
                "74b6e542dbdbc5cb"
            ],
            [
                "74b6e542dbdbc5cb"
            ],
            [
                "74b6e542dbdbc5cb"
            ],
            [
                "e0d24230baf9b98a"
            ],
            [
                "e0d24230baf9b98a"
            ],
            [
                "e0d24230baf9b98a"
            ],
            [
                "f842d3ab744396a9"
            ],
            [
                "f842d3ab744396a9"
            ],
            [
                "f842d3ab744396a9"
            ],
            [
                "266ef9aa77d73bbd"
            ],
            [
                "266ef9aa77d73bbd"
            ],
            [
                "266ef9aa77d73bbd"
            ],
            [
                "e3fb863bb518ccc9"
            ],
            [
                "e3fb863bb518ccc9"
            ],
            [
                "e3fb863bb518ccc9"
            ],
            [
                "864a40a395c8fa8f"
            ],
            [
                "864a40a395c8fa8f"
            ],
            [
                "864a40a395c8fa8f"
            ],
            [
                "5a3afa75da189b8f"
            ],
            [
                "5a3afa75da189b8f"
            ],
            [
                "5a3afa75da189b8f"
            ]
        ],
        "outputLabels": [
            "A1_belegt",
            "A1_type",
            "A1_workpieceId",
            "A2_belegt",
            "A2_type",
            "A2_workpieceId",
            "A3_belegt",
            "A3_type",
            "A3.workpieceId",
            "B1_belegt",
            "B1_type",
            "B1_workpieceId",
            "B2_belegt",
            "B2_type",
            "B2_workpieceId",
            "B3_belegt",
            "B3_type",
            "B3_workpieceId",
            "C1_belegt",
            "C1_type",
            "C1_workpieceId",
            "C2_belegt",
            "C2_type",
            "C2_workpieceId",
            "C3_belegt",
            "C3_type",
            "C3_workpieceId"
        ]
    },
    {
        "id": "9b87fb7895e4b341",
        "type": "subflow:ea935d7649fccac4",
        "z": "fd2a2507d5769687",
        "name": "A1",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "A1",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1120,
        "wires": []
    },
    {
        "id": "c1e826cbcd3e6ea0",
        "type": "subflow:ea935d7649fccac4",
        "z": "fd2a2507d5769687",
        "name": "A2",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "A2",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1180,
        "wires": []
    },
    {
        "id": "74b6e542dbdbc5cb",
        "type": "subflow:ea935d7649fccac4",
        "z": "fd2a2507d5769687",
        "name": "A3",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "A3",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1240,
        "wires": []
    },
    {
        "id": "e0d24230baf9b98a",
        "type": "subflow:ea935d7649fccac4",
        "z": "fd2a2507d5769687",
        "name": "B1",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "B1",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1300,
        "wires": []
    },
    {
        "id": "f842d3ab744396a9",
        "type": "subflow:ea935d7649fccac4",
        "z": "fd2a2507d5769687",
        "name": "B2",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "B2",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1360,
        "wires": []
    },
    {
        "id": "266ef9aa77d73bbd",
        "type": "subflow:ea935d7649fccac4",
        "z": "fd2a2507d5769687",
        "name": "B3",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "B3",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1420,
        "wires": []
    },
    {
        "id": "e3fb863bb518ccc9",
        "type": "subflow:ea935d7649fccac4",
        "z": "fd2a2507d5769687",
        "name": "C1",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "C1",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1480,
        "wires": []
    },
    {
        "id": "864a40a395c8fa8f",
        "type": "subflow:ea935d7649fccac4",
        "z": "fd2a2507d5769687",
        "name": "C2",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "C2",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1540,
        "wires": []
    },
    {
        "id": "5a3afa75da189b8f",
        "type": "subflow:ea935d7649fccac4",
        "z": "fd2a2507d5769687",
        "name": "C3",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "C3",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1600,
        "wires": []
    },
    {
        "id": "0a3adc723b4e8369",
        "type": "debug",
        "z": "fd2a2507d5769687",
        "name": "write-order",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1810,
        "y": 80,
        "wires": []
    },
    {
        "id": "76e8b49dade6b177",
        "type": "inject",
        "z": "fd2a2507d5769687",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.2",
        "crontab": "",
        "once": true,
        "onceDelay": "0.2",
        "topic": "rack.positions",
        "payload": "rack.positions",
        "payloadType": "flow",
        "x": 290,
        "y": 620,
        "wires": [
            [
                "559b08bfb885d948"
            ]
        ]
    },
    {
        "id": "559b08bfb885d948",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "order-rackpositions",
        "func": "const rackPositions = msg.payload ?? {};\n\nmsg.payload = Object.keys(rackPositions).reduce((sorted, key) => {\n    return {\n        ...sorted,\n        [key]: rackPositions[key]\n    }\n}, {});\nmsg.topic = \"ordered-rackpositions\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 620,
        "wires": [
            [
                "6468901380bea245"
            ]
        ]
    },
    {
        "id": "6468901380bea245",
        "type": "change",
        "z": "fd2a2507d5769687",
        "name": "set-positions",
        "rules": [
            {
                "t": "set",
                "p": "rack.positions",
                "pt": "flow",
                "to": "payload",
                "tot": "msg",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 710,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "ca89af0dd7dca629",
        "type": "OPCUA-IIoT-Write",
        "z": "fd2a2507d5769687",
        "connector": "7934c6af334404ef",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1670,
        "y": 540,
        "wires": [
            [
                "c18e9cbe4d9252e8",
                "80866d5af0a56ffa"
            ]
        ]
    },
    {
        "id": "e39ebb18f7878da3",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "set-storage",
        "func": "/**\n * @typedef {object} RackPosition\n * @property {{value: string}} name\n * @property {{\"#address\": string, value: string}} workpieceId\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n */\n\n/**\n * @typedef {object} Load\n * @property {string} loadType\n * @property {string} loadId\n * @property {string} [loadPosition]\n * \n * @param {string} rackPosition\n * @param {string} workpieceId\n * @param {string} type\n */\nfunction createLoad(rackPosition, workpieceId, type) {\n    return {\n        loadType: type,\n        loadId: workpieceId,\n        loadPosition: rackPosition,\n    };\n}\n\n/**\n * @param {Record<string, { type: string, workpieceId: string}>} contents\n * @returns {Load[]}\n */\nfunction fillLoads(contents) {\n    return Object.entries(contents).map(([key, val]) => createLoad(key, val.workpieceId ?? \"\", val.type ?? \"\"));\n}\n\n/**\n * @typedef {object} OpcuaCommand\n * @property {array} nodesToWrite\n * @property {array} valuesToWrite\n * \n * @param {Load[]} loads\n * @returns {OpcuaCommand}\n */\nfunction createOpcuaCommand(loads) {\n    const rackPositions = flow.get(\"rack.positions\") ?? {};\n    const nodesToWrite = [];\n    const valuesToWrite = [];\n\n    for (let [rackPos, entry] of Object.entries(rackPositions)) {\n        const targetLoad = loads.find(l => l.loadPosition == rackPos);\n        nodesToWrite.push({ nodeId: entry.workpieceId['#address'], datatypeName: \"String\" });\n        valuesToWrite.push({ value: targetLoad?.loadId ?? \"\" });\n        nodesToWrite.push({ nodeId: entry.type['#address'], datatypeName: \"String\" });\n        valuesToWrite.push({ value: targetLoad?.loadType ?? \"\" });\n        nodesToWrite.push({ nodeId: entry.belegt['#address'], datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: !!targetLoad && !!targetLoad?.loadType });\n    }\n\n    return { nodesToWrite, valuesToWrite };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\") {\n    const actionMetadata = msg.actionMetadata ?? { contents: {} };\n    const newLoads = fillLoads(actionMetadata.contents);\n    const { nodesToWrite, valuesToWrite } = createOpcuaCommand(newLoads);\n\n    msg.loads = newLoads;\n    msg.actionCommand = \"SET_STORAGE\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not IDLE and cannot be filled with workpieces\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 720,
        "wires": [
            [
                "ca89af0dd7dca629",
                "f774fb45e5fb328d"
            ],
            [
                "c0bf5a3d35222b1d"
            ]
        ]
    },
    {
        "id": "aab6119b3fc80b58",
        "type": "subflow:7173b966cb38f0e0",
        "z": "fd2a2507d5769687",
        "name": "",
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "value": "REF,RACK_REIHE_A_SPALTE_1,RACK_REIHE_B_SPALTE_2,RACK_REIHE_C_SPALTE_3,RAMPE,PICK,DROP,PARK",
                "type": "str"
            },
            {
                "name": "CURRENT_POSITION",
                "value": "REF",
                "type": "str"
            }
        ],
        "x": 790,
        "y": 860,
        "wires": []
    },
    {
        "id": "c18e9cbe4d9252e8",
        "type": "debug",
        "z": "fd2a2507d5769687",
        "name": "after-write-order",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1960,
        "y": 600,
        "wires": []
    },
    {
        "id": "e73809a8e41d243f",
        "type": "delay",
        "z": "fd2a2507d5769687",
        "name": "Verzögerung",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 1210,
        "y": 1080,
        "wires": [
            [
                "11d953731ddafa06"
            ]
        ]
    },
    {
        "id": "9da182fd2dafbeb6",
        "type": "subflow:fb6b02d4d9963179",
        "z": "fd2a2507d5769687",
        "name": "",
        "x": 2270,
        "y": 540,
        "wires": [
            [
                "67c21c1828baa896"
            ]
        ]
    },
    {
        "id": "8a915a063b7e11d6",
        "type": "subflow:fb6b02d4d9963179",
        "z": "fd2a2507d5769687",
        "name": "",
        "x": 1710,
        "y": 1080,
        "wires": [
            [
                "1df8cbd17e5cde13"
            ]
        ]
    },
    {
        "id": "cd88a9c8b70520bb",
        "type": "subflow:fb6b02d4d9963179",
        "z": "fd2a2507d5769687",
        "name": "",
        "x": 1670,
        "y": 380,
        "wires": [
            [
                "c0a328943becf51f"
            ]
        ]
    },
    {
        "id": "37c83bf94a055297",
        "type": "subflow:07a7fc5bcd60a12a",
        "z": "fd2a2507d5769687",
        "name": "",
        "x": 2010,
        "y": 480,
        "wires": [
            [
                "67c21c1828baa896"
            ]
        ]
    },
    {
        "id": "11d953731ddafa06",
        "type": "subflow:105d02aba31c4a1d",
        "z": "fd2a2507d5769687",
        "x": 1430,
        "y": 1080,
        "wires": [
            [
                "8a915a063b7e11d6"
            ]
        ]
    },
    {
        "id": "c3f098ec62c4010b",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.actionId ?? actionState.id;\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1870,
        "y": 120,
        "wires": [
            [
                "c0a328943becf51f"
            ]
        ]
    },
    {
        "id": "dfc69caf74d22c95",
        "type": "debug",
        "z": "fd2a2507d5769687",
        "name": "opcua-status",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 940,
        "wires": []
    },
    {
        "id": "f774fb45e5fb328d",
        "type": "debug",
        "z": "fd2a2507d5769687",
        "name": "before-write-order",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1690,
        "y": 640,
        "wires": []
    },
    {
        "id": "80866d5af0a56ffa",
        "type": "delay",
        "z": "fd2a2507d5769687",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1820,
        "y": 540,
        "wires": [
            [
                "809f70668d4df02f"
            ]
        ]
    },
    {
        "id": "809f70668d4df02f",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "update-calibration-data",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nmsg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2000,
        "y": 540,
        "wires": [
            [
                "9da182fd2dafbeb6"
            ]
        ]
    },
    {
        "id": "ad34b1839a6c08f8",
        "type": "OPCUA-IIoT-Inject",
        "z": "fd2a2507d5769687",
        "g": "d4589490bc22cdbd",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 360,
        "wires": [
            [
                "98c2222cc6522015",
                "50ab54e952166f62"
            ]
        ]
    },
    {
        "id": "98c2222cc6522015",
        "type": "OPCUA-IIoT-Read",
        "z": "fd2a2507d5769687",
        "g": "d4589490bc22cdbd",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "7934c6af334404ef",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 320,
        "wires": [
            [
                "50ab54e952166f62"
            ]
        ]
    },
    {
        "id": "50ab54e952166f62",
        "type": "subflow:468f2460ce66f11e",
        "z": "fd2a2507d5769687",
        "g": "d4589490bc22cdbd",
        "name": "",
        "x": 590,
        "y": 360,
        "wires": [
            [
                "c0a328943becf51f"
            ]
        ]
    },
    {
        "id": "e8814c9e0f267cc9",
        "type": "OPCUA-IIoT-Inject",
        "z": "fd2a2507d5769687",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=116",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=315",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 200,
        "wires": [
            [
                "4e68fd05fde8834d"
            ]
        ]
    },
    {
        "id": "8f126a2af39d84b1",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"HBW\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"HBW\");\nflow.set(\"errors\", []);\n\n// state bauen\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"operatingMode\": \"AUTOMATIC\",\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    },\n    \"information\": []\n});\n\nconst factsheet = msg.factsheet ?? {};\nfactsheet.serialNumber = \"Unknown\";\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.81\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\n\nflow.set(\"opcuaState\", \"connected\");\nreturn ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "ff3436eb4f63eb6e",
        "type": "function",
        "z": "fd2a2507d5769687",
        "name": "reset",
        "func": "msg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: \"ns=4;i=259\", \"datatypeName\": \"Boolean\" }\n    ],\n    valuesToWrite: [\n        { value: true }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1230,
        "y": 760,
        "wires": [
            [
                "1a9ca33050186a23",
                "f774fb45e5fb328d"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite"
        ]
    },
    {
        "id": "1a9ca33050186a23",
        "type": "OPCUA-IIoT-Write",
        "z": "fd2a2507d5769687",
        "connector": "7934c6af334404ef",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1670,
        "y": 760,
        "wires": [
            [
                "c18e9cbe4d9252e8"
            ]
        ]
    },
    {
        "id": "a647d5bba18406a1",
        "type": "subflow:6a25ecd632542087",
        "z": "814355edd4de93bc",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-hbw.json",
                "type": "str"
            }
        ],
        "x": 150,
        "y": 60,
        "wires": [
            [
                "9d836696d4a84878"
            ]
        ]
    },
    {
        "id": "d46ddf2deb1ca07f",
        "type": "OPCUA-IIoT-Listener",
        "z": "814355edd4de93bc",
        "connector": "ac4f033c5eb8a63f",
        "action": "subscribe",
        "queueSize": "30",
        "name": "",
        "topic": "",
        "justValue": true,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 580,
        "y": 900,
        "wires": [
            [
                "f6f19bcae905b2c2",
                "55cdaa9b791103c2",
                "6266abd30bce06ff",
                "f1cca1aa2a07e601"
            ]
        ]
    },
    {
        "id": "b451db407b274886",
        "type": "OPCUA-IIoT-Read",
        "z": "814355edd4de93bc",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "ac4f033c5eb8a63f",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 200,
        "wires": [
            [
                "f4ae626cb34f5f8d"
            ]
        ]
    },
    {
        "id": "6c97a75554a52355",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "vda_status_finished PICK",
        "func": "const nodeValue = msg.payload.value.value.value;\nconst moduleStsate = flow.get(\"moduleState\");\nif (nodeValue == true && moduleStsate == \"RPICK\") {\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n    const actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\"; // Waiting for FTS\n\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = flow.get(\"actionState\");\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"moduleState\", \"IDLE\");\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1430,
        "y": 1020,
        "wires": [
            [
                "3d69917654ee4e59",
                "93b293c477a8fd8f"
            ]
        ]
    },
    {
        "id": "f6f19bcae905b2c2",
        "type": "switch",
        "z": "814355edd4de93bc",
        "name": "topicswitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=57",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=258",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=256",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=246",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=247",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=250",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=260",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=242",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=243",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 9,
        "x": 770,
        "y": 980,
        "wires": [
            [
                "9d3ec9d401130b81"
            ],
            [
                "c3ce3a555839d610"
            ],
            [],
            [
                "f31e44935a621587"
            ],
            [
                "f31e44935a621587",
                "f3a2532754a0c252"
            ],
            [],
            [
                "c3ce3a555839d610"
            ],
            [
                "f31e44935a621587"
            ],
            [
                "f31e44935a621587",
                "6c97a75554a52355"
            ]
        ],
        "outputLabels": [
            "busy",
            "anfahren_beendet",
            "default_beendet",
            "drop_aktiv",
            "drop_finished",
            "kalib_aktiv",
            "kalib_finished",
            "pick_aktiv",
            "pick_finished"
        ]
    },
    {
        "id": "f3a2532754a0c252",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "vda_status_finished DROP",
        "func": "const nodeValue = msg.payload.value.value.value;\nconst moduleState = flow.get(\"moduleState\");\nif (nodeValue == true && moduleState == \"RDROP\") {\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n    const actionState = flow.get(\"actionState\");\n    actionState.state = \"FINISHED\";\n    // get the workpieceId from the flow state (set during initial determination of the rack position)\n    let workpieceId = flow.get(\"workpieceId\");\n    // unknown should never happen if a workpiece is introduced via DPS\n    actionState.result = workpieceId ?? \"unknown\"; \n\n    // state\n    state.headerId = headerId;\n    state.loads = flow.get(\"loads\");\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"orderId\", 0);\n    flow.set(\"orderUpdateId\", 0);\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"workpieceId\", undefined);\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n} else {\n    return;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 980,
        "wires": [
            [
                "3d69917654ee4e59",
                "93b293c477a8fd8f"
            ]
        ]
    },
    {
        "id": "3d69917654ee4e59",
        "type": "debug",
        "z": "814355edd4de93bc",
        "name": "finished",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1780,
        "y": 980,
        "wires": []
    },
    {
        "id": "9d3ec9d401130b81",
        "type": "change",
        "z": "814355edd4de93bc",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_busy",
                "pt": "flow",
                "to": "payload.value.value.value",
                "tot": "msg",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1230,
        "y": 900,
        "wires": [
            []
        ]
    },
    {
        "id": "55cdaa9b791103c2",
        "type": "debug",
        "z": "814355edd4de93bc",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 780,
        "wires": []
    },
    {
        "id": "260a296725eda4db",
        "type": "OPCUA-IIoT-Browser",
        "z": "814355edd4de93bc",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": "1",
        "delayPerMessage": 0.2,
        "connector": "ac4f033c5eb8a63f",
        "x": 400,
        "y": 900,
        "wires": [
            [
                "d46ddf2deb1ca07f",
                "4c24162468b3edfd",
                "fae6d88e7ad39cf6",
                "6266abd30bce06ff",
                "92dd082cc8702421",
                "c7c6465e4d6e7639",
                "20309b34d4295499",
                "e575576daaa8d16b",
                "04efc342b88a99c2",
                "88105ae3a1a24feb",
                "d74c89dcc3a8f35c",
                "71e78a2bd25f1ddb",
                "87868ac137c42086"
            ]
        ]
    },
    {
        "id": "ad358555922adfde",
        "type": "OPCUA-IIoT-Inject",
        "z": "814355edd4de93bc",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "hbw",
        "addressSpaceItems": [],
        "x": 250,
        "y": 900,
        "wires": [
            [
                "260a296725eda4db"
            ]
        ]
    },
    {
        "id": "4c24162468b3edfd",
        "type": "debug",
        "z": "814355edd4de93bc",
        "name": "browser",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 740,
        "wires": []
    },
    {
        "id": "fae6d88e7ad39cf6",
        "type": "change",
        "z": "814355edd4de93bc",
        "name": "BrowserArray",
        "rules": [
            {
                "t": "set",
                "p": "BrowseArray",
                "pt": "flow",
                "to": "payload.browserResults",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 780,
        "y": 820,
        "wires": [
            []
        ]
    },
    {
        "id": "93b293c477a8fd8f",
        "type": "link out",
        "z": "814355edd4de93bc",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1945,
        "y": 1060,
        "wires": []
    },
    {
        "id": "f4ae626cb34f5f8d",
        "type": "subflow:1b897516f5bf21fa",
        "z": "814355edd4de93bc",
        "name": "",
        "x": 710,
        "y": 200,
        "wires": [
            [
                "5aeb48f81bd2d80e"
            ],
            [
                "e27c58b0ce63623f"
            ],
            [
                "90d6f05d70ab15ba"
            ],
            []
        ]
    },
    {
        "id": "38b63712fa9f0a88",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nlet factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 380,
        "wires": [
            [
                "3aaf45b5fe63b8ed",
                "90d6f05d70ab15ba"
            ]
        ]
    },
    {
        "id": "ed655a1d4b5ba332",
        "type": "link out",
        "z": "814355edd4de93bc",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2305,
        "y": 600,
        "wires": []
    },
    {
        "id": "e27c58b0ce63623f",
        "type": "switch",
        "z": "814355edd4de93bc",
        "name": "instantActionSwitch",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "factsheetRequest",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "startCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "storeCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "selectCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "testCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "resetCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "SET_STORAGE",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "reset",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 10,
        "x": 950,
        "y": 480,
        "wires": [
            [
                "38b63712fa9f0a88"
            ],
            [
                "96543562d981c1e8"
            ],
            [
                "90bdaba3969d6a1d"
            ],
            [
                "b097f18e1f3563df"
            ],
            [
                "7219fbf06cf48bec"
            ],
            [
                "ea8222f16de1d8f9"
            ],
            [
                "97a59bca88693d30"
            ],
            [
                "6be45ca2611f585e"
            ],
            [
                "209039d621dfe5de"
            ],
            [
                "104a545cfdf1eb67"
            ]
        ]
    },
    {
        "id": "96543562d981c1e8",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "startCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {ReferenceData[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            const refData = createReferenceData(nodeName, nodeValue);\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\" || moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"CALIBRATION\");\n\n    const isCalibActive = flow.get(\"calibration.state.status__kalibAktiv.nodeValue\") ?? false;\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.modulePaused = true;\n    msg.operatingMode = \"TEACHIN\";\n    msg.actionCommand = \"startCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=251\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: !isCalibActive }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not IDLE and cannot be set to CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 440,
        "wires": [
            [
                "49d06d9e725f65af",
                "dee6e8c149022f55"
            ],
            [
                "3c4ca5482eac1698"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "3c4ca5482eac1698",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 600,
        "wires": [
            [
                "ed655a1d4b5ba332"
            ]
        ]
    },
    {
        "id": "90bdaba3969d6a1d",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "stopCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"IDLE\");\n    flow.set(\"state.information\", []);\n\n    msg.actionCommand = \"stopCalibration\";\n    msg.calibrationData = [];\n    msg.modulePaused = false;\n    msg.operatingMode = \"AUTOMATIC\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=259\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 480,
        "wires": [
            [
                "ea90bb4df7cc4ddf",
                "dee6e8c149022f55"
            ],
            [
                "3c4ca5482eac1698"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "ea90bb4df7cc4ddf",
        "type": "OPCUA-IIoT-Write",
        "z": "814355edd4de93bc",
        "connector": "ac4f033c5eb8a63f",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1670,
        "y": 480,
        "wires": [
            [
                "f7f256df2b179551",
                "60e1c5853f61ca6d"
            ]
        ]
    },
    {
        "id": "b097f18e1f3563df",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "setCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n */\nfunction createError(message) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", error);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"setCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 520,
        "wires": [
            [
                "49d06d9e725f65af",
                "dee6e8c149022f55"
            ],
            [
                "3c4ca5482eac1698"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "7219fbf06cf48bec",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "storeCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n */\nfunction createError(message) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", error);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        for (let ref of metadata.references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: toUpdate.nodeValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"storeCalibrationValues\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 640,
        "wires": [
            [
                "49d06d9e725f65af",
                "dee6e8c149022f55"
            ],
            [
                "3c4ca5482eac1698"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "ea8222f16de1d8f9",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "selectCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/** @type {Record<string, PositionTargetData>} */\nconst positions = {\n    \"REF\": {\n        \"befehl__anfahren_position_dreh\": 0,\n        \"befehl__anfahren_position_x\": 0,\n        \"befehl__anfahren_position_y\": 0,\n    },\n    \"RACK_REIHE_A_SPALTE_1\": {\n        \"befehl__anfahren_position_dreh\": undefined,\n        \"befehl__anfahren_position_x\": \"kalib__spalte_1\",\n        \"befehl__anfahren_position_y\": \"kalib__reihe_A\"\n    },\n    \"RACK_REIHE_B_SPALTE_2\": {\n        \"befehl__anfahren_position_dreh\": undefined,\n        \"befehl__anfahren_position_x\": \"kalib__spalte_2\",\n        \"befehl__anfahren_position_y\": \"kalib__reihe_B\",\n    },\n    \"RACK_REIHE_C_SPALTE_3\": {\n        \"befehl__anfahren_position_dreh\": undefined,\n        \"befehl__anfahren_position_x\": \"kalib__spalte_3\",\n        \"befehl__anfahren_position_y\": \"kalib__reihe_C\"\n    },\n    \"RAMPE\": {\n        \"befehl__anfahren_position_dreh\": \"kalib__rampe_position_dreh\",\n        \"befehl__anfahren_position_x\": \"kalib__rampe_position_X\",\n        \"befehl__anfahren_position_y\": \"kalib__rampe_position_Y\"\n    },\n    \"PICK\": {\n        \"befehl__anfahren_position_dreh\": \"kalib__FTS_position_Dreh\",\n        \"befehl__anfahren_position_x\": undefined,\n        \"befehl__anfahren_position_y\": undefined,\n    },\n    \"DROP\": {\n        \"befehl__anfahren_position_dreh\": \"kalib__FTS_position_Dreh\",\n        \"befehl__anfahren_position_x\": undefined,\n        \"befehl__anfahren_position_y\": undefined,\n    },\n};\n\n/**\n * @param {string} message\n */\nfunction createError(message) {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", error);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @param {string} newCurrentPosition\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions(newCurrentPosition) {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": newCurrentPosition },\n        ]\n    }\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.position?.length > 0) {\n        /** @type {Reference[]} */\n        const targetRefs = [];\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        /** @type {PositionTargetData} */\n        const targetData = positions[metadata.position];\n        for (let [key, value] of Object.entries(targetData)) {\n            /** @type {Reference | null} */\n            let newRef = null;\n            if (value == undefined) {\n                continue;\n            } else if (typeof value == \"string\") {\n                const nodeValue = flow.get(`calibration.state.${value}.nodeValue`);\n                /** @type {Reference} */\n                newRef = {\n                    referenceKey: key,\n                    referenceValue: nodeValue,\n                };\n            } else {\n                /** @type {Reference} */\n                newRef = {\n                    referenceKey: key,\n                    referenceValue: value,\n                };\n            }\n            targetRefs.push(newRef);\n        }\n\n        for (let { referenceKey, referenceValue } of targetRefs) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaPark() {\n    return {\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=316\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        createError(`${metadata.position} is not a valid position`);\n        return [null, msg];\n    }\n\n    const newPosition = metadata.position;\n    flow.set(\"calibration.positions.current\", newPosition);\n\n    const newData = (newPosition == \"PARK\") ? createOpcuaPark() : createOpcuaUpdate(metadata);\n    const { nodesToWrite, valuesToWrite } = newData;\n\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions(newPosition)];\n    msg.actionCommand = \"selectCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1290,
        "y": 560,
        "wires": [
            [
                "49d06d9e725f65af",
                "dee6e8c149022f55"
            ],
            [
                "3c4ca5482eac1698"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "97a59bca88693d30",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "testCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {Reference[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n * \n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    return {\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=257\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n    msg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\n    msg.actionCommand = \"testCalibrationPosition\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 600,
        "wires": [
            [
                "ea90bb4df7cc4ddf",
                "dee6e8c149022f55"
            ],
            [
                "3c4ca5482eac1698"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "6be45ca2611f585e",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "resetCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    msg.actionCommand = \"resetCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=255\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not in CALIBRATION mode\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 680,
        "wires": [
            [
                "49d06d9e725f65af",
                "dee6e8c149022f55"
            ],
            [
                "3c4ca5482eac1698"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "0bfee30c97acf819",
        "type": "OPCUA-IIoT-Write",
        "z": "814355edd4de93bc",
        "connector": "ac4f033c5eb8a63f",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1630,
        "y": 120,
        "wires": [
            [
                "49cc1767ae56fc66",
                "4a1f8d2800bf9751"
            ]
        ]
    },
    {
        "id": "313f88ce97978b34",
        "type": "switch",
        "z": "814355edd4de93bc",
        "name": "orderswitch",
        "property": "order",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1190,
        "y": 160,
        "wires": [
            [
                "0e28b3cc3c5a9888"
            ],
            [
                "d0fcfabca6515a6b"
            ]
        ]
    },
    {
        "id": "0e28b3cc3c5a9888",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "PICK",
        "func": "/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @typedef {object} RackPosition\n * @property {{\"#address\": string, value: string }} name\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n * @property {{\"#address\": string, value: string}} workpieceId\n */\n\nfunction getEmptyRackPositions() {\n    /** @type Record<string, RackPosition> */\n    const rackPositions = flow.get(\"rack.positions\") ?? {};\n    return Object.keys(rackPositions)\n        .sort((a, b) => {\n            const letterA = a.charAt(0);\n            const letterB = b.charAt(0);\n            const numberA = parseInt(a.substring(1));\n            const numberB = parseInt(b.substring(1));\n\n            if (numberA === numberB) {\n                return letterA.localeCompare(letterB);\n            } else {\n                return numberA - numberB;\n            }\n        })\n        .map(k => rackPositions[k])\n        .filter(r => r.belegt?.value == false);\n}\n\n/**\n * @param {string} type\n * @param {string} workpieceId\n * @return {{valuesToWrite: Array<object>, nodesToWrite: Array<object>}}\n */\nfunction createPickCommand(type, workpieceId) {\n    const emptyRackPositions = getEmptyRackPositions();\n    const emptyRackPosition = emptyRackPositions[0];\n    node.status({ fill: \"grey\", shape: \"dot\", text: emptyRackPosition?.name?.value ?? \"UNKNOWN\" });\n    if (!emptyRackPosition) {\n        throw new Error(\"No empty rack\");\n    }\n    return {\n        nodesToWrite: [\n            { nodeId: 'ns=4;i=245' /* PICK-RACK */, \"datatypeName\": \"String\" },\n            { nodeId: 'ns=4;i=244'/* PICK */, \"datatypeName\": \"Boolean\" },\n            { nodeId: emptyRackPosition.belegt['#address'], \"datatypeName\": \"Boolean\" },\n            { nodeId: emptyRackPosition.type['#address'], \"datatypeName\": \"String\" },\n            { nodeId: emptyRackPosition.workpieceId['#address'], \"datatypeName\": \"String\" }\n        ],\n        valuesToWrite: [\n            { value: emptyRackPosition.name.value },\n            { value: true },\n            { value: true },\n            { value: type },\n            { value: workpieceId }\n        ]\n    };\n}\n\n/**\n * @typedef {object} OrderPayload\n * @property {string} timestamp\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} serialNumber\n * @property {{id: string, command: string, metadata: {type: string, workpieceId: string}}} action \n * \n * @param {OrderPayload} payload\n * @return {[type: string, workpieceId: string]}\n */\nfunction extractPickParams(payload) {\n    const actionMetadata = payload.action.metadata;\n    return [actionMetadata.type, actionMetadata.workpieceId];\n}\n\n// wenn nicht IDLE dann nichts tun\nconst currentModuleState = flow.get(\"moduleState\") ?? \"UNKNOWN\";\nnode.status({ fill: \"green\", shape: \"dot\", text: currentModuleState });\nif (currentModuleState == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RPICK\"); // modulestate zu \"RUNNING PICK\" setzen\n    node.status({ fill: \"grey\", shape: \"dot\", text: \"RPICK\" });\n\n    // Retrieve current Storage information and pick the next \n    try {\n        const [type, workpieceId] = extractPickParams(msg.payload);\n        node.status({ fill: \"green\", shape: \"dot\", text: `${type} / ${workpieceId}` });\n        const opcuaCommand = createPickCommand(type, workpieceId);\n        node.warn({ opcuaCommand });\n        msg.payload = {\n            \"nodetype\": \"inject\",\n            \"injectType\": \"write\",\n            ...opcuaCommand\n        };\n        return [msg, null];\n    } catch (err) {\n        flow.set(\"moduleState\", \"IDLE\");\n        createError(err.message);\n        return [null, msg];\n    }\n} else {\n    createError(\"Module is not IDLE\");\n    node.status({ fill: \"red\", shape: \"dot\", text: \"Not IDLE\" });\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 100,
        "wires": [
            [
                "0bfee30c97acf819"
            ],
            [
                "56ecaa1ead57ed47"
            ]
        ]
    },
    {
        "id": "d0fcfabca6515a6b",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "DROP",
        "func": "/**\n * @param {string} message\n * @param {\"WARNING\"|\"FATAL\"} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @typedef {object} RackPosition\n * @property {{\"#address\": string, value: string}} name\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n * @property {{\"#address\": string, value: string}} workpieceId\n */\n\n/** @param {string} type */\nfunction getRackPositionByType(type) {\n    /** @type Record<string, RackPosition> */\n    const rackPositions = flow.get(\"rack.positions\") ?? {};\n    return Object.keys(rackPositions)\n        .sort((a, b) => {\n            const letterA = a.charAt(0);\n            const letterB = b.charAt(0);\n            const numberA = parseInt(a.substring(1));\n            const numberB = parseInt(b.substring(1));\n\n            if (numberA === numberB) {\n                return letterA.localeCompare(letterB);\n            } else {\n                return numberA - numberB;\n            }\n        })\n        .map(k => rackPositions[k])\n        .filter(r => {\n            node.warn({ r });\n            return r.type?.value == type;\n        });\n}\n\n/**\n * @param {string} type\n * @return {{valuesToWrite: Array<object>, nodesToWrite: Array<object>}}\n */\nfunction createDropCommand(type) {\n    node.status({ fill: 'green', shape: 'dot', text: `${type}` });\n    const rackPositionsForType = getRackPositionByType(type);\n    node.warn({ rackPositionsForType });\n    const firstRackPositionForType = rackPositionsForType[0];\n    node.warn({ firstRackPositionForType });\n    node.status({ fill: 'gray', shape: 'dot', text: firstRackPositionForType?.name?.value ?? \"N/A\" });\n    if (!firstRackPositionForType) {\n        throw new Error(\"Type not available\");\n    }\n    // set the retrieved workpiece's ID to the flow state to access it when finishing the drop command \n    flow.set(\"workpieceId\", firstRackPositionForType?.workpieceId?.value);\n    return {\n        nodesToWrite: [\n            { nodeId: 'ns=4;i=248' /* DROP-RACK */, \"datatypeName\": \"String\" },\n            { nodeId: 'ns=4;i=249'/* DROP */, \"datatypeName\": \"Boolean\" },\n            { nodeId: firstRackPositionForType.belegt['#address'], \"datatypeName\": \"Boolean\" },\n            { nodeId: firstRackPositionForType.type['#address'], \"datatypeName\": \"String\" },\n            { nodeId: firstRackPositionForType.workpieceId['#address'], \"datatypeName\": \"String\" }\n        ],\n        valuesToWrite: [\n            { value: firstRackPositionForType.name.value },\n            { value: true },\n            { value: false },\n            { value: \"\" },\n            { value: \"\" }\n        ]\n    };\n}\n\n/**\n * @typedef {object} OrderPayload\n * @property {string} timestamp\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} serialNumber\n * @property {{id: string, command: string, metadata: {type: string, workpieceId: string}}} action \n * \n * @param {OrderPayload} payload\n * @return {string}\n */\nfunction extractDropParams(payload) {\n    const actionMetadata = payload.action.metadata;\n    return actionMetadata.type;\n}\n\n// wenn nicht IDLE dann nichts tun\nconst currentModuleState = flow.get(\"moduleState\") ?? \"UNKNOWN\";\nnode.status({ fill: \"grey\", shape: \"dot\", text: currentModuleState });\nif (currentModuleState == \"IDLE\") {\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"RDROP\"); // modulestate zu \"RUNNING PICK\" setzen\n\n    // Retrieve current Storage information and pick the next \n    try {\n        const type = extractDropParams(msg.payload);\n        const opcuaCommand = createDropCommand(type);\n        msg.payload = {\n            \"nodetype\": \"inject\",\n            \"injectType\": \"write\",\n            ...opcuaCommand\n        };\n        return [msg, null];\n    } catch (err) {\n        flow.set(\"moduleState\", \"IDLE\");\n        createError(err.message);\n        return [null, msg];\n    }\n} else {\n    createError(\"Module is not IDLE\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 160,
        "wires": [
            [
                "0bfee30c97acf819"
            ],
            [
                "56ecaa1ead57ed47"
            ]
        ]
    },
    {
        "id": "5aeb48f81bd2d80e",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "Order Update Check",
        "func": "// actionState in Flow speichern\nflow.set(\"actionState\", msg.payload.action);\n\n// orderUpdateId updaten\nflow.set(\"orderUpdateId\", msg.payload.orderUpdateId);\n\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 160,
        "wires": [
            [
                "313f88ce97978b34"
            ]
        ]
    },
    {
        "id": "56ecaa1ead57ed47",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"orderId\", 0);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1650,
        "y": 180,
        "wires": [
            [
                "90d6f05d70ab15ba"
            ]
        ]
    },
    {
        "id": "90d6f05d70ab15ba",
        "type": "link out",
        "z": "814355edd4de93bc",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2155,
        "y": 220,
        "wires": []
    },
    {
        "id": "411c18be26575f61",
        "type": "catch",
        "z": "814355edd4de93bc",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 140,
        "y": 120,
        "wires": [
            [
                "6c6b3d0bb3abda66"
            ]
        ]
    },
    {
        "id": "6c6b3d0bb3abda66",
        "type": "debug",
        "z": "814355edd4de93bc",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 370,
        "y": 120,
        "wires": []
    },
    {
        "id": "f1cca1aa2a07e601",
        "type": "switch",
        "z": "814355edd4de93bc",
        "name": "update-rack-state",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=262",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=263",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=261",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=265",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=264",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=266",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=268",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=267",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=269",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=271",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=270",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=272",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=274",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=273",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=275",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=277",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=276",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=278",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=280",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=279",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=281",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=283",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=282",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=284",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=286",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=285",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=287",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 27,
        "x": 770,
        "y": 1300,
        "wires": [
            [
                "92dd082cc8702421"
            ],
            [
                "92dd082cc8702421"
            ],
            [
                "92dd082cc8702421"
            ],
            [
                "c7c6465e4d6e7639"
            ],
            [
                "c7c6465e4d6e7639"
            ],
            [
                "c7c6465e4d6e7639"
            ],
            [
                "20309b34d4295499"
            ],
            [
                "20309b34d4295499"
            ],
            [
                "20309b34d4295499"
            ],
            [
                "e575576daaa8d16b"
            ],
            [
                "e575576daaa8d16b"
            ],
            [
                "e575576daaa8d16b"
            ],
            [
                "04efc342b88a99c2"
            ],
            [
                "04efc342b88a99c2"
            ],
            [
                "04efc342b88a99c2"
            ],
            [
                "88105ae3a1a24feb"
            ],
            [
                "88105ae3a1a24feb"
            ],
            [
                "88105ae3a1a24feb"
            ],
            [
                "d74c89dcc3a8f35c"
            ],
            [
                "d74c89dcc3a8f35c"
            ],
            [
                "d74c89dcc3a8f35c"
            ],
            [
                "71e78a2bd25f1ddb"
            ],
            [
                "71e78a2bd25f1ddb"
            ],
            [
                "71e78a2bd25f1ddb"
            ],
            [
                "87868ac137c42086"
            ],
            [
                "87868ac137c42086"
            ],
            [
                "87868ac137c42086"
            ]
        ],
        "outputLabels": [
            "A1_belegt",
            "A1_type",
            "A1_workpieceId",
            "A2_belegt",
            "A2_type",
            "A2_workpieceId",
            "A3_belegt",
            "A3_type",
            "A3.workpieceId",
            "B1_belegt",
            "B1_type",
            "B1_workpieceId",
            "B2_belegt",
            "B2_type",
            "B2_workpieceId",
            "B3_belegt",
            "B3_type",
            "B3_workpieceId",
            "C1_belegt",
            "C1_type",
            "C1_workpieceId",
            "C2_belegt",
            "C2_type",
            "C2_workpieceId",
            "C3_belegt",
            "C3_type",
            "C3_workpieceId"
        ]
    },
    {
        "id": "92dd082cc8702421",
        "type": "subflow:ea935d7649fccac4",
        "z": "814355edd4de93bc",
        "name": "A1",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "A1",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1120,
        "wires": []
    },
    {
        "id": "c7c6465e4d6e7639",
        "type": "subflow:ea935d7649fccac4",
        "z": "814355edd4de93bc",
        "name": "A2",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "A2",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1180,
        "wires": []
    },
    {
        "id": "20309b34d4295499",
        "type": "subflow:ea935d7649fccac4",
        "z": "814355edd4de93bc",
        "name": "A3",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "A3",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1240,
        "wires": []
    },
    {
        "id": "e575576daaa8d16b",
        "type": "subflow:ea935d7649fccac4",
        "z": "814355edd4de93bc",
        "name": "B1",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "B1",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1300,
        "wires": []
    },
    {
        "id": "04efc342b88a99c2",
        "type": "subflow:ea935d7649fccac4",
        "z": "814355edd4de93bc",
        "name": "B2",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "B2",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1360,
        "wires": []
    },
    {
        "id": "88105ae3a1a24feb",
        "type": "subflow:ea935d7649fccac4",
        "z": "814355edd4de93bc",
        "name": "B3",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "B3",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1420,
        "wires": []
    },
    {
        "id": "d74c89dcc3a8f35c",
        "type": "subflow:ea935d7649fccac4",
        "z": "814355edd4de93bc",
        "name": "C1",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "C1",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1480,
        "wires": []
    },
    {
        "id": "71e78a2bd25f1ddb",
        "type": "subflow:ea935d7649fccac4",
        "z": "814355edd4de93bc",
        "name": "C2",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "C2",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1540,
        "wires": []
    },
    {
        "id": "87868ac137c42086",
        "type": "subflow:ea935d7649fccac4",
        "z": "814355edd4de93bc",
        "name": "C3",
        "env": [
            {
                "name": "RACK_POSITION",
                "value": "C3",
                "type": "str"
            }
        ],
        "x": 1010,
        "y": 1600,
        "wires": []
    },
    {
        "id": "4a1f8d2800bf9751",
        "type": "debug",
        "z": "814355edd4de93bc",
        "name": "write-order",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1810,
        "y": 80,
        "wires": []
    },
    {
        "id": "29a9c6560208561f",
        "type": "inject",
        "z": "814355edd4de93bc",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "0.2",
        "crontab": "",
        "once": true,
        "onceDelay": "0.2",
        "topic": "rack.positions",
        "payload": "rack.positions",
        "payloadType": "flow",
        "x": 290,
        "y": 620,
        "wires": [
            [
                "273d8bd3c8cac544"
            ]
        ]
    },
    {
        "id": "273d8bd3c8cac544",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "order-rackpositions",
        "func": "const rackPositions = msg.payload ?? {};\n\nmsg.payload = Object.keys(rackPositions).reduce((sorted, key) => {\n    return {\n        ...sorted,\n        [key]: rackPositions[key]\n    }\n}, {});\nmsg.topic = \"ordered-rackpositions\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 620,
        "wires": [
            [
                "2e622e1899bc5a3e"
            ]
        ]
    },
    {
        "id": "2e622e1899bc5a3e",
        "type": "change",
        "z": "814355edd4de93bc",
        "name": "set-positions",
        "rules": [
            {
                "t": "set",
                "p": "rack.positions",
                "pt": "flow",
                "to": "payload",
                "tot": "msg",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 710,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "49d06d9e725f65af",
        "type": "OPCUA-IIoT-Write",
        "z": "814355edd4de93bc",
        "connector": "ac4f033c5eb8a63f",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1670,
        "y": 540,
        "wires": [
            [
                "f7f256df2b179551",
                "d0ca1c162cd14618"
            ]
        ]
    },
    {
        "id": "209039d621dfe5de",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "set-storage",
        "func": "/**\n * @typedef {object} RackPosition\n * @property {{value: string}} name\n * @property {{\"#address\": string, value: string}} workpieceId\n * @property {{\"#address\": string, value: boolean}} belegt\n * @property {{\"#address\": string, value: string}} type\n */\n\n/**\n * @typedef {object} Load\n * @property {string} loadType\n * @property {string} loadId\n * @property {string} [loadPosition]\n * \n * @param {string} rackPosition\n * @param {string} workpieceId\n * @param {string} type\n */\nfunction createLoad(rackPosition, workpieceId, type) {\n    return {\n        loadType: type,\n        loadId: workpieceId,\n        loadPosition: rackPosition,\n    };\n}\n\n/**\n * @param {Record<string, { type: string, workpieceId: string}>} contents\n * @returns {Load[]}\n */\nfunction fillLoads(contents) {\n    return Object.entries(contents).map(([key, val]) => createLoad(key, val.workpieceId ?? \"\", val.type ?? \"\"));\n}\n\n/**\n * @typedef {object} OpcuaCommand\n * @property {array} nodesToWrite\n * @property {array} valuesToWrite\n * \n * @param {Load[]} loads\n * @returns {OpcuaCommand}\n */\nfunction createOpcuaCommand(loads) {\n    const rackPositions = flow.get(\"rack.positions\") ?? {};\n    const nodesToWrite = [];\n    const valuesToWrite = [];\n\n    for (let [rackPos, entry] of Object.entries(rackPositions)) {\n        const targetLoad = loads.find(l => l.loadPosition == rackPos);\n        nodesToWrite.push({ nodeId: entry.workpieceId['#address'], datatypeName: \"String\" });\n        valuesToWrite.push({ value: targetLoad?.loadId ?? \"\" });\n        nodesToWrite.push({ nodeId: entry.type['#address'], datatypeName: \"String\" });\n        valuesToWrite.push({ value: targetLoad?.loadType ?? \"\" });\n        nodesToWrite.push({ nodeId: entry.belegt['#address'], datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: !!targetLoad && !!targetLoad?.loadType });\n    }\n\n    return { nodesToWrite, valuesToWrite };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\") {\n    const actionMetadata = msg.actionMetadata ?? { contents: {} };\n    const newLoads = fillLoads(actionMetadata.contents);\n    const { nodesToWrite, valuesToWrite } = createOpcuaCommand(newLoads);\n\n    msg.loads = newLoads;\n    msg.actionCommand = \"SET_STORAGE\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not IDLE and cannot be filled with workpieces\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 720,
        "wires": [
            [
                "49d06d9e725f65af",
                "dee6e8c149022f55"
            ],
            [
                "3c4ca5482eac1698"
            ]
        ]
    },
    {
        "id": "6266abd30bce06ff",
        "type": "subflow:7173b966cb38f0e0",
        "z": "814355edd4de93bc",
        "name": "",
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "value": "REF,RACK_REIHE_A_SPALTE_1,RACK_REIHE_B_SPALTE_2,RACK_REIHE_C_SPALTE_3,RAMPE,PICK,DROP,PARK",
                "type": "str"
            },
            {
                "name": "CURRENT_POSITION",
                "value": "REF",
                "type": "str"
            }
        ],
        "x": 790,
        "y": 860,
        "wires": []
    },
    {
        "id": "f7f256df2b179551",
        "type": "debug",
        "z": "814355edd4de93bc",
        "name": "after-write-order",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1960,
        "y": 600,
        "wires": []
    },
    {
        "id": "c3ce3a555839d610",
        "type": "delay",
        "z": "814355edd4de93bc",
        "name": "Verzögerung",
        "pauseType": "delay",
        "timeout": "250",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 1210,
        "y": 1080,
        "wires": [
            [
                "82fc1b870cdf8463"
            ]
        ]
    },
    {
        "id": "c8557f1291a116bd",
        "type": "subflow:fb6b02d4d9963179",
        "z": "814355edd4de93bc",
        "name": "",
        "x": 2270,
        "y": 540,
        "wires": [
            [
                "ed655a1d4b5ba332"
            ]
        ]
    },
    {
        "id": "d1207ea7a6287ad8",
        "type": "subflow:fb6b02d4d9963179",
        "z": "814355edd4de93bc",
        "name": "",
        "x": 1710,
        "y": 1080,
        "wires": [
            [
                "93b293c477a8fd8f"
            ]
        ]
    },
    {
        "id": "3aaf45b5fe63b8ed",
        "type": "subflow:fb6b02d4d9963179",
        "z": "814355edd4de93bc",
        "name": "",
        "x": 1670,
        "y": 380,
        "wires": [
            [
                "90d6f05d70ab15ba"
            ]
        ]
    },
    {
        "id": "60e1c5853f61ca6d",
        "type": "subflow:07a7fc5bcd60a12a",
        "z": "814355edd4de93bc",
        "name": "",
        "x": 2010,
        "y": 480,
        "wires": [
            [
                "ed655a1d4b5ba332"
            ]
        ]
    },
    {
        "id": "82fc1b870cdf8463",
        "type": "subflow:105d02aba31c4a1d",
        "z": "814355edd4de93bc",
        "x": 1430,
        "y": 1080,
        "wires": [
            [
                "d1207ea7a6287ad8"
            ]
        ]
    },
    {
        "id": "49cc1767ae56fc66",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "Publish vda_status_RUNNING",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n//state bauen\nlet headerId = flow.get(\"headerId\");\nlet actionState = flow.get(\"actionState\");\nactionState.id = msg.actionId ?? actionState.id;\nlet state = flow.get(\"state\");\n\nactionState.state = \"RUNNING\";\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\nmsg.payload = state;\n\n// flowVariable Update\nflow.set(\"headerId\", headerId + 1);\nflow.set(\"errors\", null);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1870,
        "y": 120,
        "wires": [
            [
                "90d6f05d70ab15ba"
            ]
        ]
    },
    {
        "id": "f31e44935a621587",
        "type": "debug",
        "z": "814355edd4de93bc",
        "name": "opcua-status",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 940,
        "wires": []
    },
    {
        "id": "dee6e8c149022f55",
        "type": "debug",
        "z": "814355edd4de93bc",
        "name": "before-write-order",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1690,
        "y": 640,
        "wires": []
    },
    {
        "id": "d0ca1c162cd14618",
        "type": "delay",
        "z": "814355edd4de93bc",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1820,
        "y": 540,
        "wires": [
            [
                "1900033baecd3f8e"
            ]
        ]
    },
    {
        "id": "1900033baecd3f8e",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "update-calibration-data",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions() {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    const currentPosition = flow.get(\"calibration.positions.current\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": currentPosition },\n        ]\n    }\n}\n\nmsg.calibrationData = [createCalibrationData(), createCalibrationPositions()];\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2000,
        "y": 540,
        "wires": [
            [
                "c8557f1291a116bd"
            ]
        ]
    },
    {
        "id": "197f631d3bf14322",
        "type": "OPCUA-IIoT-Inject",
        "z": "814355edd4de93bc",
        "g": "b1275603c54863e5",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 360,
        "wires": [
            [
                "cf8e6cdf952dc7ec",
                "56a54db18c10d5c1"
            ]
        ]
    },
    {
        "id": "cf8e6cdf952dc7ec",
        "type": "OPCUA-IIoT-Read",
        "z": "814355edd4de93bc",
        "g": "b1275603c54863e5",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "ac4f033c5eb8a63f",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 320,
        "wires": [
            [
                "56a54db18c10d5c1"
            ]
        ]
    },
    {
        "id": "56a54db18c10d5c1",
        "type": "subflow:468f2460ce66f11e",
        "z": "814355edd4de93bc",
        "g": "b1275603c54863e5",
        "name": "",
        "x": 590,
        "y": 360,
        "wires": [
            [
                "90d6f05d70ab15ba"
            ]
        ]
    },
    {
        "id": "3977eec6a3a60574",
        "type": "OPCUA-IIoT-Inject",
        "z": "814355edd4de93bc",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=116",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=315",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 200,
        "wires": [
            [
                "b451db407b274886"
            ]
        ]
    },
    {
        "id": "9d836696d4a84878",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"HBW\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"HBW\");\nflow.set(\"errors\", []);\n\n// state bauen\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": {},\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"operatingMode\": \"AUTOMATIC\",\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    },\n    \"information\": []\n});\n\nconst factsheet = msg.factsheet ?? {};\nfactsheet.serialNumber = \"Unknown\";\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.82\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\n\nflow.set(\"opcuaState\", \"connected\");\nreturn ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "104a545cfdf1eb67",
        "type": "function",
        "z": "814355edd4de93bc",
        "name": "reset",
        "func": "msg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: \"ns=4;i=259\", \"datatypeName\": \"Boolean\" }\n    ],\n    valuesToWrite: [\n        { value: true }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1230,
        "y": 760,
        "wires": [
            [
                "66c5ef1c6d40d186",
                "dee6e8c149022f55"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite"
        ]
    },
    {
        "id": "66c5ef1c6d40d186",
        "type": "OPCUA-IIoT-Write",
        "z": "814355edd4de93bc",
        "connector": "ac4f033c5eb8a63f",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1670,
        "y": 760,
        "wires": [
            [
                "f7f256df2b179551"
            ]
        ]
    },
    {
        "id": "beb8c6214059f8db",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "variable setup",
        "func": "// Nötige Werte im Flow speichern\nflow.set(\"flowName\", \"DPS\");\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"orderUpdateId\", 0);\nflow.set(\"orderId\", \"0\");\nflow.set(\"loads\", []);\nflow.set(\"headerId\", 1);\nflow.set(\"actionState\", {});\nflow.set(\"modell\", \"DPS\");\nflow.set(\"errors\", []);\n\n// state bauen\nflow.set(\"state\", {\n    \"headerId\": 0,\n    \"loads\": [],\n    \"actionState\": null,\n    \"serialNumber\": \"notReadYet\",\n    \"batterystate\": {},\n    \"timestamp\": \"timestamp\",\n    \"errors\": [],\n    \"orderUpdateId\": 0,\n    \"orderId\": \"\",\n    \"paused\": false,\n    \"metadata\": {\n        \"opcuaState\": \"connected\"\n    }\n});\n\nconst factsheet = msg.factsheet ?? {};\nflow.set(\"factsheet\", factsheet);\n\nflow.set(\"connection\", {\n    \"headerId\": 0,\n    \"timestamp\": \"timestamp\",\n    \"ip\": \"192.168.0.90\",\n    \"version\": \"1.0.0\",\n    \"manufacturer\": \"Fischertechnik\",\n    \"serialNumber\": \"serialNumber\",\n    \"connectionState\": \"ONLINE\"\n});\n\nflow.set(\"opcuaState\", \"connected\");\nreturn ;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 100,
        "wires": [
            []
        ]
    },
    {
        "id": "ed3ffb6b7cb5bb18",
        "type": "subflow:6a25ecd632542087",
        "z": "616d25e29ffaadda",
        "name": "",
        "env": [
            {
                "name": "FACTSHEET_FILE",
                "value": "/data/factsheets/factsheet-dps.json",
                "type": "str"
            }
        ],
        "x": 140,
        "y": 100,
        "wires": [
            [
                "beb8c6214059f8db"
            ]
        ]
    },
    {
        "id": "2cac656d13e5c930",
        "type": "OPCUA-IIoT-Listener",
        "z": "616d25e29ffaadda",
        "connector": "b58c2380ef5679ca",
        "action": "subscribe",
        "queueSize": 10,
        "name": "",
        "topic": "",
        "justValue": true,
        "useGroupItems": false,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 620,
        "y": 1700,
        "wires": [
            [
                "ae6dd357dd699f21",
                "39a1d53d0cb4dcd9",
                "3b0e67df7c87f63d"
            ]
        ]
    },
    {
        "id": "ae30585893fe4101",
        "type": "OPCUA-IIoT-Inject",
        "z": "616d25e29ffaadda",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            },
            {
                "name": "version",
                "nodeId": "ns=4;i=51",
                "datatypeName": "String"
            }
        ],
        "x": 170,
        "y": 240,
        "wires": [
            [
                "376c79d4c88dc6fb"
            ]
        ]
    },
    {
        "id": "376c79d4c88dc6fb",
        "type": "OPCUA-IIoT-Read",
        "z": "616d25e29ffaadda",
        "attributeId": "0",
        "maxAge": "1000",
        "depth": 1,
        "connector": "b58c2380ef5679ca",
        "name": "read serialNumber",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 430,
        "y": 240,
        "wires": [
            [
                "fd646b22baf24c2c"
            ]
        ]
    },
    {
        "id": "6e95c88907b3deb5",
        "type": "switch",
        "z": "616d25e29ffaadda",
        "name": "statusSwitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "ns=4;i=46",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=5",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=6",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=45",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=50",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=48",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=49",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=13",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=14",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=10",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=11",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=41",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=43",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=16",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "ns=4;i=17",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 16,
        "x": 1090,
        "y": 1720,
        "wires": [
            [],
            [],
            [],
            [
                "422b946874fd89bd"
            ],
            [
                "e5dd9588fee4aeb9",
                "f1bf3def467a1762"
            ],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ],
        "inputLabels": [
            "opcua-in"
        ],
        "outputLabels": [
            "ausgang",
            "bewegen_aktiv",
            "bewegen_finished",
            "busy",
            "eingang",
            "farbbereich_blau",
            "farbbereich_rot",
            "farbbereich_weiss",
            "hbw_aktiv",
            "hbw_finished",
            "home_aktiv",
            "home_finished",
            "kalib_anfahren_finished",
            "kalib_beenden_finished",
            "kalibriere_aktiv",
            "kalibriere_finished"
        ]
    },
    {
        "id": "422b946874fd89bd",
        "type": "change",
        "z": "616d25e29ffaadda",
        "name": "OPCUA state IDLE",
        "rules": [
            {
                "t": "set",
                "p": "SPS_idle",
                "pt": "flow",
                "to": "nodeValue",
                "tot": "msg"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1390,
        "y": 1620,
        "wires": [
            []
        ]
    },
    {
        "id": "ae6dd357dd699f21",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "listener out",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 1660,
        "wires": []
    },
    {
        "id": "d1c398da6ad79c89",
        "type": "OPCUA-IIoT-Browser",
        "z": "616d25e29ffaadda",
        "nodeId": "ns=4;i=1",
        "name": "browse",
        "justValue": true,
        "sendNodesToRead": false,
        "sendNodesToBrowser": false,
        "sendNodesToListener": true,
        "multipleOutputs": false,
        "showStatusActivities": true,
        "showErrors": true,
        "recursiveBrowse": false,
        "recursiveDepth": 1,
        "delayPerMessage": 0.2,
        "connector": "b58c2380ef5679ca",
        "x": 460,
        "y": 1700,
        "wires": [
            [
                "2cac656d13e5c930",
                "3b0e67df7c87f63d",
                "368132ae9f01185f"
            ]
        ]
    },
    {
        "id": "90a9040113858c4b",
        "type": "OPCUA-IIoT-Inject",
        "z": "616d25e29ffaadda",
        "injectType": "inject",
        "payload": "{\"interval\":100}",
        "payloadType": "json",
        "topic": "",
        "repeat": "",
        "crontab": "",
        "once": true,
        "startDelay": "10",
        "name": "inject",
        "addressSpaceItems": [],
        "x": 310,
        "y": 1700,
        "wires": [
            [
                "d1c398da6ad79c89"
            ]
        ]
    },
    {
        "id": "66b392bb4886c28c",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 1835,
        "y": 1680,
        "wires": []
    },
    {
        "id": "fd646b22baf24c2c",
        "type": "subflow:1b897516f5bf21fa",
        "z": "616d25e29ffaadda",
        "name": "",
        "x": 680,
        "y": 240,
        "wires": [
            [
                "dad6a4fb2a044684",
                "cd0e48ca11c1b1ad"
            ],
            [
                "8109c87e0d84cd91",
                "dad6a4fb2a044684"
            ],
            [
                "5743940d1df62fa0"
            ],
            [
                "b8a46edee9327136"
            ]
        ]
    },
    {
        "id": "b11f1980ad03aa7a",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "vda_action factsheetRequest",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// factsheet timestamp aktualisieren\nlet factsheet = flow.get(\"factsheet\");\nfactsheet.timestamp = new Date().toISOString();\nflow.set(\"factsheet\", factsheet);\n\n//publish on topic\nmsg.topic = flow.get(\"MQTT_topic\") + \"/factsheet\";\nmsg.payload = factsheet;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 340,
        "wires": [
            [
                "d0294086443d968b",
                "7a082f983aa142c0"
            ]
        ]
    },
    {
        "id": "d0294086443d968b",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2315,
        "y": 380,
        "wires": []
    },
    {
        "id": "8109c87e0d84cd91",
        "type": "switch",
        "z": "616d25e29ffaadda",
        "name": "instantActionSwitch",
        "property": "instantAction",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "factsheetRequest",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "startCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "storeCalibrationValues",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "selectCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "testCalibrationPosition",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "resetCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "announceOutput",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "cancelStorageOrder",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "setStatusLED",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "reset",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 12,
        "x": 930,
        "y": 520,
        "wires": [
            [
                "b11f1980ad03aa7a"
            ],
            [
                "22d8cc54397dcd63",
                "6b4027de8d6ed9a9",
                "c71907b47cada35d"
            ],
            [
                "b7e7fa6787250d5e",
                "6b4027de8d6ed9a9"
            ],
            [
                "8b8e8266e47a3df6",
                "6b4027de8d6ed9a9",
                "fcbb28ea3b4f0f39"
            ],
            [
                "380b13f49f6bccc1",
                "6b4027de8d6ed9a9",
                "fcbb28ea3b4f0f39"
            ],
            [
                "f28df58a07fa929a"
            ],
            [
                "a6937453441357a0"
            ],
            [
                "e5088763ecbf213e",
                "6b4027de8d6ed9a9"
            ],
            [
                "d52c59f9fdaf1ec4"
            ],
            [
                "99b3a9d7b07dce6b"
            ],
            [
                "968729850bf85226",
                "2b95ee7a787aed1a"
            ],
            [
                "6b4027de8d6ed9a9",
                "dea6fd6d90068cda"
            ]
        ]
    },
    {
        "id": "22d8cc54397dcd63",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "startCalibration",
        "func": "/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    const isCalibActive = flow.get(\"calibration.state.status__kalibriere_aktiv.nodeValue\") ?? false;\n    return {\n        nodesToWrite: [\n            { name: \"befehl__KALIBRIERE\", nodeId: \"ns=4;i=15\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: !isCalibActive }\n        ]\n    };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"IDLE\" || moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"CALIBRATION\");\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not IDLE and cannot be set to CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 420,
        "wires": [
            [
                "6748aa914e24d9ba"
            ],
            []
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "b7e7fa6787250d5e",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "stopCalibration",
        "func": "/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    return {\n        nodesToWrite: [\n            { name: \"befehl__kalib_BEENDEN\", nodeId: \"ns=4;i=42\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    flow.set(\"moduleState\", \"IDLE\");\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 460,
        "wires": [
            [
                "6748aa914e24d9ba"
            ],
            []
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "6748aa914e24d9ba",
        "type": "OPCUA-IIoT-Write",
        "z": "616d25e29ffaadda",
        "connector": "b58c2380ef5679ca",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1730,
        "y": 480,
        "wires": [
            []
        ]
    },
    {
        "id": "8b8e8266e47a3df6",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "setCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        const references = metadata.references.filter(ref => ref.referenceKey.indexOf(\"kalib__\") > -1);\n        for (let ref of references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int16\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 500,
        "wires": [
            [
                "6748aa914e24d9ba",
                "bd22af298bcaaeec"
            ],
            []
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "380b13f49f6bccc1",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "storeCalibrationValues",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.references?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n        const references = metadata.references.filter(ref => ref.referenceKey.indexOf(\"kalib__\") > -1);\n        for (let ref of references) {\n            /** @type {CalibrationValue} */\n            const toUpdate = flow.get(`calibration.state.${ref.referenceKey}`);\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int32\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n            nodesToWrite.push({ nodeId: toUpdate.nodeId, \"datatypeName\": \"Int16\" });\n            valuesToWrite.push({ value: ref.referenceValue });\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const metadata = msg.actionMetadata;\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite,\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 540,
        "wires": [
            [
                "6748aa914e24d9ba",
                "bd22af298bcaaeec"
            ],
            []
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "f28df58a07fa929a",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "selectCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nfunction createCalibrationData() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {Reference[]} */\n    const infoReferences = Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"calib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            /** @tye {Reference} */\n            const refData = {\n                referenceKey: nodeName,\n                referenceValue: nodeValue,\n            };\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n    return {\n        infoType: \"calibration_data\",\n        infoLevel: \"DEBUG\",\n        infoReferences,\n    };\n}\n\n/**\n * @param {string} newCurrentPosition\n * @returns {CalibrationData}\n */\nfunction createCalibrationPositions(newCurrentPosition) {\n    const availablePositions = flow.get(\"calibration.positions.available\");\n    return {\n        infoType: \"calibration_status\",\n        infoLevel: \"DEBUG\",\n        infoReferences: [\n            { \"referenceKey\": \"POSITIONS.AVAILABLE\", \"referenceValue\": availablePositions },\n            { \"referenceKey\": \"POSITIONS.CURRENT\", \"referenceValue\": newCurrentPosition },\n        ]\n    }\n}\n\n/**\n * @param {ActionMetadata} metadata\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate(metadata) {\n    if (metadata.position?.length > 0) {\n        const nodesToWrite = [];\n        const valuesToWrite = [];\n\n        switch (metadata.position) {\n            case \"CAMERA_HOME\": {\n                const posX = flow.get(\"calibration.state.kalib__position_home_X.nodeValue\") ?? 0;\n                const posY = flow.get(\"calibration.state.kalib__position_home_Y.nodeValue\") ?? 0;\n                nodesToWrite.push({ nodeId: \"ns=4;i=39\", \"datatypeName\": \"Int32\" })\n                valuesToWrite.push({ value: posX });\n                nodesToWrite.push({ nodeId: \"ns=4;i=40\", \"datatypeName\": \"Int32\" })\n                valuesToWrite.push({ value: posY });\n                break;\n            }\n            case \"CAMERA_HBW\": {\n                const posX = flow.get(\"calibration.state.kalib__position_hbw_X.nodeValue\") ?? 0;\n                const posY = flow.get(\"calibration.state.kalib__position_hbw_Y.nodeValue\") ?? 0;\n                nodesToWrite.push({ nodeId: \"ns=4;i=39\", \"datatypeName\": \"Int32\" })\n                valuesToWrite.push({ value: posX });\n                nodesToWrite.push({ nodeId: \"ns=4;i=40\", \"datatypeName\": \"Int32\" })\n                valuesToWrite.push({ value: posY });\n                break;\n            }\n            case \"PARK\": {\n                nodesToWrite.push({ nodeId: \"ns=4;i=56\", \"datatypeName\": \"Boolean\" });\n                valuesToWrite.push({ value: true });\n                break;\n            }\n        }\n        return { nodesToWrite, valuesToWrite };\n    }\n    return { nodesToWrite: [], valuesToWrite: [] };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        return [null, msg, null];\n    }\n    // The park position needs to be set for both OPCUA and TXT4.0\n    const forwardMsg = (metadata.position == \"PARK\") ? RED.util.cloneMessage(msg) : null;\n\n    const newPosition = metadata.position;\n    flow.set(\"calibration.positions.current\", newPosition);\n\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate(metadata);\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    \n    return [msg, forwardMsg, null];\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, null, msg];\n}",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1310,
        "y": 580,
        "wires": [
            [
                "6748aa914e24d9ba"
            ],
            [
                "6b4027de8d6ed9a9"
            ],
            [
                "89f3370e02e6073c"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "forwardToTXT",
            "error"
        ]
    },
    {
        "id": "a6937453441357a0",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "testCalibrationPosition",
        "func": "/**\n * @typedef {object} Reference\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {Reference[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n *\n * @typedef {object} PositionTargetData\n * @property {number | string | undefined} position_dreh\n * @property {number | string | undefined} position_x\n * @property {number | string | undefined} position_y\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\n/**\n * @returns {{ nodesToWrite: Array, valuesToWrite: Array }}\n */\nfunction createOpcuaUpdate() {\n    return {\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=38\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    /** @type {ActionMetadata} */\n    const metadata = msg.actionMetadata;\n    /** @type {string[]} */\n    const availablePosition = flow.get(\"calibration.positions.available\");\n    if (availablePosition.indexOf(metadata.position) == -1) {\n        return [null, msg, null];\n    }\n\n    const { nodesToWrite, valuesToWrite } = createOpcuaUpdate();\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite,\n        valuesToWrite\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, null, msg];\n}",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 640,
        "wires": [
            [
                "6748aa914e24d9ba"
            ],
            [
                "6b4027de8d6ed9a9"
            ],
            [
                "89f3370e02e6073c"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error",
            ""
        ]
    },
    {
        "id": "e5088763ecbf213e",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "resetCalibration",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} message\n * @param {string} [errorLevel]\n */\nfunction createError(message, errorLevel = \"WARNING\") {\n    const flowErrors = flow.get(\"errors\") ?? [];\n    const existingErrors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n    const error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": errorLevel,\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": message\n    }\n    flow.set(\"errors\", [...existingErrors, error]);\n    return error;\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    msg.actionCommand = \"resetCalibration\";\n    msg.payload = {\n        nodetype: 'inject',\n        injectType: 'write',\n        nodesToWrite: [\n            { nodeId: \"ns=4;i=52\", \"datatypeName\": \"Boolean\" }\n        ],\n        valuesToWrite: [\n            { value: true }\n        ]\n    };\n    return msg;\n} else {\n    createError(\"Module is not in CALIBRATION mode\");\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 680,
        "wires": [
            [
                "6748aa914e24d9ba"
            ],
            [
                "89f3370e02e6073c"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "4fc97cbca0d7fbc2",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "Publish vda_status_RUNNING",
        "func": "/**\n * @typedef {object} ActionState\n * @property {string} id\n * @property {string} state\n * @property {string} command\n * @property {object} [metadata]\n * \n * @param {string} state\n * @returns {ActionState}\n */\nfunction updateActionState(state, metadata = undefined) {\n    const actionState = flow.get(\"actionState\") ?? {};\n    actionState.id = msg.actionId;\n    actionState.state = state;\n    actionState.command = msg.actionCommand;\n    actionState.metadata = metadata ?? undefined;\n    flow.set(\"actionState\", actionState);\n    return actionState;\n}\n\nconst actionState = updateActionState(\"RUNNING\");\n\n// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = actionState;\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\n\n\n// flowVariable Update\nflow.set(\"errors\", {});\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.payload = state;\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2170,
        "y": 120,
        "wires": [
            [
                "1db7ab2115fb2f64"
            ]
        ]
    },
    {
        "id": "cd0e48ca11c1b1ad",
        "type": "switch",
        "z": "616d25e29ffaadda",
        "name": "orderswitch",
        "property": "payload.action.command",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1330,
        "y": 180,
        "wires": [
            [
                "1599913f0d45d8dc"
            ],
            [
                "db4aad5bb14c7939"
            ]
        ]
    },
    {
        "id": "1599913f0d45d8dc",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "PICK",
        "func": "// wenn nicht IDLE dann nichts tun\nif (flow.get(\"moduleState\") == \"IDLE\" || flow.get(\"moduleState\") == \"OUTPUT_ANNOUNCED\") {\n    node.status({fill:\"green\",shape:\"ring\",text:\"PICK\"});\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"BUSY\");\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Module is not IDLE\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1590,
        "y": 100,
        "wires": [
            [
                "4fc97cbca0d7fbc2",
                "1ca985ca428dc482",
                "14e3b24a283e9316"
            ],
            [
                "3a49fd53217d5843"
            ]
        ]
    },
    {
        "id": "db4aad5bb14c7939",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "DROP",
        "func": "if (flow.get(\"moduleState\") == \"WP_INPUT_SENT\") {\n    node.status({fill:\"green\",shape:\"ring\",text:\"DROP\"});\n    // ModulState busy setzen\n    flow.set(\"moduleState\", \"BUSY\");\n    return [msg, null];\n} else {\n    let error = {\n        \"errorType\": \"Validation\",\n        \"errorLevel\": \"WARNING\",\n        \"errorReferences\": [\n            { \"topic\": \"order\" },\n            { \"headerId\": flow.get(\"headerId\") },\n            { \"orderId\": flow.get(\"orderId\") },\n            { \"orderUpdateId\": flow.get(\"orderUpdateId\") }\n        ],\n        \"errorMessage\": \"Internal modulestate does not accept DROP\"\n    }\n    flow.set(\"errors\", error);\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 280,
        "wires": [
            [
                "4fc97cbca0d7fbc2",
                "1ca985ca428dc482",
                "14e3b24a283e9316"
            ],
            [
                "3a49fd53217d5843"
            ]
        ]
    },
    {
        "id": "3a49fd53217d5843",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2130,
        "y": 220,
        "wires": [
            [
                "1db7ab2115fb2f64"
            ]
        ]
    },
    {
        "id": "1db7ab2115fb2f64",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2425,
        "y": 160,
        "wires": []
    },
    {
        "id": "5743940d1df62fa0",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 905,
        "y": 280,
        "wires": []
    },
    {
        "id": "fecd8fe318047469",
        "type": "catch",
        "z": "616d25e29ffaadda",
        "name": "Catch all Errors",
        "scope": null,
        "uncaught": true,
        "x": 160,
        "y": 160,
        "wires": [
            [
                "f2d1983430b552f9"
            ]
        ]
    },
    {
        "id": "f2d1983430b552f9",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "display-error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 400,
        "y": 160,
        "wires": []
    },
    {
        "id": "bb1e14a23472345f",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "internal state txt",
        "func": "msg.topic = flow.get(\"TXT_MQTT_topic\") + \"/state\";\nmsg.action = \"subscribe\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 1040,
        "wires": [
            [
                "299876d0477a3253"
            ]
        ]
    },
    {
        "id": "b8a46edee9327136",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "internal connection txt",
        "func": "const spsSerialNumber = flow.get(\"serialNumber\");\nflow.set('TXT_MQTT_topic', `module/v1/ff/NodeRed/${spsSerialNumber}`);\n\nmsg.topic = flow.get(\"TXT_MQTT_topic\") + \"/instantAction\";\nmsg.payload = {\n    \"host\": flow.get(\"serialNumber\"),\n    \"serialNumber\": spsSerialNumber,\n    \"timestamp\": new Date().toISOString(),\n    \"actions\": [\n        {\n            \"actionId\": \"SOME_ID\",\n            \"actionType\": \"factsheetRequest\",\n            \"metadata\": {}\n        }\n    ]\n}\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 980,
        "wires": [
            [
                "bb1e14a23472345f",
                "1d592cc1870f9f5e",
                "75b7426ef58f12b5"
            ]
        ]
    },
    {
        "id": "299876d0477a3253",
        "type": "mqtt in",
        "z": "616d25e29ffaadda",
        "name": "dynamic Connection",
        "topic": "",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 1,
        "x": 1450,
        "y": 1040,
        "wires": [
            [
                "be811a9e51b23fa5",
                "278a3eca463b8d25"
            ]
        ]
    },
    {
        "id": "1d592cc1870f9f5e",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "internal connection establish",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1110,
        "y": 1160,
        "wires": []
    },
    {
        "id": "1f97a4188eef17aa",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "MQTT_retained",
        "mode": "link",
        "links": [
            "1a56d5a4f8592caa"
        ],
        "x": 2415,
        "y": 980,
        "wires": []
    },
    {
        "id": "dad6a4fb2a044684",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "after-handle-actions",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 900,
        "y": 160,
        "wires": []
    },
    {
        "id": "1ca985ca428dc482",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "send-order-to-txt",
        "func": "/** @type {string} */\nconst txtTopicBase = flow.get(\"TXT_MQTT_topic\");\n/** @type {string} */\nconst spsSerial = flow.get(\"serialNumber\");\nmsg.topic = `${txtTopicBase}/order`;\nmsg.payload.serialNumber = spsSerial;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2120,
        "y": 40,
        "wires": [
            [
                "53b8ba0d43c3adbd"
            ]
        ]
    },
    {
        "id": "1ca172d39bde80f8",
        "type": "switch",
        "z": "616d25e29ffaadda",
        "name": "calibSwitch",
        "property": "payload.nodeId",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 14,
        "x": 1090,
        "y": 1980,
        "wires": [
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ],
        "inputLabels": [
            "opcua-in"
        ],
        "outputLabels": [
            "farbe_blau_richtwert",
            "farbe_rot_richtwert",
            "farbe_weiss_richtwert",
            "farbwert",
            "grenze_x_oben",
            "grenze_x_unten",
            "grenze_y_oben",
            "grenze_y_unten",
            "position_hbw_x",
            "position_hbw_y",
            "position_home_x",
            "position_home_y",
            "zeit_prozessWarteZeitKurz",
            "zeit_prozessWarteZeitLang"
        ]
    },
    {
        "id": "39a1d53d0cb4dcd9",
        "type": "change",
        "z": "616d25e29ffaadda",
        "name": "extract-opcua-values",
        "rules": [
            {
                "t": "set",
                "p": "nodeId",
                "pt": "msg",
                "to": "payload.nodeId",
                "tot": "msg",
                "dc": true
            },
            {
                "t": "set",
                "p": "nodeValue",
                "pt": "msg",
                "to": "payload.value.value.value",
                "tot": "msg",
                "dc": true
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 840,
        "y": 1720,
        "wires": [
            [
                "6e95c88907b3deb5",
                "1ca172d39bde80f8"
            ]
        ]
    },
    {
        "id": "b04f17f4308fda6e",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "move-workpiece-to-rgb",
        "func": "/**\n * @typedef {object} Workpiece\n * @property {string} workpieceId\n * \n * @typedef {object} Metadata\n * @property {string} [type]\n * @property {string} [workpieceId]\n * @property {Workpiece} [workpiece]\n * \n * @typedef {object} Action\n * @property {string} id\n * @property {string} command\n * @property {Metadata} metadata\n * \n * @typedef {object} Order\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} timestamp\n * @property {Action} action\n */\n\n/**\n * @param {string} id\n * @param {string} command\n * @returns {Order}\n */\nfunction createOrder(id, command) {\n    const newOrderUpdateId = (flow.get(\"orderUpdateId\") ?? 0) + 1;\n    flow.set(\"orderUpdateId\", newOrderUpdateId);\n    return {\n        timestamp: new Date().toISOString(),\n        orderId: id,\n        orderUpdateId: newOrderUpdateId,\n        action: {\n            id,\n            command,\n            metadata: {}\n        }\n    };\n}\n\nif (msg.nodeValue == true) {\n    /** @type {string} */\n    const txtTopicBase = flow.get(\"TXT_MQTT_topic\");\n    /** @type {string} */\n    const orderId = msg.payload.guid;\n    flow.set(\"orderId\", orderId);\n\n    flow.set(\"actionState\", {\n        id: orderId,\n        command: \"TO_INPUT\",\n        metadata: {}\n    });\n\n    msg.payload = createOrder(orderId, \"INPUT_RGB\");\n    msg.topic = txtTopicBase + \"/order\";\n    return msg;\n}\nreturn;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1900,
        "y": 1740,
        "wires": [
            [
                "83eb15f6b69aedf5"
            ]
        ]
    },
    {
        "id": "3b0e67df7c87f63d",
        "type": "subflow:7173b966cb38f0e0",
        "z": "616d25e29ffaadda",
        "name": "",
        "env": [
            {
                "name": "AVAILABLE_POSITIONS",
                "value": "CAMERA_HOME,CAMERA_HBW,PARK",
                "type": "str"
            }
        ],
        "x": 830,
        "y": 1780,
        "wires": []
    },
    {
        "id": "368132ae9f01185f",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "browser",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 810,
        "y": 1620,
        "wires": []
    },
    {
        "id": "d52c59f9fdaf1ec4",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "announceOutput",
        "func": "const moduleState = flow.get(\"moduleState\");\nif (moduleState == \"WP_INPUT\") {\n    // let robot abort\n    flow.set(\"moduleState\", \"WP_INPUT_ABORTED\");\n    return [msg, null];\n} else if (moduleState === \"IDLE\" || moduleState === \"OUTPUT_ANNOUNCED\") {\n    flow.set(\"moduleState\", \"OUTPUT_ANNOUNCED\");\n    return [null, null];\n} else if (moduleState != \"IDLE\") {\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1290,
        "y": 720,
        "wires": [
            [
                "6b4027de8d6ed9a9"
            ],
            [
                "89f3370e02e6073c"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "ab0e8b6f330d8f33",
        "type": "comment",
        "z": "616d25e29ffaadda",
        "name": "move-workpiece-to-output",
        "info": "",
        "x": 1650,
        "y": 60,
        "wires": []
    },
    {
        "id": "f15a01fae4db7abc",
        "type": "comment",
        "z": "616d25e29ffaadda",
        "name": "move-workpiece-to-fts",
        "info": "",
        "x": 1620,
        "y": 240,
        "wires": []
    },
    {
        "id": "ca9b37506bf3cf33",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "vda_status_loads",
        "func": "function createState() {\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n    const loads = [{ loadType: \"UNKNOWN\" }];\n    flow.set(\"loads\", loads);\n\n    state.headerId = headerId;\n    state.loads = loads;\n    state.actionState = null;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"state\", state);\n    return state;\n}\n\nif (msg.nodeValue == true) {\n    const state = createState();\n\n    msg.topic = flow.get(\"MQTT_topic\") + \"/state\";\n    msg.payload = state;\n    return msg;\n}\nreturn;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1690,
        "y": 1680,
        "wires": [
            [
                "66b392bb4886c28c"
            ]
        ]
    },
    {
        "id": "612ca12040facc01",
        "type": "data-generator",
        "z": "616d25e29ffaadda",
        "name": "generate-uuid",
        "field": "payload",
        "fieldType": "msg",
        "syntax": "json",
        "template": "{\n    \"guid\": \"{{guid}}\"\n}",
        "x": 1680,
        "y": 1740,
        "wires": [
            [
                "b04f17f4308fda6e"
            ]
        ]
    },
    {
        "id": "6e84866a5f4e20c3",
        "type": "switch",
        "z": "616d25e29ffaadda",
        "name": "actionState.command",
        "property": "payload.actionState.command",
        "propertyType": "msg",
        "rules": [
            {
                "t": "cont",
                "v": "INPUT_RGB",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "RGB_NFC",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "DROP",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "PICK",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "stopCalibration",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "announceOutput",
                "vt": "str"
            },
            {
                "t": "cont",
                "v": "cancelStorageOrder",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 7,
        "x": 1220,
        "y": 1320,
        "wires": [
            [
                "4f5cf4c672c61cdb"
            ],
            [
                "59323579ef4b1759"
            ],
            [
                "909a688b0fac08e3"
            ],
            [
                "909a688b0fac08e3"
            ],
            [
                "909a688b0fac08e3"
            ],
            [
                "909a688b0fac08e3"
            ],
            [
                "909a688b0fac08e3"
            ]
        ]
    },
    {
        "id": "ebfd503502c162cc",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "forward-to-sps-state",
        "func": "/**\n * @typedef {object} Load\n * @property {string} type\n * @property {string} [workpieceId]\n * \n * @typedef {object} Workpiece\n * @property {string} workpieceId\n * \n * @typedef {object} Metadata\n * @property {string} [type]\n * @property {string} [workpieceId]\n * @property {Workpiece} [workpiece]\n * \n * @typedef {object} Action\n * @property {string} id\n * @property {string} command\n * @property {string} [state]\n * @property {any} [result] \n * @property {Metadata} metadata\n */\n\n// if old actionState matches new actionState\n// discard message\n/** @type {Action} */\nconst oldActionState = flow.get(\"actionState\");\n/** @type {Action} */\nconst newActionState = msg.payload.actionState;\nif (newActionState.state != \"FINISHED\") {\n    return;\n}\n\n// The drop command was executed successfully\nflow.set(\"moduleState\", \"IDLE\");\nflow.set(\"actionState\", newActionState);\n\nif (newActionState.command == \"DROP\"\n     || newActionState.command == \"announceOutput\"\n     || newActionState.command == \"cancelStorageOrder\"\n    ) {\n    // If the successful command was drop, make sure\n    // to clear the loads.\n    const loads = [];\n    const state = flow.get(\"state\");\n    state.loads = loads;\n    flow.set(\"state\", state);\n    flow.set(\"loads\", loads);\n}\n\nflow.set(\"orderId\", \"0\");\nflow.set(\"orderUpdateId\", 0);\n\nif (newActionState.command == \"announceOutput\") {\n    // announceOutput reserves the module for the order with the given orderId\n    flow.set(\"orderId\", newActionState.metadata.orderId);\n    flow.set(\"orderUpdateId\", -1);\n    flow.set(\"moduleState\", \"OUTPUT_ANNOUNCED\");\n}\n\nconst spsTopic = flow.get(\"MQTT_topic\");\nmsg.payload.serialNumber = flow.get(\"serialNumber\");\nmsg.topic = spsTopic + \"/state\";\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1940,
        "y": 1380,
        "wires": [
            [
                "1f97a4188eef17aa"
            ]
        ]
    },
    {
        "id": "a31a3044eac31f4b",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "read-color",
        "func": "/**\n * @typedef {object} Load\n * @property {string} type\n * @property {string} [workpieceId]\n * \n * @typedef {object} Workpiece\n * @property {string} workpieceId\n * \n * @typedef {object} Metadata\n * @property {string} [type]\n * @property {string} [workpieceId]\n * @property {Workpiece} [workpiece]\n * \n * @typedef {object} Action\n * @property {string} id\n * @property {string} command\n * @property {string} [state]\n * @property {Metadata} metadata\n * \n * @typedef {object} Order\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} timestamp\n * @property {Action} action\n */\n\n/**\n * @param {boolean} isRed\n * @param {boolean} isWhite\n * @param {boolean} isBlue\n * @returns {Load}\n */\nfunction createLoad(isRed, isWhite, isBlue) {\n    let type = \"UNKNOWN\";\n    if (isRed && !isWhite && !isBlue) {\n        type = \"RED\";\n    } else if (!isRed && isWhite && !isBlue) {\n        type = \"WHITE\";\n    } else if (!isRed && !isWhite && isBlue) {\n        type = \"BLUE\";\n    }\n    return {\n        type\n    };\n}\n\n/**\n * @param {Load} load\n */\nfunction createState(load) {\n    /** @type {object} */\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n    const loads = [load];\n    flow.set(\"loads\", loads);\n\n    state.headerId = headerId;\n    state.loads = loads;\n    state.actionState = null;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"state\", state);\n    return state;\n}\n\n// if old actionState matches new actionState\n// discard message\n/** @type {Action} */\nconst oldActionState = flow.get(\"actionState\");\n/** @type {Action} */\nconst newActionState = msg.payload.actionState;\nif (newActionState.state != \"FINISHED\") {\n    return;\n}\n\n/** @type {boolean} */\nconst isRed = flow.get(\"calibration.state.status__farbbereich_rot.nodeValue\");\n/** @type {boolean} */\nconst isWhite = flow.get(\"calibration.state.status__farbbereich_weiss.nodeValue\");\n/** @type {boolean} */\nconst isBlue = flow.get(\"calibration.state.status__farbbereich_blau.nodeValue\");\n\n/** @type {Load} */\nconst load = createLoad(isRed, isWhite, isBlue);\nflow.set(\"actionState\", newActionState);\nconst state = createState(load);\n/** @type {string} */\nconst spsTopic = flow.get(\"MQTT_topic\");\nmsg.topic = spsTopic + \"/state\";\nmsg.payload = state;\nmsg.workpieceType = load.type;\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1900,
        "y": 1280,
        "wires": [
            [
                "1f97a4188eef17aa",
                "73b9a8cfa99a65e9"
            ]
        ]
    },
    {
        "id": "73b9a8cfa99a65e9",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "move-workpiece-to-nfc",
        "func": "/**\n * @typedef {object} Workpiece\n * @property {string} workpieceId\n * \n * @typedef {object} Metadata\n * @property {string} [type]\n * @property {string} [workpieceId]\n * @property {Workpiece} [workpiece]\n * \n * @typedef {object} Action\n * @property {string} id\n * @property {string} command\n * @property {string} [state]\n * @property {Metadata} metadata\n * \n * @typedef {object} Order\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} timestamp\n * @property {Action} action\n */\n\n/**\n * @param {string} id - the id of the order\n * @param {string} command - the command to execute\n * @param {string} type - the workpiece type\n * @returns {Order}\n */\nfunction createOrder(id, command, type) {\n    const newOrderUpdateId = (flow.get(\"orderUpdateId\") ?? 0) + 1;\n    flow.set(\"orderUpdateId\", newOrderUpdateId);\n    return {\n        timestamp: new Date().toISOString(),\n        orderId: id,\n        orderUpdateId: newOrderUpdateId,\n        action: {\n            id,\n            command,\n            metadata: {\n                type\n            }\n        }\n    };\n}\n\n/** @type {string} */\nconst txtTopicBase = flow.get(\"TXT_MQTT_topic\");\n/** @type {string} */\nconst orderId = msg.payload.orderId;\nflow.set(\"orderId\", orderId);\n/** @type {string} */\nconst workpieceType = msg.workpieceType;\n\nmsg.payload = createOrder(orderId, \"RGB_NFC\", workpieceType);\nmsg.topic = txtTopicBase + \"/order\";\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2180,
        "y": 1260,
        "wires": [
            [
                "71f010505de4b896",
                "631c7523cebe0901"
            ]
        ]
    },
    {
        "id": "7adcfe33557c586b",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "read-nfc-result",
        "func": "/**\n * @typedef {object} Load\n * @property {string} type\n * @property {string} [workpieceId]\n * \n * @typedef {object} Workpiece\n * @property {string} workpieceId\n * \n * @typedef {object} Metadata\n * @property {string} [type]\n * @property {string} [workpieceId]\n * @property {Workpiece} [workpiece]\n * \n * @typedef {object} Action\n * @property {string} id\n * @property {string} command\n * @property {string} [state]\n * @property {any} [result] \n * @property {Metadata} metadata\n */\n\n/**\n * @param {string} type\n * @param {string} workpieceId\n * @returns {Load}\n */\nfunction createLoad(type, workpieceId) {\n    return {\n        type,\n        workpieceId,\n    };\n}\n\n/**\n * @param {Action} actionState\n * @param {Load[]} loads\n */\nfunction createState(actionState, loads) {\n    /** @type {object} */\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n    flow.set(\"loads\", loads);\n\n    state.headerId = headerId;\n    state.loads = loads;\n    state.actionState = actionState;\n    state.timestamp = timestamp;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"state\", state);\n    return state;\n}\n\n// if old actionState matches new actionState\n// discard message\n/** @type {Action} */\nconst newActionState = msg.payload.actionState;\nif (newActionState.state != \"FINISHED\") {\n    return;\n}\n\n/** @type {Action} */\nconst actionState = msg.payload.actionStates[0] ?? {};\n/** @type {Metadata} */\nconst actionMetadata = actionState.metadata;\n/** @type {string} */\nconst spsStateTopic = flow.get(\"MQTT_topic\") + \"/state\";\nconst nfcResult = actionState.result ?? actionMetadata.result;\n\nif (!!nfcResult) {\n    // Update loads\n    // Send order \"wait_for_drop\"\n    const loads = [createLoad(actionMetadata.type, actionMetadata.result)];\n    const state = createState(actionState, loads);\n\n    msg.workpieceType = actionMetadata.type;\n    msg.workpieceId = nfcResult;\n    msg.topic = spsStateTopic;\n    msg.payload = state;\n\n    return msg;\n}\n\n// Move workpiece to NIO-Bin\n// clear loads\n// set moduleState to IDLE\nflow.set(\"moduleState\", \"IDLE\");\nconst state = createState(actionState, []);\nstate.actionState = actionState;\n\nmsg.topic = spsStateTopic;\nmsg.payload = state;\n\nflow.set(\"orderId\", \"0\");\nflow.set(\"orderUpdateId\", 0);\n\n\nreturn [null, msg];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1920,
        "y": 1320,
        "wires": [
            [
                "ac215b4ea1d849ae",
                "1f97a4188eef17aa"
            ],
            [
                "233f86057743ae7d",
                "1f97a4188eef17aa"
            ]
        ],
        "outputLabels": [
            "send-order-for-drop",
            "discard-workpiece-to-nio"
        ]
    },
    {
        "id": "ac215b4ea1d849ae",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "send-store-order",
        "func": "/**\n * @typedef {object} Workpiece\n * @property {string} workpieceId\n * \n * @typedef {object} Metadata\n * @property {string} [type]\n * @property {string} [workpieceId]\n * @property {Workpiece} [workpiece]\n * \n * @typedef {object} Action\n * @property {string} id\n * @property {string} command\n * @property {Metadata} metadata\n * \n * @typedef {object} Order\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} timestamp\n * @property {Action} action\n */\n\n/**\n * @param {string} command - the command to execute\n * @param {string} type - the workpiece type\n * @param {string} workpieceId - the id of the workpiece\n * @returns {Order}\n */\nfunction createOrder(command, type, workpieceId) {\n    const newOrderUpdateId = (flow.get(\"orderUpdateId\") ?? 0) + 1;\n    flow.set(\"orderUpdateId\", newOrderUpdateId);\n    return {\n        timestamp: new Date().toISOString(),\n        orderType: command,\n        type,\n        workpieceId,\n    };\n}\n\n// create order to store current workpiece\n\n/** @type {string} */\nconst ccuOrderTopic = \"ccu/order/request\"; // CCU-ORDER-TOPIC\n/** @type {string} */\nconst workpieceType = msg.workpieceType;\n/** @type {string} */\nconst workpieceId = msg.workpieceId;\n\nmsg.payload = createOrder(\"STORAGE\", workpieceType, workpieceId);\nmsg.topic = ccuOrderTopic;\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2170,
        "y": 1300,
        "wires": [
            [
                "a379cd4e88c43b43"
            ]
        ]
    },
    {
        "id": "233f86057743ae7d",
        "type": "function",
        "z": "616d25e29ffaadda",
        "d": true,
        "name": "discard-workpiece-to-nio",
        "func": "/**\n * @typedef {object} Workpiece\n * @property {string} workpieceId\n * \n * @typedef {object} Metadata\n * @property {string} [type]\n * @property {string} [workpieceId]\n * @property {Workpiece} [workpiece]\n * \n * @typedef {object} Action\n * @property {string} id\n * @property {string} command\n * @property {string} [state]\n * @property {Metadata} metadata\n * \n * @typedef {object} Order\n * @property {string} orderId\n * @property {number} orderUpdateId\n * @property {string} timestamp\n * @property {Action} action\n */\n\n/**\n * @param {string} id - the id of the order\n * @param {string} command - the command to execute\n * @returns {Order}\n */\nfunction createOrder(id, command) {\n    return {\n        timestamp: new Date().toISOString(),\n        orderId: id,\n        orderUpdateId: flow.get(\"orderUpdateId\"),\n        action: {\n            id,\n            command,\n            metadata: {}\n        }\n    };\n}\n\n/** @type {string} */\nconst txtTopicBase = flow.get(\"TXT_MQTT_topic\");\n/** @type {string} */\nconst orderId = msg.payload.orderId;\nflow.set(\"orderId\", orderId);\n\nmsg.payload = createOrder(orderId, \"NFC_NIO\");\nmsg.topic = txtTopicBase + \"/order\";\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2250,
        "y": 1360,
        "wires": [
            [
                "1f97a4188eef17aa"
            ]
        ]
    },
    {
        "id": "909a688b0fac08e3",
        "type": "delay",
        "z": "616d25e29ffaadda",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1640,
        "y": 1380,
        "wires": [
            [
                "ebfd503502c162cc"
            ]
        ]
    },
    {
        "id": "59323579ef4b1759",
        "type": "delay",
        "z": "616d25e29ffaadda",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1640,
        "y": 1320,
        "wires": [
            [
                "7adcfe33557c586b"
            ]
        ]
    },
    {
        "id": "4f5cf4c672c61cdb",
        "type": "delay",
        "z": "616d25e29ffaadda",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1640,
        "y": 1260,
        "wires": [
            [
                "a31a3044eac31f4b"
            ]
        ]
    },
    {
        "id": "71f010505de4b896",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "move-robot",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2770,
        "y": 1280,
        "wires": []
    },
    {
        "id": "83eb15f6b69aedf5",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "mqtt-not-retained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 2055,
        "y": 1740,
        "wires": []
    },
    {
        "id": "631c7523cebe0901",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "mqtt-not-retained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 2655,
        "y": 1200,
        "wires": []
    },
    {
        "id": "53b8ba0d43c3adbd",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "mqtt-not-retained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 2425,
        "y": 60,
        "wires": []
    },
    {
        "id": "7a082f983aa142c0",
        "type": "subflow:fb6b02d4d9963179",
        "z": "616d25e29ffaadda",
        "name": "",
        "x": 1650,
        "y": 340,
        "wires": [
            [
                "d0294086443d968b"
            ]
        ]
    },
    {
        "id": "2df5845a90f8f8de",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "MQTT_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1935,
        "y": 420,
        "wires": []
    },
    {
        "id": "6b4027de8d6ed9a9",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "send-instantAction-to-txt",
        "func": "/** @type {string} */\nconst txtTopicBase = flow.get(\"TXT_MQTT_topic\");\n/** @type {string} */\nconst spsSerial = flow.get(\"serialNumber\");\nmsg.topic = `${txtTopicBase}/instantAction`;\nmsg.payload.serialNumber = spsSerial;\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1590,
        "y": 400,
        "wires": [
            [
                "2df5845a90f8f8de"
            ]
        ]
    },
    {
        "id": "dde2e119f28adbae",
        "type": "comment",
        "z": "616d25e29ffaadda",
        "name": "The TXT-Controller does discard automatically. The command to move the workpiece to the NIO-Bin is currently not available for external use.",
        "info": "",
        "x": 2570,
        "y": 1400,
        "wires": []
    },
    {
        "id": "bc26a735805965bd",
        "type": "inject",
        "z": "616d25e29ffaadda",
        "g": "5218755bb1725ef8",
        "name": "Cam-Control",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "action",
                "v": "subscribe",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "/j1/txt/1/o/ptu",
        "x": 330,
        "y": 2160,
        "wires": [
            [
                "59f18557de90da57"
            ]
        ]
    },
    {
        "id": "59f18557de90da57",
        "type": "mqtt in",
        "z": "616d25e29ffaadda",
        "g": "5218755bb1725ef8",
        "name": "dynamic Connection",
        "topic": "",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "15b84ed331dcc49c",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 1,
        "x": 530,
        "y": 2160,
        "wires": [
            [
                "1bc0a242bc419c4f",
                "09b4b5a556d8a94a",
                "06d80e3d59c38d1c"
            ]
        ]
    },
    {
        "id": "1bc0a242bc419c4f",
        "type": "function",
        "z": "616d25e29ffaadda",
        "g": "5218755bb1725ef8",
        "name": "create-opcua-write",
        "func": "/**\n * @typedef {object} NodeInfo\n * @template T\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {T} nodeValue\n */\n\n/** @type {NodeInfo<number>} */\nconst posX = flow.get(\"calibration.state.befehl__bewegen_position_X\");\n/** @type {NodeInfo<number>} */\nconst posY = flow.get(\"calibration.state.befehl__bewegen_position_Y\");\n/** @type {NodeInfo<number>} */\nconst limitX = flow.get(\"calibration.state.kalib__grenze_x_oben\");\n/** @type {NodeInfo<number>} */\nconst limitY = flow.get(\"calibration.state.kalib__grenze_y_oben\");\n/** @type {NodeInfo<boolean>} */\nconst cmdHome = flow.get(\"calibration.state.befehl__HOME\");\n/** @type {NodeInfo<boolean>} */\nconst cmdMove = flow.get(\"calibration.state.befehl__BEWEGEN\");\n/** @type {NodeInfo<boolean>} */\nconst isMoving = flow.get(\"calibration.state.status__bewegen_aktiv\");\n\nlet nodesToWrite = [];\nlet valuesToWrite = [];\nconst moveCmd = msg.payload.cmd;\nmsg.moveCmd = moveCmd;\n/**\n * MoveDegree is sent as number (e.g. 20 -> 20°) but needs to be converted into the encoder ticks\n * Estimated conversion factor horizontal: 1400 ticks ~ 160° -> 1° ~ 9 ticks\n * Estimated conversion factor vertical: 700 ticks ~ 130° -> 1° ~ 6 ticks \n * \n */\nconst moveDegree = msg.payload.degree ?? 0;\nmsg.moveDegree = moveDegree || -1;\nconst allowedCmds = [\"home\", \"relmove_up\", \"relmove_down\", \"relmove_left\", \"relmove_right\", \"start_pan\", \"end_pan\", \"start_tilt\", \"end_tilt\"];\n\nnode.warn({ isIdle: isMoving.nodeValue == false });\nif (isMoving.nodeValue != false) {\n    return;\n}\nif (allowedCmds.indexOf(moveCmd) == -1) {\n    return;\n}\n\nswitch (moveCmd) {\n    case \"home\": {\n        nodesToWrite.push({ nodeName: cmdHome.nodeName, nodeId: cmdHome.nodeId, datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: true });\n        break;\n    }\n    case \"relmove_up\": {\n        const targetValue = Math.min(posY.nodeValue + moveDegree * 6, limitY.nodeValue);\n        nodesToWrite.push({ nodeName: posY.nodeName, nodeId: posY.nodeId, datatypeName: \"Int32\" });\n        valuesToWrite.push({ value: targetValue });\n        nodesToWrite.push({ nodeName: cmdMove.nodeName, nodeId: cmdMove.nodeId, datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: true });\n        break;\n    }\n    case \"relmove_down\": {\n        const targetValue = Math.max(posY.nodeValue - moveDegree * 6, 0);\n        nodesToWrite.push({ nodeName: posY.nodeName, nodeId: posY.nodeId, datatypeName: \"Int32\" });\n        valuesToWrite.push({ value: targetValue });\n        nodesToWrite.push({ nodeName: cmdMove.nodeName, nodeId: cmdMove.nodeId, datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: true });\n        break;\n    }\n    case \"relmove_left\": {\n        const targetValue = Math.max(posX.nodeValue - moveDegree * 9, 0);\n        nodesToWrite.push({ nodeName: posX.nodeName, nodeId: posX.nodeId, datatypeName: \"Int32\" });\n        valuesToWrite.push({ value: targetValue });\n        nodesToWrite.push({ nodeName: cmdMove.nodeName, nodeId: cmdMove.nodeId, datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: true });\n        break;\n    }\n    case \"relmove_right\": {\n        const targetValue = Math.min(posX.nodeValue + moveDegree * 9, limitX.nodeValue);\n        nodesToWrite.push({ nodeName: posX.nodeName, nodeId: posX.nodeId, datatypeName: \"Int32\" });\n        valuesToWrite.push({ value: targetValue });\n        nodesToWrite.push({ nodeName: cmdMove.nodeName, nodeId: cmdMove.nodeId, datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: true });\n        break;\n    }\n    case \"start_pan\": {\n        nodesToWrite.push({ nodeName: posX.nodeName, nodeId: posX.nodeId, datatypeName: \"Int32\" });\n        valuesToWrite.push({ value: 0 });\n        nodesToWrite.push({ nodeName: cmdMove.nodeName, nodeId: cmdMove.nodeId, datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: true });\n        break;\n    }\n    case \"end_pan\": {\n        nodesToWrite.push({ nodeName: posX.nodeName, nodeId: posX.nodeId, datatypeName: \"Int32\" });\n        valuesToWrite.push({ value: limitX.nodeValue });\n        nodesToWrite.push({ nodeName: cmdMove.nodeName, nodeId: cmdMove.nodeId, datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: true });\n        break;\n    }\n    case \"start_tilt\": {\n        nodesToWrite.push({ nodeName: posY.nodeName, nodeId: posY.nodeId, datatypeName: \"Int32\" });\n        valuesToWrite.push({ value: 0 });\n        nodesToWrite.push({ nodeName: cmdMove.nodeName, nodeId: cmdMove.nodeId, datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: true });\n        break;\n    }\n    case \"end_tilt\": {\n        nodesToWrite.push({ nodeName: posY.nodeName, nodeId: posY.nodeId, datatypeName: \"Int32\" });\n        valuesToWrite.push({ value: limitY.nodeValue });\n        nodesToWrite.push({ nodeName: cmdMove.nodeName, nodeId: cmdMove.nodeId, datatypeName: \"Boolean\" });\n        valuesToWrite.push({ value: true });\n        break;\n    }\n}\n\nmsg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite,\n    valuesToWrite\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 2160,
        "wires": [
            [
                "6ef8c2588adea0a2",
                "75f3c6b5c505a6a0"
            ]
        ]
    },
    {
        "id": "09b4b5a556d8a94a",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "g": "5218755bb1725ef8",
        "name": "move-cam-cmd",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload.cmd",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 780,
        "y": 2200,
        "wires": []
    },
    {
        "id": "06d80e3d59c38d1c",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "g": "5218755bb1725ef8",
        "name": "move-cam-degree",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload.degree",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 790,
        "y": 2260,
        "wires": []
    },
    {
        "id": "6ef8c2588adea0a2",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "g": "5218755bb1725ef8",
        "name": "before-write-order",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 2220,
        "wires": []
    },
    {
        "id": "75f3c6b5c505a6a0",
        "type": "OPCUA-IIoT-Write",
        "z": "616d25e29ffaadda",
        "g": "5218755bb1725ef8",
        "connector": "b58c2380ef5679ca",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1010,
        "y": 2160,
        "wires": [
            [
                "148850ccd1c7c024"
            ]
        ]
    },
    {
        "id": "148850ccd1c7c024",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "g": "5218755bb1725ef8",
        "name": "after-write-order",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1270,
        "y": 2220,
        "wires": []
    },
    {
        "id": "be811a9e51b23fa5",
        "type": "switch",
        "z": "616d25e29ffaadda",
        "name": "is operatingMode TEACHIN",
        "property": "payload.operatingMode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "TEACHIN",
                "vt": "str"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 1440,
        "y": 1180,
        "wires": [
            [
                "90499a667aa05928",
                "7e888ca5427b9145"
            ],
            [
                "6e84866a5f4e20c3",
                "341e95ef8376d27c"
            ]
        ]
    },
    {
        "id": "bc313d6f64d7e92c",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "forward TXT calibration state to module state",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number | string} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\n/**\n * @param {string} nodeName\n * @param {number} nodeValue\n * @returns {ReferenceData}\n */\nfunction createReferenceData(nodeName, nodeValue) {\n    return {\n        referenceKey: nodeName,\n        referenceValue: nodeValue,\n    };\n}\n\n/**\n * @returns {ReferenceData[]}\n */\nfunction createReferenceDataArray() {\n    /** @type {Record<string, CalibrationValue>} */\n    const calibrationState = flow.get(\"calibration.state\") ?? {};\n    /** @type {ReferenceData[]} */\n    return Object.keys(calibrationState)\n        .filter(key => key.indexOf(\"kalib__\") > -1 && key.indexOf(\"grenze\") == -1)\n        .reduce((agg, key) => {\n            const { nodeName, nodeValue } = calibrationState[key];\n            const refData = createReferenceData(nodeName, nodeValue);\n            return [\n                ...agg,\n                refData\n            ];\n        }, []);\n}\n\n/**\n * Expand existing information with dps calibration data \n */\nfunction expandCalibrationInfo(information) {\n    return information.map(data => {\n        if (data.infoType == \"calibration_status\") {\n            return {\n                ...data,\n                infoReferences: data.infoReferences.map(ref => {\n                    if (ref.referenceKey == \"POSITIONS.AVAILABLE\") {\n                        return {\n                            ...ref,\n                            referenceValue: `${ref.referenceValue},CAMERA_HOME,CAMERA_HBW`\n                        };\n                    }\n                    return ref;\n                }),\n            };\n        }\n        if (data.infoType == \"calibration_data\") {\n            const dpsRefData = createReferenceDataArray();\n            /** @type {ReferenceData[]} */\n            const filtered = data.infoReferences.filter(\n                (/** @type {ReferenceData} */ref) => !dpsRefData.some(dr => ref.referenceKey == dr.referenceKey)\n            );\n            return {\n                ...data,\n                infoReferences: [\n                    ...filtered,\n                    ...dpsRefData,\n                ],\n            }\n        }\n        return data;\n    });\n}\n\n/**\n * @param information\n */\nfunction createState(information) {\n    /** @type {object} */\n    const state = flow.get(\"state\");\n    const timestamp = new Date().toISOString();\n    const headerId = flow.get(\"headerId\");\n\n    state.headerId = headerId;\n    state.operatingMode = \"TEACHIN\";\n    state.timestamp = timestamp;\n    state.paused = true;\n    state.information = information;\n    state.orderId = flow.get(\"orderId\");\n    state.orderUpdateId = flow.get(\"orderUpdateId\");\n    const flowErrors = flow.get(\"errors\") ?? [];\n    state.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n    // headerId Update\n    flow.set(\"headerId\", headerId + 1);\n    flow.set(\"state\", state);\n    return state;\n}\n\nconst moduleState = flow.get(\"moduleState\");\nif (moduleState == \"CALIBRATION\") {\n    const updatedInformation = expandCalibrationInfo(msg.payload.information);\n    const state = createState(updatedInformation);\n    /** @type {string} */\n    const spsTopic = flow.get(\"MQTT_topic\");\n    msg.topic = spsTopic + \"/state\";\n    msg.payload = state;\n\n    return msg;\n}\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 1160,
        "wires": [
            [
                "1f97a4188eef17aa"
            ]
        ]
    },
    {
        "id": "278a3eca463b8d25",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "switch-state",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1720,
        "y": 1040,
        "wires": []
    },
    {
        "id": "90499a667aa05928",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "switch-teachin",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1710,
        "y": 1120,
        "wires": []
    },
    {
        "id": "341e95ef8376d27c",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "switch-otherwise",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1710,
        "y": 1200,
        "wires": []
    },
    {
        "id": "3bfb78db92b17372",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "WP input moduleState check",
        "func": "node.status({ fill: \"gray\", shape: \"ring\", text: `Input: ${msg.nodeValue}` });\nflow.set(\"workpieceInput\", msg.nodeValue);\nif (msg.nodeValue == false) {\n    // Skip processing for empty input\n    // and stop resending messages\n    return [null, { resend_ignore: true }];\n}\n\nconst spsSerial = flow.get(\"state.serialNumber\") ?? null;\nif (spsSerial == \"notReadYet\" || spsSerial == null) {\n    return [null, null];\n}\n\nif (flow.get(\"moduleState\") !== \"IDLE\") {\n    // Start resending messages while BUSY\n    return [null, null];\n};\n\nflow.set(\"moduleState\", \"WP_INPUT\");\n\n// Stop resending messages after successful processing\nreturn [msg, { resend_ignore: true }];",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1400,
        "y": 1680,
        "wires": [
            [
                "ca9b37506bf3cf33",
                "612ca12040facc01",
                "f1bf3def467a1762"
            ],
            [
                "e5dd9588fee4aeb9"
            ]
        ]
    },
    {
        "id": "a379cd4e88c43b43",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "manage moduleState and require WP_INPUT ",
        "func": "const moduleState = flow.get(\"moduleState\");\nif (moduleState == \"WP_INPUT\") {\n    flow.set(\"moduleState\", \"WP_INPUT_SENT\")\n    return msg;\n} else {\n    // do not publish when input is not active.\n    return null;\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2460,
        "y": 1300,
        "wires": [
            [
                "71f010505de4b896",
                "631c7523cebe0901"
            ]
        ]
    },
    {
        "id": "968729850bf85226",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "setStatusLED Ampel",
        "func": "const red = msg.payload.actions[0].metadata.red;\nconst yellow = msg.payload.actions[0].metadata.yellow;\nconst green = msg.payload.actions[0].metadata.green;\n\nmsg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: 'ns=4;i=19'/* red */, \"datatypeName\": \"Boolean\" },\n        { nodeId: 'ns=4;i=20'/* green */, \"datatypeName\": \"Boolean\" }, // in OPCUA ist die bennung aktuell vertauscht worden (20231011)\n        { nodeId: 'ns=4;i=21'/* yellow */, \"datatypeName\": \"Boolean\" } // in OPCUA ist die bennung aktuell vertauscht worden (20231011)\n    ],\n    valuesToWrite: [\n        { value: red },\n        { value: green },\n        { value: yellow }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 800,
        "wires": [
            [
                "0cac5a439a752db5"
            ]
        ]
    },
    {
        "id": "5c2d6a064396467b",
        "type": "inject",
        "z": "616d25e29ffaadda",
        "name": "setStatusLED testdummy",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "instantAction",
                "v": "setStatusLED",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "5",
        "topic": "",
        "payload": "{\"serialNumber\":\"SVR1D26982\",\"actions\":[{\"actionType\":\"setStatusLED\",\"actionId\":\"do not care\",\"metadata\":{\"red\":true,\"yellow\":true,\"green\":true}}]}",
        "payloadType": "json",
        "x": 690,
        "y": 500,
        "wires": [
            [
                "8109c87e0d84cd91"
            ]
        ]
    },
    {
        "id": "0cac5a439a752db5",
        "type": "OPCUA-IIoT-Write",
        "z": "616d25e29ffaadda",
        "connector": "b58c2380ef5679ca",
        "name": "Write Order",
        "justValue": true,
        "showStatusActivities": true,
        "showErrors": false,
        "x": 1730,
        "y": 800,
        "wires": [
            [
                "b4abf75459820104"
            ]
        ]
    },
    {
        "id": "b4abf75459820104",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "LED Update done",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2040,
        "y": 800,
        "wires": []
    },
    {
        "id": "2b95ee7a787aed1a",
        "type": "subflow:fb6b02d4d9963179",
        "z": "616d25e29ffaadda",
        "name": "",
        "x": 930,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "5261c88e9b6c126a",
        "type": "comment",
        "z": "616d25e29ffaadda",
        "name": "Early instantAction finish",
        "info": "Directly end instant action to clear module state from orderID",
        "x": 1010,
        "y": 700,
        "wires": []
    },
    {
        "id": "14e3b24a283e9316",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "order-for-txt",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2120,
        "y": 280,
        "wires": []
    },
    {
        "id": "99b3a9d7b07dce6b",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "cancelStorageOrder",
        "func": "const moduleState = flow.get(\"moduleState\");\nif (moduleState == \"WP_INPUT_SENT\") {\n    // let robot abort\n    flow.set(\"moduleState\", \"WP_INPUT_ABORTED\");\n    return [msg, null];\n} else if (moduleState != \"IDLE\") {\n    return [null, msg];\n}\n",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 760,
        "wires": [
            [
                "6b4027de8d6ed9a9"
            ],
            [
                "89f3370e02e6073c"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite",
            "error"
        ]
    },
    {
        "id": "3dab37aa17cac162",
        "type": "comment",
        "z": "616d25e29ffaadda",
        "name": "cancelStorageOrder",
        "info": "cancelStorageOrder is similar to announceOutput.\nThe difference is that it discards the workpiece \nafter the order has been sent and leves the module idle.\nAny new order will be accepted.",
        "x": 1370,
        "y": 1440,
        "wires": []
    },
    {
        "id": "773a8b1b302b8602",
        "type": "comment",
        "z": "616d25e29ffaadda",
        "name": "announceOutput",
        "info": "announceOutput will be received when the factory \nwants to deliver a manufactured workpiece to the DPS.\nDo nothing if the DPS is idle.\nAny input process is aborted if it is ongoing, \nunless the storage order has been sent already.",
        "x": 1360,
        "y": 1400,
        "wires": []
    },
    {
        "id": "e5dd9588fee4aeb9",
        "type": "msg-resend",
        "z": "616d25e29ffaadda",
        "interval": "10",
        "intervalUnit": "secs",
        "maximum": "60",
        "bytopic": false,
        "clone": false,
        "firstDelayed": false,
        "addCounters": false,
        "waitForResend": false,
        "highRate": true,
        "outputCountField": "",
        "outputMaxField": "",
        "name": "",
        "x": 1390,
        "y": 1760,
        "wires": [
            [
                "3bfb78db92b17372"
            ]
        ]
    },
    {
        "id": "f1bf3def467a1762",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "after-dsi",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1610,
        "y": 1840,
        "wires": []
    },
    {
        "id": "6a3050f1d6bb1ff8",
        "type": "OPCUA-IIoT-Inject",
        "z": "616d25e29ffaadda",
        "g": "9d1b70bc07095e3a",
        "injectType": "read",
        "payload": "",
        "payloadType": "date",
        "topic": "readSerial",
        "repeat": "15",
        "crontab": "",
        "once": true,
        "startDelay": "20",
        "name": "serialnumber",
        "addressSpaceItems": [
            {
                "name": "SerialNumber",
                "nodeId": "ns=3;s=SerialNumber",
                "datatypeName": "String"
            },
            {
                "name": "modell",
                "nodeId": "ns=4;i=2",
                "datatypeName": "String"
            }
        ],
        "x": 180,
        "y": 380,
        "wires": [
            [
                "c315836ebc16f905",
                "51a0da5752d71ee6"
            ]
        ]
    },
    {
        "id": "c315836ebc16f905",
        "type": "OPCUA-IIoT-Read",
        "z": "616d25e29ffaadda",
        "g": "9d1b70bc07095e3a",
        "attributeId": "0",
        "maxAge": 1,
        "depth": 1,
        "connector": "b58c2380ef5679ca",
        "name": "Read serial",
        "justValue": false,
        "showStatusActivities": true,
        "showErrors": true,
        "parseStrings": true,
        "historyDays": 1,
        "x": 370,
        "y": 340,
        "wires": [
            [
                "51a0da5752d71ee6"
            ]
        ]
    },
    {
        "id": "51a0da5752d71ee6",
        "type": "subflow:468f2460ce66f11e",
        "z": "616d25e29ffaadda",
        "g": "9d1b70bc07095e3a",
        "name": "",
        "x": 590,
        "y": 380,
        "wires": [
            [
                "5743940d1df62fa0"
            ]
        ]
    },
    {
        "id": "89f3370e02e6073c",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "publish errorState",
        "func": "// Timestamp\nlet now = new Date();\nlet timestamp = now.toISOString();\n\n// state bauen\nlet state = flow.get(\"state\");\nstate.headerId = flow.get(\"headerId\");\nstate.loads = flow.get(\"loads\");\nstate.actionState = flow.get(\"actionState\");\nstate.actionState.state = \"FAILED\";\nstate.timestamp = timestamp;\nstate.orderId = flow.get(\"orderId\");\nstate.orderUpdateId = flow.get(\"orderUpdateId\");\nconst flowErrors = flow.get(\"errors\") ?? [];\nstate.errors = Array.isArray(flowErrors) ? flowErrors : [flowErrors];\n\n// Flow Update\nflow.set(\"errors\", []);\nflow.set(\"headerId\", state.headerId + 1);\n\nmsg.topic = flow.get(\"MQTT_topic\") + \"/state\";\nmsg.payload = state\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1910,
        "y": 620,
        "wires": [
            [
                "d0294086443d968b"
            ]
        ]
    },
    {
        "id": "c71907b47cada35d",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "after-switch",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1270,
        "y": 380,
        "wires": []
    },
    {
        "id": "dea6fd6d90068cda",
        "type": "function",
        "z": "616d25e29ffaadda",
        "name": "reset",
        "func": "/**\n * @typedef {object} ActionMetadata\n * @property {string} [position]\n * @property {boolean} [factory]\n * @property {{referenceKey: string, referenceValue: number}[]} [references]\n * \n * @typedef {object} Action\n * @property {\"startCalibration\" \n *    | \"stopCalibration\" \n *    | \"setCalibrationValues\" \n *    | \"storeCalibrationValues\" \n *    | \"selectCalibrationPosition\" \n *    | \"testCalibrationPosition\" \n *    | \"resetCalibration\"} actionType\n * @property {string} actionId\n * @property {ActionMetadata} metadata\n * \n * @typedef {object} CalibrationInstantAction\n * @property {string} serialNumber\n * @property {Date} timestamp\n * @property {Action[]} actions\n * \n * @typedef {object} ReferenceData\n * @property {string} referenceKey\n * @property {number} referenceValue\n * \n * @typedef {object} CalibrationData\n * @property {string} infoType\n * @property {string} infoLevel\n * @property {ReferenceData[]} infoReferences\n * \n * @typedef {object} CalibrationValue\n * @property {string} nodeId\n * @property {string} nodeName\n * @property {string} nodeValue\n */\n\nmsg.payload = {\n    nodetype: 'inject',\n    injectType: 'write',\n    nodesToWrite: [\n        { nodeId: \"ns=4;i=42\", \"datatypeName\": \"Boolean\" }\n    ],\n    valuesToWrite: [\n        { value: true }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 840,
        "wires": [
            [
                "6748aa914e24d9ba"
            ]
        ],
        "inputLabels": [
            "instantAction"
        ],
        "outputLabels": [
            "opcuaWrite"
        ]
    },
    {
        "id": "bd22af298bcaaeec",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1780,
        "y": 540,
        "wires": []
    },
    {
        "id": "fcbb28ea3b4f0f39",
        "type": "debug",
        "z": "616d25e29ffaadda",
        "name": "debug 4",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 920,
        "wires": []
    },
    {
        "id": "7e888ca5427b9145",
        "type": "delay",
        "z": "616d25e29ffaadda",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1700,
        "y": 1160,
        "wires": [
            [
                "bc313d6f64d7e92c"
            ]
        ]
    },
    {
        "id": "75b7426ef58f12b5",
        "type": "link out",
        "z": "616d25e29ffaadda",
        "name": "mqtt_notRetained",
        "mode": "link",
        "links": [
            "b868e3d26bf1f789"
        ],
        "x": 1035,
        "y": 980,
        "wires": []
    }
]